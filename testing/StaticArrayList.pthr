def std = @import("std");



type TypeSystemEscape = struct <{T: Type}> {
	func get = (this) #unsafe -> T* { return std.bit.bitCast<{T*}>(this.data.data()); }
	func get = (this mut) #unsafe -> T*mut { return std.bit.bitCast<{T*mut}>(this.data.data()); }
	func getUninit = (this mut) #unsafe -> T*! { return std.bit.bitCast<{T*!}>(this.data.data()); }
	
	var data: [Byte:std.types.numBytes<{T}>()] #priv;
}


type StaticArrayList = struct <{T: Type, CAPACITY: USize}> #pub {
	func new = () -> (output: This) {
		output._data = new [TypeSystemEscape<{T}>:CAPACITY]();
		output._size = 0;
		return...;
	}


	func new = (data: [T:*]) -> (output: This) {
		output = new This();

		for(data) [_; value: T] {
			output.append().* = copy value;
		}

		return...;
	}


	when(std.types.isTriviallyDeletable<{T}>() == false){
		func delete = (this mut) -> Void {
			for(this as [T:*mut]) [_; elem: T mut] {
				unsafe{ delete elem; }
			}
		}
	}


	when(std.types.isNoErrorCopyable<{T}>()){
		func copy = (this)
			#rt(std.types.isComptimeCopyable<{T}>() == false) #unsafe(std.types.isSafeCopyable<{T}>() == false)
		-> (output: This) {
			output._data = new [TypeSystemEscape<{T}>:CAPACITY]();
			output._size = copy this._size;

			std.mem.copyBuffer(output as [T:*mut], this as [T:*]);

			return...;
		}
	}
	

	when(std.types.isNoErrorMovable<{T}>()){
		func move = (this mut)
			#rt(std.types.isComptimeMovable<{T}>() == false) #unsafe(std.types.isSafeMovable<{T}>() == false)
		-> (output: This) {
			output._data = new [TypeSystemEscape<{T}>:CAPACITY]();
			output._size = copy this._size;

			std.mem.moveBuffer(output as [T:*mut], this as [T:*mut]);
			
			return...;
		}
	}




	///////////////////////////////////
	// element access

	func [] = (this, index: USize) -> T* { unsafe{ return this._data[index].get(); } }
	func [] = (this mut, index: USize) -> T*mut { unsafe{ return this._data[index].get(); } }

	func first = (this) -> T* { return this[0]; }
	func first = (this mut) -> T*mut { return this[0]; }

	func last = (this) -> T* { return this[this.size() - 1]; }
	func last = (this mut) -> T*mut { return this[this.size() - 1]; }

	func data = (this) -> T* { return this[0]; }
	func data = (this mut) -> T*mut { return this[0]; }



	///////////////////////////////////
	// capacity

	func isEmpty = (this) -> Bool { return this.size() == 0; }
	func size = (this) -> USize { return copy this._size; }
	func capacity = () -> USize { return CAPACITY; }


	///////////////////////////////////
	// modifiers

	func clear = (this mut) -> Void {
		for(this as [T:*mut]) [_; elem: T mut] {
			unsafe{ delete elem; }
		}

		this._size = 0;
	}


	func append = (this mut) -> T*! {
		this._size += 1;

		unsafe{ return this._data[this._size - 1].getUninit(); }
	}

	func pop = (this mut) -> Void {
		unsafe{ delete this.last().*; }
		this._size -= 1;
	}

	func popExtract = (this mut) -> (output: T) {
		unsafe{ output = move this.last().*; }
		this._size -= 1;
		return...;
	}


	///////////////////////////////////
	// type conversion

	func as = (this) #implicit -> [T:*] { return new [T:*](this.data(), this.size()); }
	func as = (this mut) #implicit -> [T:*mut] { return new [T:*mut](this.data(), this.size()); }


	///////////////////////////////////
	// iterators

	impl @pthr.Iterable{
		createIterator = (this) -> impl(std.ArrayRefIter<{[T:*]}>:@pthr.Iterator) {
			return new impl(std.ArrayRefIter<{[T:*]}>:@pthr.Iterator)(this as [T:*]);
		},
		createIterator = (this mut) -> impl(std.MutArrayRefIter<{[T:*mut]}>:@pthr.MutIterator) {
			return new impl(std.MutArrayRefIter<{[T:*mut]}>:@pthr.MutIterator)(this as [T:*mut]);
		},
	}


	impl @pthr.IterableRT{
		createIterator = (this) -> impl(std.ArrayRefIter<{[T:*]}>:@pthr.IteratorRT) {
			return new impl(std.ArrayRefIter<{[T:*]}>:@pthr.IteratorRT)(this as [T:*]);
		},
		createIterator = (this mut) -> impl(std.MutArrayRefIter<{[T:*mut]}>:@pthr.MutIteratorRT) {
			return new impl(std.MutArrayRefIter<{[T:*mut]}>:@pthr.MutIteratorRT)(this as [T:*mut]);
		},
	}




	///////////////////////////////////
	// member vars

	var _data: [TypeSystemEscape<{T}>:CAPACITY] #priv;
	var _size: USize;
}
