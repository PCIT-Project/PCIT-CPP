def std = @import("std");



type TypeSystemEscape = struct <{T: Type}> {
	func get = (this) #unsafe -> T* { return std.bitCast<{T*}>(this.data.data()); }
	func get = (this mut) #unsafe -> T*mut { return std.bitCast<{T*mut}>(this.data.data()); }
	func getUninit = (this mut) #unsafe -> T*! { return std.bitCast<{T*!}>(this.data.data()); }
	
	var data: [Byte:std.types.numBytes<{T}>()] #priv;
}


type StaticArrayList = struct <{T: Type, CAPACITY: USize}> #pub {
	func new = () -> (output: This) {
		output._data = new [TypeSystemEscape<{T}>:CAPACITY]();
		output._size = 0;
		return...;
	}


	when(std.types.isNoErrorCopyable<{T}>()){
		func new = (data: [T:*])
			#rt(std.types.isComptimeCopyable<{T}>() == false) #unsafe(std.types.isSafeCopyable<{T}>() == false)
		-> (output: This) {
			output._data = new [TypeSystemEscape<{T}>:CAPACITY]();
			output._size = data.size();

			std.mem.copyBuffer(output as [T:*mut], data);
			return...;
		}
	}


	when(std.types.isTriviallyDeletable<{T}>() == false){
		func delete = (this mut) #rt(std.types.isComptimeDeletable<{T}>() == false) -> Void {
			for(this as [T:*mut]) [_; elem: T mut] {
				unsafe{ delete elem; }
			}
		}
	}


	when(std.types.isNoErrorCopyable<{T}>()){
		func copy = (this)
			#rt(std.types.isComptimeCopyable<{T}>() == false) #unsafe(std.types.isSafeCopyable<{T}>() == false)
		-> (output: This) {
			output._data = new [TypeSystemEscape<{T}>:CAPACITY]();
			output._size = this.size();

			std.mem.copyBuffer(output as [T:*mut], this as [T:*]);

			return...;
		}
	}else{
		func copy = delete;
	}


	when(std.types.isNoErrorMovable<{T}>()){
		func move = (this mut)
			#rt(std.types.isComptimeMovable<{T}>() == false) #unsafe(std.types.isSafeMovable<{T}>() == false)
		-> (output: This) {
			output._data = new [TypeSystemEscape<{T}>:CAPACITY]();
			output._size = this.size();

			std.mem.moveBuffer(output as [T:*mut], this as [T:*mut]);
			
			return...;
		}
	}else{
		func move = delete;
	}




	///////////////////////////////////
	// element access

	func [] = (this, index: USize) -> T* { unsafe{ return this._data[index].get(); } }
	func [] = (this mut, index: USize) -> T*mut { unsafe{ return this._data[index].get(); } }

	func first = (this) -> T* { return this[0]; }
	func first = (this mut) -> T*mut { return this[0]; }

	func last = (this) -> T* { return this[this.size() - 1]; }
	func last = (this mut) -> T*mut { return this[this.size() - 1]; }

	func data = (this) -> T* { return this[0]; }
	func data = (this mut) -> T*mut { return this[0]; }



	///////////////////////////////////
	// capacity

	func isEmpty = (this) -> Bool { return this.size() == 0; }
	func size = (this) -> USize { return copy this._size; }
	func capacity = () -> USize { return CAPACITY; }


	///////////////////////////////////
	// modifiers

	func clear = (this mut) #rt(std.types.isComptimeDeletable<{T}>()) -> Void {
		when(std.types.isTriviallyDeletable<{T}>() == false){
			for(this as [T:*mut]) [_; elem: T mut] {
				unsafe{ delete elem; }
			}
		}

		this._size = 0;
	}


	func append = (this mut) -> T*! {
		this._size += 1;

		unsafe{ return this._data[this._size - 1].getUninit(); }
	}

	func pop = (this mut) #rt(std.types.isComptimeDeletable<{T}>() == false) -> Void {
		when(std.types.isTriviallyDeletable<{T}>() == false){
			unsafe{ delete this.last().*; }
		}
		this._size -= 1;
	}

	when(std.types.isNoErrorMovable<{T}>()){
		func popExtract = (this mut) 
			#rt(std.types.isComptimeMovable<{T}>() == false) #unsafe(std.types.isSafeMovable<{T}>() == false)
		-> (output: T) {
			// TODO(FUTURE): remove warning about unsafe in unsafe
			unsafe{ output = move this.last().*; }
			this._size -= 1;
			return...;
		}

	}else when(std.types.isNoErrorCopyable<{T}>()){
		func popExtract = (this mut) 
			#rt(std.types.isComptimeCopyable<{T}>() == false || std.types.isComptimeDeletable<{T}>() == false)
			#unsafe(std.types.isSafeCopyable<{T}>())
		-> (output: T) {
			output = copy this.last().*;
			this.pop();
			return...;
		}
	}


	///////////////////////////////////
	// type conversion

	func as = (this) #implicit -> [T:*] { return new [T:*](this.data(), this.size()); }
	func as = (this mut) #implicit -> [T:*mut] { return new [T:*mut](this.data(), this.size()); }


	///////////////////////////////////
	// iterators

	impl @pthr.Iterable{
		createIterator = (this) -> impl(std.ArrayRefIter<{[T:*]}>:@pthr.Iterator) {
			return new impl(std.ArrayRefIter<{[T:*]}>:@pthr.Iterator)(this as [T:*]);
		},
		createIterator = (this mut) -> impl(std.MutArrayRefIter<{[T:*mut]}>:@pthr.MutIterator) {
			return new impl(std.MutArrayRefIter<{[T:*mut]}>:@pthr.MutIterator)(this as [T:*mut]);
		},
	}


	impl @pthr.IterableRT{
		createIterator = (this) -> impl(std.ArrayRefIter<{[T:*]}>:@pthr.IteratorRT) {
			return new impl(std.ArrayRefIter<{[T:*]}>:@pthr.IteratorRT)(this as [T:*]);
		},
		createIterator = (this mut) -> impl(std.MutArrayRefIter<{[T:*mut]}>:@pthr.MutIteratorRT) {
			return new impl(std.MutArrayRefIter<{[T:*mut]}>:@pthr.MutIteratorRT)(this as [T:*mut]);
		},
	}




	///////////////////////////////////
	// member vars

	var _data: [TypeSystemEscape<{T}>:CAPACITY] #priv;
	var _size: USize #priv;
}
