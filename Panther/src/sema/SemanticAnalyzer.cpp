////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
// Part of PCIT-CPP, under the Apache License v2.0 with LLVM and PCIT exceptions. //
// You may not use this file except in compliance with the License.               //
// See `https://github.com/PCIT-Project/PCIT-CPP/blob/main/LICENSE`for info.      //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////


#include "./SemanticAnalyzer.h"

#include <queue>
#include <ranges>

#include "../symbol_proc/SymbolProcBuilder.h"
#include "./attributes.h"
#include "./ComptimeIntrinsicEvaluator.h"


#if defined(EVO_COMPILER_MSVC)
	#pragma warning(default : 4062)
#endif

namespace pcit::panther{

	using Instruction = SymbolProc::Instruction;



	//////////////////////////////////////////////////////////////////////
	// semantic analyzer


	auto SemanticAnalyzer::analyze() -> void {
		if(this->symbol_proc.passedOnByWhenCond()){ return; }

		
		{
			const auto lock = std::scoped_lock(this->symbol_proc.waiting_for_lock);
			this->symbol_proc.setStatusWorking();
		}


		EVO_DEFER([&](){
			evo::debugAssert(
				this->symbol_proc.status != SymbolProc::Status::WORKING, "Symbol Proc being worked on should be false"
			);
		});

		while(this->symbol_proc.isAtEnd() == false){
			#if defined(PCIT_CONFIG_DEBUG)
				{
					// separate var to prevent debugging race conditons
					const SymbolProc::Status current_status = this->symbol_proc.status.load();
					evo::debugAssert(
						current_status == SymbolProc::Status::WORKING,
						"Symbol Proc should only be working if the status is `WORKING`"
					);
				}
			#endif

			switch(this->analyze_instr(this->symbol_proc.getInstruction())){
				case Result::SUCCESS: {
					this->symbol_proc.nextInstruction();
				} break;

				case Result::ERROR: {
					this->context.symbol_proc_manager.symbol_proc_done();

					if(this->symbol_proc.extra_info.is<SymbolProc::StructInfo>()){
						SymbolProc::StructInfo& struct_info = this->symbol_proc.extra_info.as<SymbolProc::StructInfo>();
						if(struct_info.instantiation != nullptr){ struct_info.instantiation->errored = true; }

					}else if(this->symbol_proc.extra_info.is<SymbolProc::FuncInfo>()){
						SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();
						if(func_info.instantiation != nullptr){
							func_info.instantiation->errored_reason = 
								sema::TemplatedFunc::Instantiation::ErroredReasonErroredAfterDecl();
						}
					}

					this->symbol_proc.setStatusErrored();
					return;
				} break;

				case Result::RECOVERABLE_ERROR: {
					evo::unimplemented("recoverable errors");
					// this->symbol_proc.status = SymbolProc::Status::ERRORED;
					// if(this->symbol_proc.extra_info.is<SymbolProc::StructInfo>()){
					// 	SymbolProc::StructInfo& struct_info = this->symbol_proc.extra_info.as<SymbolProc::StructInfo>();
					// 	if(struct_info.instantiation != nullptr){ struct_info.instantiation->errored = true; }
					// }
					// this->symbol_proc.nextInstruction();
				} break;

				case Result::ERROR_NO_REPORT: {
					this->symbol_proc.setInstructionIndex(
						SymbolProc::InstructionIndex(uint32_t(this->symbol_proc.instructions.size()))
					);
				} break;

				case Result::NEED_TO_WAIT: {
					const auto lock = std::scoped_lock(this->symbol_proc.waiting_for_lock);

					 // prevent race condition
					if(this->symbol_proc.waiting_for.empty() && this->symbol_proc.is_waiting_for_builtin == false){
						continue;
					}
					
					this->symbol_proc.setStatusWaiting();
					return;
				} break;

				case Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR: {
					const auto lock = std::scoped_lock(this->symbol_proc.waiting_for_lock);

					this->symbol_proc.nextInstruction();
					
					 // prevent race condition
					if(this->symbol_proc.waiting_for.empty() && this->symbol_proc.is_waiting_for_builtin == false){
						continue;
					}

					this->symbol_proc.setStatusWaiting();
					return;
				} break;

				case Result::SUSPEND: {
					const auto lock = std::scoped_lock(this->symbol_proc.waiting_for_lock);

					this->symbol_proc.nextInstruction();
					
					this->symbol_proc.setStatusSuspended();

					if(this->scope.getCurrentEncapsulatingSymbol().is<sema::Func::ID>()){
						sema::Func& sema_func = this->context.sema_buffer.funcs[
							this->scope.getCurrentEncapsulatingSymbol().as<sema::Func::ID>()
						];

						sema_func.status = sema::Func::Status::SUSPENDED;
					}

					this->context.symbol_proc_manager.symbol_proc_suspended();
					return;
				} break;
			}
		}

		this->context.symbol_proc_manager.symbol_proc_done();
		this->symbol_proc.setStatusDone();
	}


	auto SemanticAnalyzer::analyze_instr(const Instruction& instr) -> Result {
		switch(instr.kind()){
			case Instruction::Kind::SUSPEND_SYMBOL_PROC:
				return this->instr_suspend_symbol_proc();

			case Instruction::Kind::NON_LOCAL_VAR_DECL:
				return this->instr_non_local_var_decl(this->context.symbol_proc_manager.getNonLocalVarDecl(instr));

			case Instruction::Kind::NON_LOCAL_VAR_DEF:
				return this->instr_non_local_var_def(this->context.symbol_proc_manager.getNonLocalVarDef(instr));

			case Instruction::Kind::NON_LOCAL_VAR_DECL_DEF:
				return this->instr_non_local_var_decl_def(
					this->context.symbol_proc_manager.getNonLocalVarDeclDef(instr)
				);

			case Instruction::Kind::WHEN_COND:
				return this->instr_when_cond(this->context.symbol_proc_manager.getWhenCond(instr));

			case Instruction::Kind::ALIAS:
				return this->instr_alias(this->context.symbol_proc_manager.getAlias(instr));

			case Instruction::Kind::STRUCT_DECL_INSTANTIATION:
				return this->instr_struct_decl<true>(
					this->context.symbol_proc_manager.getStructDeclInstatiation(instr)
				);

			case Instruction::Kind::STRUCT_DECL:
				return this->instr_struct_decl<false>(this->context.symbol_proc_manager.getStructDecl(instr));

			case Instruction::Kind::STRUCT_DEF:
				return this->instr_struct_def();

			case Instruction::Kind::STRUCT_CREATED_SPECIAL_MEMBERS_PIR_IF_NEEDED:
				return this->instr_struct_created_sepcial_members_pir_if_needed();

			case Instruction::Kind::TEMPLATE_STRUCT:
				return this->instr_template_struct(this->context.symbol_proc_manager.getTemplateStruct(instr));

			case Instruction::Kind::UNION_DECL:
				return this->instr_union_decl(this->context.symbol_proc_manager.getUnionDecl(instr));

			case Instruction::Kind::UNION_ADD_FIELDS:
				return this->instr_union_add_fields(this->context.symbol_proc_manager.getUnionAddFields(instr));

			case Instruction::Kind::UNION_DEF:
				return this->instr_union_def();

			case Instruction::Kind::ENUM_DECL:
				return this->instr_enum_decl(this->context.symbol_proc_manager.getEnumDecl(instr));

			case Instruction::Kind::ENUM_ADD_ENUMERATORS:
				return this->instr_enum_add_enumerators(this->context.symbol_proc_manager.getEnumAddEnumerators(instr));

			case Instruction::Kind::ENUM_DEF:
				return this->instr_enum_def();

			case Instruction::Kind::FUNC_DECL_EXTRACT_DEDUCERS:
				return this->instr_func_decl_extract_deducers(
					this->context.symbol_proc_manager.getFuncDeclExtractDeducers(instr)
				);

			case Instruction::Kind::FUNC_DECL_INSTANTIATION:
				return this->instr_func_decl<true>(this->context.symbol_proc_manager.getFuncDeclInstantiation(instr));

			case Instruction::Kind::FUNC_DECL:
				return this->instr_func_decl<false>(this->context.symbol_proc_manager.getFuncDecl(instr));

			case Instruction::Kind::FUNC_PRE_BODY:
				return this->instr_func_pre_body(this->context.symbol_proc_manager.getFuncPreBody(instr));

			case Instruction::Kind::FUNC_DEF:
				return this->instr_func_def(this->context.symbol_proc_manager.getFuncDef(instr));

			case Instruction::Kind::FUNC_PREPARE_COMPTIME_PIR_IF_NEEDED:
				return this->instr_func_prepare_comptime_pir_if_needed(
					this->context.symbol_proc_manager.getFuncPrepareComptimePIRIfNeeded(instr)
				);

			case Instruction::Kind::FUNC_COMPTIME_PIR_READY_IF_NEEDED:
				return this->instr_func_comptime_pir_ready_if_needed();

			case Instruction::Kind::TEMPLATE_FUNC_BEGIN:
				return this->instr_template_func_begin(this->context.symbol_proc_manager.getTemplateFuncBegin(instr));

			case Instruction::Kind::TEMPLATE_FUNC_SET_PARAM_IS_DEDUCER:
				return this->instr_template_set_param_is_deducer(
					this->context.symbol_proc_manager.getTemplateFuncSetParamIsDeducer(instr)
				);

			case Instruction::Kind::TEMPLATE_FUNC_END:
				return this->instr_template_func_end(this->context.symbol_proc_manager.getTemplateFuncEnd(instr));

			case Instruction::Kind::DELETED_SPECIAL_METHOD:
				return this->instr_deleted_special_method(
					this->context.symbol_proc_manager.getDeletedSpecialMethod(instr)
				);

			case Instruction::Kind::FUNC_ALIAS_DEF:
				return this->instr_func_alias_def(this->context.symbol_proc_manager.getFuncAliasDef(instr));

			case Instruction::Kind::INTERFACE_PREPARE:
				return this->instr_interface_prepare(this->context.symbol_proc_manager.getInterfacePrepare(instr));

			case Instruction::Kind::INTERFACE_DECL:
				return this->instr_interface_decl();

			case Instruction::Kind::INTERFACE_DEF:
				return this->instr_interface_def();

			case Instruction::Kind::INTERFACE_FUNC_DEF:
				return this->instr_interface_func_def(this->context.symbol_proc_manager.getInterfaceFuncDef(instr));

			case Instruction::Kind::INTERFACE_IMPL_DECL:
				return this->instr_interface_impl_decl(this->context.symbol_proc_manager.getInterfaceImplDecl(instr));

			case Instruction::Kind::INTERFACE_IN_DEF_IMPL_DECL:
				return this->instr_interface_in_def_impl_decl(
					this->context.symbol_proc_manager.getInterfaceInDefImplDecl(instr)
				);

			case Instruction::Kind::INTERFACE_DEDUCER_IMPL_INSTANTIATION_DECL:
				return this->instr_interface_deducer_impl_instantiation_decl(
					this->context.symbol_proc_manager.getInterfaceDeducerImplInstantiationDecl(instr)
				);

			case Instruction::Kind::INTERFACE_IMPL_METHOD_LOOKUP:
				return this->instr_interface_impl_method_lookup(
					this->context.symbol_proc_manager.getInterfaceImplMethodLookup(instr)
				);

			case Instruction::Kind::INTERFACE_IN_DEF_IMPL_METHOD:
				return this->instr_interface_in_def_impl_method(
					this->context.symbol_proc_manager.getInterfaceInDefImplMethod(instr)
				);

			case Instruction::Kind::INTERFACE_IMPL_DEF:
				return this->instr_interface_impl_def(this->context.symbol_proc_manager.getInterfaceImplDef(instr));

			case Instruction::Kind::INTERFACE_IMPL_COMPTIME_PIR:
				return this->instr_interface_impl_comptime_pir();

			case Instruction::Kind::LOCAL_VAR:
				return this->instr_local_var(this->context.symbol_proc_manager.getLocalVar(instr));

			case Instruction::Kind::LOCAL_FUNC_ALIAS:
				return this->instr_local_func_alias(this->context.symbol_proc_manager.getLocalFuncAlias(instr));

			case Instruction::Kind::LOCAL_ALIAS:
				return this->instr_local_alias(this->context.symbol_proc_manager.getLocalAlias(instr));

			case Instruction::Kind::RETURN:
				return this->instr_return(this->context.symbol_proc_manager.getReturn(instr));

			case Instruction::Kind::LABELED_RETURN:
				return this->instr_labeled_return(this->context.symbol_proc_manager.getLabeledReturn(instr));

			case Instruction::Kind::ERROR:
				return this->instr_error(this->context.symbol_proc_manager.getError(instr));

			case Instruction::Kind::UNREACHABLE:
				return this->instr_unreachable(this->context.symbol_proc_manager.getUnreachable(instr));

			case Instruction::Kind::BREAK:
				return this->instr_break(this->context.symbol_proc_manager.getBreak(instr));

			case Instruction::Kind::CONTINUE:
				return this->instr_continue(this->context.symbol_proc_manager.getContinue(instr));

			case Instruction::Kind::DELETE:
				return this->instr_delete(this->context.symbol_proc_manager.getDelete(instr));

			case Instruction::Kind::BEGIN_COND:
				return this->instr_begin_cond(this->context.symbol_proc_manager.getBeginCond(instr));

			case Instruction::Kind::COND_NO_ELSE:
				return this->instr_cond_no_else();

			case Instruction::Kind::COND_ELSE:
				return this->instr_cond_else();

			case Instruction::Kind::COND_ELSE_IF:
				return this->instr_cond_else_if();

			case Instruction::Kind::END_COND:
				return this->instr_end_cond();

			case Instruction::Kind::END_COND_SET:
				return this->instr_end_cond_set(this->context.symbol_proc_manager.getEndCondSet(instr));

			case Instruction::Kind::BEGIN_LOCAL_WHEN_COND:
				return this->instr_begin_local_when_cond(
					this->context.symbol_proc_manager.getBeginLocalWhenCond(instr)
				);

			case Instruction::Kind::END_LOCAL_WHEN_COND:
				return this->instr_end_local_when_cond(this->context.symbol_proc_manager.getEndLocalWhenCond(instr));

			case Instruction::Kind::BEGIN_WHILE:
				return this->instr_begin_while(this->context.symbol_proc_manager.getBeginWhile(instr));

			case Instruction::Kind::END_WHILE:
				return this->instr_end_while(this->context.symbol_proc_manager.getEndWhile(instr));

			case Instruction::Kind::BEGIN_FOR:
				return this->instr_begin_for(this->context.symbol_proc_manager.getBeginFor(instr));

			case Instruction::Kind::END_FOR:
				return this->instr_end_for(this->context.symbol_proc_manager.getEndFor(instr));

			case Instruction::Kind::BEGIN_FOR_UNROLL:
				return this->instr_begin_for_unroll(this->context.symbol_proc_manager.getBeginForUnroll(instr));

			case Instruction::Kind::FOR_UNROLL_COND:
				return this->instr_for_unroll_cond(this->context.symbol_proc_manager.getForUnrollCond(instr));

			case Instruction::Kind::FOR_UNROLL_CONTINUE:
				return this->instr_for_unroll_continue(this->context.symbol_proc_manager.getForUnrollContinue(instr));

			case Instruction::Kind::BEGIN_SWITCH:
				return this->instr_begin_switch(this->context.symbol_proc_manager.getBeginSwitch(instr));

			case Instruction::Kind::BEGIN_CASE:
				return this->instr_begin_case(this->context.symbol_proc_manager.getBeginCase(instr));

			case Instruction::Kind::END_CASE:
				return this->instr_end_case();

			case Instruction::Kind::END_SWITCH:
				return this->instr_end_switch(this->context.symbol_proc_manager.getEndSwitch(instr));

			case Instruction::Kind::BEGIN_DEFER:
				return this->instr_begin_defer(this->context.symbol_proc_manager.getBeginDefer(instr));

			case Instruction::Kind::END_DEFER:
				return this->instr_end_defer(this->context.symbol_proc_manager.getEndDefer(instr));

			case Instruction::Kind::BEGIN_STMT_BLOCK:
				return this->instr_begin_stmt_block(this->context.symbol_proc_manager.getBeginStmtBlock(instr));

			case Instruction::Kind::END_STMT_BLOCK:
				return this->instr_end_stmt_block(this->context.symbol_proc_manager.getEndStmtBlock(instr));

			case Instruction::Kind::FUNC_CALL:
				return this->instr_func_call(this->context.symbol_proc_manager.getFuncCall(instr));

			case Instruction::Kind::ASSIGNMENT:
				return this->instr_assignment(this->context.symbol_proc_manager.getAssignment(instr));

			case Instruction::Kind::ASSIGNMENT_NEW:
				return this->instr_assignment_new(this->context.symbol_proc_manager.getAssignmentNew(instr));

			case Instruction::Kind::ASSIGNMENT_COPY:
				return this->instr_assignment_copy(this->context.symbol_proc_manager.getAssignmentCopy(instr));

			case Instruction::Kind::ASSIGNMENT_MOVE:
				return this->instr_assignment_move(this->context.symbol_proc_manager.getAssignmentMove(instr));

			case Instruction::Kind::ASSIGNMENT_FORWARD:
				return this->instr_assignment_forward(this->context.symbol_proc_manager.getAssignmentForward(instr));

			case Instruction::Kind::MULTI_ASSIGN:
				return this->instr_multi_assign(this->context.symbol_proc_manager.getMultiAssign(instr));

			case Instruction::Kind::DISCARDING_ASSIGNMENT:
				return this->instr_discarding_assignment(
					this->context.symbol_proc_manager.getDiscardingAssignment(instr)
				);

			case Instruction::Kind::TRY_ELSE_BEGIN:
				return this->instr_try_else_begin(this->context.symbol_proc_manager.getTryElseBegin(instr));

			case Instruction::Kind::TRY_ELSE_END:
				return this->instr_try_else_end();

			case Instruction::Kind::BEGIN_UNSAFE:
				return this->instr_begin_unsafe(this->context.symbol_proc_manager.getBeginUnsafe(instr));

			case Instruction::Kind::END_UNSAFE:
				return this->instr_end_unsafe();

			case Instruction::Kind::TYPE_TO_TERM:
				return this->instr_type_to_term(this->context.symbol_proc_manager.getTypeToTerm(instr));

			case Instruction::Kind::REQUIRE_THIS_DEF:
				return this->instr_require_this_def();

			case Instruction::Kind::WAIT_ON_SUB_SYMBOL_PROC_DECL:
				return this->instr_wait_on_sub_symbol_proc_decl(
					this->context.symbol_proc_manager.getWaitOnSubSymbolProcDecl(instr)
				);

			case Instruction::Kind::WAIT_ON_SUB_SYMBOL_PROC_DEF:
				return this->instr_wait_on_sub_symbol_proc_def(
					this->context.symbol_proc_manager.getWaitOnSubSymbolProcDef(instr)
				);

			case Instruction::Kind::FUNC_CALL_EXPR_COMPTIME_ERRORS:
				return this->instr_func_call_expr<true, true>(
					this->context.symbol_proc_manager.getFuncCallExprComptimeErrors(instr)
				);

			case Instruction::Kind::FUNC_CALL_EXPR_COMPTIME:
				return this->instr_func_call_expr<true, false>(
					this->context.symbol_proc_manager.getFuncCallExprComptime(instr)
				);

			case Instruction::Kind::FUNC_CALL_EXPR_ERRORS:
				return this->instr_func_call_expr<false, true>(
					this->context.symbol_proc_manager.getFuncCallExprErrors(instr)
				);

			case Instruction::Kind::FUNC_CALL_EXPR:
				return this->instr_func_call_expr<false, false>(
					this->context.symbol_proc_manager.getFuncCallExpr(instr)
				);

			case Instruction::Kind::COMPTIME_FUNC_CALL_RUN:
				return this->instr_comptime_func_call_run(
					this->context.symbol_proc_manager.getComptimeFuncCallRun(instr)
				);

			case Instruction::Kind::IMPORT_PANTHER:
				return this->instr_import<Instruction::Language::PANTHER>(
					this->context.symbol_proc_manager.getImportPanther(instr)
				);

			case Instruction::Kind::IMPORT_C:
				return this->instr_import<Instruction::Language::C>(
					this->context.symbol_proc_manager.getImportC(instr)
				);

			case Instruction::Kind::IMPORT_CPP:
				return this->instr_import<Instruction::Language::CPP>(
					this->context.symbol_proc_manager.getImportCpp(instr)
				);

			case Instruction::Kind::IS_MACRO_DEFINED:
				return this->instr_is_macro_defined(this->context.symbol_proc_manager.getIsMacroDefined(instr));

			case Instruction::Kind::MAKE_INIT_PTR:
				return this->instr_make_init_ptr(this->context.symbol_proc_manager.getMakeInitPtr(instr));

			case Instruction::Kind::COMPTIME_ERROR:
				return this->instr_comptime_error(this->context.symbol_proc_manager.getComptimeError(instr));

			case Instruction::Kind::COMPTIME_ASSERT:
				return this->instr_comptime_assert(this->context.symbol_proc_manager.getComptimeAssert(instr));

			case Instruction::Kind::TEMPLATE_INTRINSIC_FUNC_CALL:
				return this->instr_template_intrinsic_func_call(
					this->context.symbol_proc_manager.getTemplateIntrinsicFuncCall(instr)
				);

			case Instruction::Kind::TEMPLATE_INTRINSIC_FUNC_CALL_EXPR_COMPTIME:
				return this->instr_template_intrinsic_func_call_expr<true>(
					this->context.symbol_proc_manager.getTemplateIntrinsicFuncCallExprComptime(instr)
				);

			case Instruction::Kind::TEMPLATE_INTRINSIC_FUNC_CALL_EXPR:
				return this->instr_template_intrinsic_func_call_expr<false>(
					this->context.symbol_proc_manager.getTemplateIntrinsicFuncCallExpr(instr)
				);

			case Instruction::Kind::INDEXER_COMPTIME:
				return this->instr_indexer<true>(this->context.symbol_proc_manager.getIndexerComptime(instr));

			case Instruction::Kind::INDEXER:
				return this->instr_indexer<false>(this->context.symbol_proc_manager.getIndexer(instr));

			case Instruction::Kind::TEMPLATED_TERM:
				return this->instr_templated_term(this->context.symbol_proc_manager.getTemplatedTerm(instr));

			case Instruction::Kind::TEMPLATED_TERM_WAIT_FOR_DEF:
				return this->instr_templated_term_wait<true>(
					this->context.symbol_proc_manager.getTemplatedTermWaitForDef(instr)
				);

			case Instruction::Kind::TEMPLATED_TERM_WAIT_FOR_DECL:
				return this->instr_templated_term_wait<false>(
					this->context.symbol_proc_manager.getTemplatedTermWaitForDecl(instr)
				);

			case Instruction::Kind::PUSH_TEMPLATE_DECL_INSTANTIATION_TYPES_SCOPE:
				return this->instr_push_template_decl_instantiation_types_scope();

			case Instruction::Kind::POP_TEMPLATE_DECL_INSTANTIATION_TYPES_SCOPE:
				return this->instr_pop_template_decl_instantiation_types_scope();

			case Instruction::Kind::ADD_TEMPLATE_DECL_INSTANTIATION_TYPE:
				return this->instr_add_template_decl_instantiation_type(
					this->context.symbol_proc_manager.getAddTemplateDeclInstantiationType(instr)
				);

			case Instruction::Kind::COPY:
				return this->instr_copy(this->context.symbol_proc_manager.getCopy(instr));

			case Instruction::Kind::MOVE:
				return this->instr_move(this->context.symbol_proc_manager.getMove(instr));

			case Instruction::Kind::FORWARD:
				return this->instr_forward(this->context.symbol_proc_manager.getForward(instr));

			case Instruction::Kind::ADDR_OF:
				return this->instr_addr_of(this->context.symbol_proc_manager.getAddrOf(instr));

			case Instruction::Kind::PREFIX_NEGATE_COMPTIME:
				return this->instr_prefix_negate<true>(
					this->context.symbol_proc_manager.getPrefixNegateComptime(instr)
				);

			case Instruction::Kind::PREFIX_NEGATE:
				return this->instr_prefix_negate<false>(this->context.symbol_proc_manager.getPrefixNegate(instr));

			case Instruction::Kind::PREFIX_NOT_COMPTIME:
				return this->instr_prefix_not<true>(this->context.symbol_proc_manager.getPrefixNotComptime(instr));

			case Instruction::Kind::PREFIX_NOT:
				return this->instr_prefix_not<false>(this->context.symbol_proc_manager.getPrefixNot(instr));

			case Instruction::Kind::PREFIX_BITWISE_NOT_COMPTIME:
				return this->instr_prefix_bitwise_not<true>(
					this->context.symbol_proc_manager.getPrefixBitwiseNotComptime(instr)
				);

			case Instruction::Kind::PREFIX_BITWISE_NOT:
				return this->instr_prefix_bitwise_not<false>(
					this->context.symbol_proc_manager.getPrefixBitwiseNot(instr)
				);

			case Instruction::Kind::DEREF:
				return this->instr_deref(this->context.symbol_proc_manager.getDeref(instr));

			case Instruction::Kind::UNWRAP:
				return this->instr_unwrap(this->context.symbol_proc_manager.getUnwrap(instr));

			case Instruction::Kind::NEW_COMPTIME_ERRORS:
				return this->instr_new<true, true>(this->context.symbol_proc_manager.getNewComptimeErrors(instr));

			case Instruction::Kind::NEW_COMPTIME:
				return this->instr_new<true, false>(this->context.symbol_proc_manager.getNewComptime(instr));

			case Instruction::Kind::NEW_ERRORS:
				return this->instr_new<false, true>(this->context.symbol_proc_manager.getNewErrors(instr));

			case Instruction::Kind::NEW:
				return this->instr_new<false, false>(this->context.symbol_proc_manager.getNew(instr));

			case Instruction::Kind::ARRAY_INIT_NEW_COMPTIME:
				return this->instr_array_init_new<true>(
					this->context.symbol_proc_manager.getArrayInitNewComptime(instr)
				);

			case Instruction::Kind::ARRAY_INIT_NEW:
				return this->instr_array_init_new<false>(
					this->context.symbol_proc_manager.getArrayInitNew(instr)
				);

			case Instruction::Kind::DESIGNATED_INIT_NEW_COMPTIME:
				return this->instr_designated_init_new<true>(
					this->context.symbol_proc_manager.getDesignatedInitNewComptime(instr)
				);

			case Instruction::Kind::DESIGNATED_INIT_NEW:
				return this->instr_designated_init_new<false>(
					this->context.symbol_proc_manager.getDesignatedInitNew(instr)
				);

			case Instruction::Kind::PREPARE_TRY_HANDLER:
				return this->instr_prepare_try_handler(this->context.symbol_proc_manager.getPrepareTryHandler(instr));

			case Instruction::Kind::TRY_ELSE_EXPR:
				return this->instr_try_else_expr(this->context.symbol_proc_manager.getTryElseExpr(instr));

			case Instruction::Kind::BEGIN_EXPR_BLOCK:
				return this->instr_begin_expr_block(this->context.symbol_proc_manager.getBeginExprBlock(instr));

			case Instruction::Kind::END_EXPR_BLOCK:
				return this->instr_end_expr_block(this->context.symbol_proc_manager.getEndExprBlock(instr));

			case Instruction::Kind::AS_CONTEXPR:
				return this->instr_expr_as<true>(this->context.symbol_proc_manager.getAsComptime(instr));

			case Instruction::Kind::AS:
				return this->instr_expr_as<false>(this->context.symbol_proc_manager.getAs(instr));

			case Instruction::Kind::OPTIONAL_NULL_CHECK:
				return this->instr_optional_null_check(this->context.symbol_proc_manager.getOptionalNullCheck(instr));

			case Instruction::Kind::MATH_INFIX_COMPTIME_COMPARATIVE:
				return this->instr_expr_math_infix<true, Instruction::MathInfixKind::COMPARATIVE>(
					this->context.symbol_proc_manager.getMathInfixComptimeComparative(instr)
				);

			case Instruction::Kind::MATH_INFIX_COMPTIME_MATH:
				return this->instr_expr_math_infix<true, Instruction::MathInfixKind::MATH>(
					this->context.symbol_proc_manager.getMathInfixComptimeMath(instr)
				);

			case Instruction::Kind::MATH_INFIX_COMPTIME_INTEGRAL_MATH:
				return this->instr_expr_math_infix<true, Instruction::MathInfixKind::INTEGRAL_MATH>(
					this->context.symbol_proc_manager.getMathInfixComptimeIntegralMath(instr)
				);

			case Instruction::Kind::MATH_INFIX_COMPTIME_LOGICAL:
				return this->instr_expr_math_infix<true, Instruction::MathInfixKind::LOGICAL>(
					this->context.symbol_proc_manager.getMathInfixComptimeLogical(instr)
				);

			case Instruction::Kind::MATH_INFIX_COMPTIME_BITWISE_LOGICAL:
				return this->instr_expr_math_infix<true, Instruction::MathInfixKind::BITWISE_LOGICAL>(
					this->context.symbol_proc_manager.getMathInfixComptimeBitwiseLogical(instr)
				);

			case Instruction::Kind::MATH_INFIX_COMPTIME_SHIFT:
				return this->instr_expr_math_infix<true, Instruction::MathInfixKind::SHIFT>(
					this->context.symbol_proc_manager.getMathInfixComptimeShift(instr)
				);

			case Instruction::Kind::MATH_INFIX_COMPARATIVE:
				return this->instr_expr_math_infix<false, Instruction::MathInfixKind::COMPARATIVE>(
					this->context.symbol_proc_manager.getMathInfixComparative(instr)
				);

			case Instruction::Kind::MATH_INFIX_MATH:
				return this->instr_expr_math_infix<false, Instruction::MathInfixKind::MATH>(
					this->context.symbol_proc_manager.getMathInfixMath(instr)
				);

			case Instruction::Kind::MATH_INFIX_INTEGRAL_MATH:
				return this->instr_expr_math_infix<false, Instruction::MathInfixKind::INTEGRAL_MATH>(
					this->context.symbol_proc_manager.getMathInfixIntegralMath(instr)
				);

			case Instruction::Kind::MATH_INFIX_LOGICAL:
				return this->instr_expr_math_infix<false, Instruction::MathInfixKind::LOGICAL>(
					this->context.symbol_proc_manager.getMathInfixLogical(instr)
				);

			case Instruction::Kind::MATH_INFIX_BITWISE_LOGICAL:
				return this->instr_expr_math_infix<false, Instruction::MathInfixKind::BITWISE_LOGICAL>(
					this->context.symbol_proc_manager.getMathInfixBitwiseLogical(instr)
				);

			case Instruction::Kind::MATH_INFIX_SHIFT:
				return this->instr_expr_math_infix<false, Instruction::MathInfixKind::SHIFT>(
					this->context.symbol_proc_manager.getMathInfixShift(instr)
				);

			case Instruction::Kind::ACCESSOR_NEEDS_DEF:
				return this->instr_expr_accessor<true>(this->context.symbol_proc_manager.getAccessorNeedsDef(instr));

			case Instruction::Kind::ACCESSOR:
				return this->instr_expr_accessor<false>(this->context.symbol_proc_manager.getAccessor(instr));

			case Instruction::Kind::PRIMITIVE_TYPE:
				return this->instr_primitive_type(this->context.symbol_proc_manager.getPrimitiveType(instr));

			case Instruction::Kind::PRIMITIVE_TYPE_TERM:
				return this->instr_primitive_type_term(this->context.symbol_proc_manager.getPrimitiveTypeTerm(instr));

			case Instruction::Kind::ARRAY_TYPE:
				return this->instr_array_type(this->context.symbol_proc_manager.getArrayType(instr));

			case Instruction::Kind::ARRAY_REF:
				return this->instr_array_ref(this->context.symbol_proc_manager.getArrayRef(instr));

			case Instruction::Kind::INTERFACE_MAP:
				return this->instr_interface_map(this->context.symbol_proc_manager.getInterfaceMap(instr));

			case Instruction::Kind::TYPE_ID_CONVERTER:
				return this->instr_type_id_converter(this->context.symbol_proc_manager.getTypeIDConverter(instr));

			case Instruction::Kind::QUALIFIED_TYPE:
				return this->instr_qualified_type(this->context.symbol_proc_manager.getQualifiedType(instr));

			case Instruction::Kind::QUALIFIED_TYPE_TERM:
				return this->instr_qualified_type_term(this->context.symbol_proc_manager.getQualifiedTypeTerm(instr));

			case Instruction::Kind::BASE_TYPE_IDENT:
				return this->instr_base_type_ident(this->context.symbol_proc_manager.getBaseTypeIdent(instr));

			case Instruction::Kind::IDENT_NEEDS_DEF:
				return this->instr_ident<true>(this->context.symbol_proc_manager.getIdentNeedsDef(instr));

			case Instruction::Kind::IDENT:
				return this->instr_ident<false>(this->context.symbol_proc_manager.getIdent(instr));

			case Instruction::Kind::INTRINSIC:
				return this->instr_intrinsic(this->context.symbol_proc_manager.getIntrinsic(instr));

			case Instruction::Kind::TYPE_THIS_NEEDS_DEF:
				return this->instr_type_this<true>(this->context.symbol_proc_manager.getTypeThisNeedsDef(instr));

			case Instruction::Kind::TYPE_THIS:
				return this->instr_type_this<false>(this->context.symbol_proc_manager.getTypeThis(instr));

			case Instruction::Kind::LITERAL:
				return this->instr_literal(this->context.symbol_proc_manager.getLiteral(instr));

			case Instruction::Kind::UNINIT:
				return this->instr_uninit(this->context.symbol_proc_manager.getUninit(instr));

			case Instruction::Kind::ZEROINIT:
				return this->instr_zeroinit(this->context.symbol_proc_manager.getZeroinit(instr));

			case Instruction::Kind::THIS:
				return this->instr_this(this->context.symbol_proc_manager.getThis(instr));

			case Instruction::Kind::TYPE_DEDUCER:
				return this->instr_type_deducer(this->context.symbol_proc_manager.getTypeDeducer(instr));

			case Instruction::Kind::EXPR_DEDUCER:
				return this->instr_expr_deducer(this->context.symbol_proc_manager.getExprDeducer(instr));
		}

		evo::debugFatalBreak("Unknown SymbolProc::Instruction");
	}



	auto SemanticAnalyzer::instr_suspend_symbol_proc() -> Result {
		return Result::SUSPEND;
	}



	auto SemanticAnalyzer::instr_non_local_var_decl(const Instruction::NonLocalVarDecl& instr) -> Result {
		const std::string_view var_ident = this->source.getTokenBuffer()[instr.var_def.ident].getString();

		const evo::Result<GlobalVarAttrs> var_attrs =
			this->analyze_global_var_attrs(instr.var_def, instr.attribute_params_info);
		if(var_attrs.isError()){ return Result::ERROR; }


		const TypeInfo::VoidableID got_type_info_id = this->get_type(instr.type_id);

		if(got_type_info_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_VAR_TYPE_VOID,
				*instr.var_def.type,
				"Variables cannot be type `Void`"
			);
			return Result::ERROR;
		}
		
		bool is_global = true;
		if(instr.var_def.kind == AST::VarDef::Kind::DEF){
			if(var_attrs.value().is_global){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.var_def,
					"A [def] variable should not have the attribute `#global`"
				);
				return Result::ERROR;
			}

		}else if(this->scope.isGlobalScope()){
			if(var_attrs.value().is_global){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.var_def,
					"Global variable should not have the attribute `#global`"
				);
				return Result::ERROR;
			}

			if(var_attrs.value().is_priv){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.var_def,
					"Global variable should not have the attribute `#priv`"
				);
				return Result::ERROR;
			}
			
		}else{
			is_global = var_attrs.value().is_global;
		}


		if(is_global){
			const sema::GlobalVar::ID new_sema_var = this->context.sema_buffer.createGlobalVar(
				instr.var_def.kind,
				this->source.getID(),
				instr.var_def.ident,
				std::string(),
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				std::optional<sema::Expr>(),
				got_type_info_id.asTypeID(),
				var_attrs.value().is_pub,
				var_attrs.value().is_priv,
				this->symbol_proc_id
			);

			if(this->add_ident_to_scope(var_ident, instr.var_def, true, new_sema_var).isError()){
				return Result::ERROR;
			}

			this->symbol_proc.extra_info.emplace<SymbolProc::NonLocalVarInfo>(new_sema_var);

			if(instr.var_def.kind == AST::VarDef::Kind::CONST){
				auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);

				sema::GlobalVar& sema_var = this->context.sema_buffer.global_vars[new_sema_var];
				sema_var.comptimeJITGlobal = *sema_to_pir.lowerGlobalDecl(new_sema_var);
			}
		}else{
			if(var_attrs.value().is_pub){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.var_def,
					"Member variable should not have the attribute `#pub`"
				);
				return Result::ERROR;
			}

			BaseType::Struct& current_struct = this->context.type_manager.getStruct(
				this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
			);

			const uint32_t member_index = [&](){
				const auto lock = std::scoped_lock(current_struct.memberVarsLock);
				current_struct.memberVars.emplace_back(
					instr.var_def.kind,
					instr.var_def.ident,
					got_type_info_id.asTypeID(),
					std::nullopt,
					var_attrs.value().is_priv
				);
				return uint32_t(current_struct.memberVars.size() - 1);
			}();

			if(this->add_ident_to_scope(
				var_ident, instr.var_def.ident, false, sema::ScopeLevel::MemberVarFlag{}, instr.var_def.ident
			).isError()){
				return Result::ERROR;
			}

			this->symbol_proc.extra_info.emplace<SymbolProc::NonLocalVarInfo>(member_index);
		}


		this->propagate_finished_decl();
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_non_local_var_def(const Instruction::NonLocalVarDef& instr) -> Result {
		const bool is_global = 
			this->symbol_proc.extra_info.as<SymbolProc::NonLocalVarInfo>().sema_id.is<sema::GlobalVar::ID>();

		const TypeInfo::ID var_type_id = [&](){
			if(is_global){
				const sema::GlobalVar::ID sema_var_id =
					this->symbol_proc.extra_info.as<SymbolProc::NonLocalVarInfo>().sema_id.as<sema::GlobalVar::ID>();
				sema::GlobalVar& sema_var = this->context.sema_buffer.global_vars[sema_var_id];
				return *sema_var.typeID;

			}else{
				const uint32_t member_index =
					this->symbol_proc.extra_info.as<SymbolProc::NonLocalVarInfo>().sema_id.as<uint32_t>();

				BaseType::Struct& current_struct = this->context.type_manager.getStruct(
					this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
				);

				const auto lock = std::scoped_lock(current_struct.memberVarsLock);
				return current_struct.memberVars[member_index].typeID;
			}
		}();

		if(instr.value_id.has_value()){
			TermInfo& value_term_info = this->get_term_info(*instr.value_id);

			if(value_term_info.value_category == TermInfo::ValueCategory::INITIALIZER){
				if(instr.var_def.kind != AST::VarDef::Kind::VAR){
					this->emit_error(
						Diagnostic::Code::SEMA_VAR_INITIALIZER_ON_NON_VAR,
						instr.var_def,
						"Only [var] global variables can be defined with an initializer value"
					);
					return Result::ERROR;
				}

			}else if(value_term_info.value_category == TermInfo::ValueCategory::NULL_VALUE){
				// do nothing...

			}else{
				if(value_term_info.is_ephemeral() == false){
					if(this->check_term_isnt_type(value_term_info, *instr.var_def.value).isError()){
						return Result::ERROR;
					}

					if(value_term_info.is_module()){
						this->error_type_mismatch(
							var_type_id, value_term_info, "Variable definition", *instr.var_def.value
						);
						return Result::ERROR;
					}

					this->emit_error(
						Diagnostic::Code::SEMA_VAR_DEF_NOT_EPHEMERAL,
						*instr.var_def.value,
						"Cannot define a variable with a non-ephemeral value"
					);
					return Result::ERROR;
				}

				TypeCheckInfo type_check_info = this->type_check<true, true>(
					var_type_id, value_term_info, "Variable definition", *instr.var_def.value
				);

				if(type_check_info.ok == false){
					if(type_check_info.special_result_from_interface_match.has_value()){
						return type_check_info.extractSpecialResultFromInterfaceMatch();
					}else{
						return Result::ERROR;
					}
				}
			}

		}else{
			if(is_global){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_GLOBAL_LIFETIME_VAR_WITHOUT_VALUE,
					instr.var_def,
					"Variables with global lifetime must be declared with a value"
				);
				return Result::ERROR;
			}
		}



		if(is_global){
			const sema::GlobalVar::ID sema_var_id =
				this->symbol_proc.extra_info.as<SymbolProc::NonLocalVarInfo>().sema_id.as<sema::GlobalVar::ID>();
			sema::GlobalVar& sema_var = this->context.sema_buffer.global_vars[sema_var_id];

			sema_var.expr = this->get_term_info(*instr.value_id).getExpr();

			if(instr.var_def.kind == AST::VarDef::Kind::CONST){
				auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);

				sema_to_pir.lowerGlobalDef(sema_var_id);


				///////////////////////////////////
				// The following code commented code is for lowering directly to JIT
				// I'm purposely keeping this here (at least for now)

				// const evo::Expected<void, evo::SmallVector<std::string>> add_module_subset_result = 
				// 	this->context.comptime_jit_engine.addModuleSubsetWithWeakDependencies(
				// 		this->context.pir_module,
				// 		pir::JITEngine::ModuleSubsets{ .globalVars = *sema_var.comptimeJITGlobal, }
				// 	);

				// if(add_module_subset_result.has_value() == false){
				// 	auto infos = evo::SmallVector<Diagnostic::Info>();
				// 	for(const std::string& error : add_module_subset_result.error()){
				// 		infos.emplace_back(std::format("Message from LLVM: \"{}\"", error));
				// 	}

				// 	this->emit_fatal(
				// 		Diagnostic::Code::MISC_LLVM_ERROR,
				// 		instr.var_def,
				// 		Diagnostic::createFatalMessage("Failed to setup PIR JIT interface for const global variable"),
				// 		std::move(infos)
				// 	);
				// 	return Result::ERROR;
				// }
			}

		}else if(instr.value_id.has_value()){ // member var with default value
			const uint32_t member_index =
				this->symbol_proc.extra_info.as<SymbolProc::NonLocalVarInfo>().sema_id.as<uint32_t>();

			BaseType::Struct& current_struct = this->context.type_manager.getStruct(
				this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
			);

			const TermInfo& default_term = this->get_term_info(*instr.value_id);

			const auto lock = std::scoped_lock(current_struct.memberVarsLock);
			current_struct.memberVars[member_index].defaultValue = BaseType::Struct::MemberVar::DefaultValue(
				default_term.getExpr(), default_term.value_stage == TermInfo::ValueStage::COMPTIME
			);
		}
		

		this->propagate_finished_def();
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_non_local_var_decl_def(const Instruction::NonLocalVarDeclDef& instr) -> Result {
		const std::string_view var_ident = this->source.getTokenBuffer()[instr.var_def.ident].getString();

		const evo::Result<GlobalVarAttrs> var_attrs =
			this->analyze_global_var_attrs(instr.var_def, instr.attribute_params_info);
		if(var_attrs.isError()){ return Result::ERROR; }


		TermInfo& value_term_info = this->get_term_info(instr.value_id);
		if(value_term_info.value_category == TermInfo::ValueCategory::MODULE){
			if(instr.var_def.kind != AST::VarDef::Kind::DEF){
				this->emit_error(
					Diagnostic::Code::SEMA_MODULE_VAR_MUST_BE_DEF,
					*instr.var_def.value,
					"Variable that has a module value must be declared as [def]"
				);
				return Result::ERROR;
			}

			const evo::Result<> add_ident_result = this->add_ident_to_scope(
				var_ident,
				instr.var_def,
				true,
				value_term_info.type_id.as<Source::ID>(),
				instr.var_def.ident,
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				var_attrs.value().is_pub,
				var_attrs.value().is_priv
			);

			// TODO(FUTURE): propgate if `add_ident_result` errored?
			this->propagate_finished_decl_def();
			return add_ident_result.isError() ? Result::ERROR : Result::SUCCESS;

		}else if(value_term_info.value_category == TermInfo::ValueCategory::CLANG_MODULE){
			if(instr.var_def.kind != AST::VarDef::Kind::DEF){
				this->emit_error(
					Diagnostic::Code::SEMA_MODULE_VAR_MUST_BE_DEF,
					*instr.var_def.value,
					"Variable that has a module value must be declared as [def]"
				);
				return Result::ERROR;
			}

			const evo::Result<> add_ident_result = this->add_ident_to_scope(
				var_ident,
				instr.var_def,
				true,
				value_term_info.type_id.as<ClangSource::ID>(),
				instr.var_def.ident,
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				var_attrs.value().is_pub,
				var_attrs.value().is_priv
			);

			// TODO(FUTURE): propgate if `add_ident_result` errored?
			this->propagate_finished_decl_def();
			return add_ident_result.isError() ? Result::ERROR : Result::SUCCESS;
		}


		if(value_term_info.value_category == TermInfo::ValueCategory::INITIALIZER){
			this->emit_error(
				Diagnostic::Code::SEMA_VAR_INITIALIZER_WITHOUT_EXPLICIT_TYPE,
				*instr.var_def.value,
				"Cannot define a variable with an initializer value without an explicit type"
			);
			return Result::ERROR;

		}else if(value_term_info.value_category == TermInfo::ValueCategory::NULL_VALUE){
			this->emit_error(
				Diagnostic::Code::SEMA_VAR_NULL_WITHOUT_EXPLICIT_TYPE,
				*instr.var_def.value,
				"Cannot define a variable with a [null] value without an explicit type"
			);
			return Result::ERROR;
		}


		if(value_term_info.is_ephemeral() == false){
			if(this->check_term_isnt_type(value_term_info, *instr.var_def.value).isError()){ return Result::ERROR; }

			this->emit_error(
				Diagnostic::Code::SEMA_VAR_DEF_NOT_EPHEMERAL,
				*instr.var_def.value,
				"Cannot define a variable with a non-ephemeral value"
			);
			return Result::ERROR;
		}

			
		if(value_term_info.isMultiValue()){
			this->emit_error(
				Diagnostic::Code::SEMA_MULTI_RETURN_INTO_SINGLE_VALUE,
				*instr.var_def.value,
				"Cannot define a variable with multiple values"
			);
			return Result::ERROR;
		}

		if(
			instr.var_def.kind != AST::VarDef::Kind::DEF &&
			value_term_info.value_category == TermInfo::ValueCategory::EPHEMERAL_FLUID
		){
			this->emit_error(
				Diagnostic::Code::SEMA_CANNOT_INFER_TYPE,
				*instr.var_def.value,
				"Cannot infer the type of a fluid literal",
				Diagnostic::Info("Did you mean this variable to be [def]? If not, give the variable an explicit type")
			);
			return Result::ERROR;
		}


		if(instr.type_id.has_value()){
			const TypeInfo::VoidableID got_type_info_id = this->get_type(*instr.type_id);

			if(got_type_info_id.isVoid()){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_TYPE_VOID, *instr.var_def.type, "Variables cannot be type `Void`"
				);
				return Result::ERROR;
			}

			const TypeInfo& got_type_info = this->context.getTypeManager().getTypeInfo(got_type_info_id.asTypeID());

			if(got_type_info.baseTypeID().kind() == BaseType::Kind::INTERFACE){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_TYPE_INTERFACE,
					*instr.var_def.type,
					"Variables cannot be an interface type"
				);
				return Result::ERROR;
			}


			const TypeCheckInfo type_check_info = this->type_check<true, true>(
				got_type_info_id.asTypeID(), value_term_info, "Variable definition", *instr.var_def.value
			);

			if(type_check_info.ok == false){ return Result::ERROR; }

			if(type_check_info.deduced_terms.empty() == false){
				if(this->scope.isGlobalScope()){
					this->emit_error(
						Diagnostic::Code::SEMA_DEDUCER_IN_GLOBAL_VAR,
						*instr.var_def.type,
						"Global variables cannot have deducers"
					);
					return Result::ERROR;
				}

				if(this->add_deduced_terms_to_scope(type_check_info.deduced_terms).isError()){ return Result::ERROR; }
			}

		}

		const std::optional<TypeInfo::ID> type_id = [&](){
			if(value_term_info.type_id.is<TypeInfo::ID>()){
				return std::optional<TypeInfo::ID>(value_term_info.type_id.as<TypeInfo::ID>());
			}
			return std::optional<TypeInfo::ID>();
		}();



		bool is_global = true;
		if(instr.var_def.kind == AST::VarDef::Kind::DEF){
			if(var_attrs.value().is_global){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.var_def,
					"A [def] variable should not have the attribute `#global`"
				);
				return Result::ERROR;
			}

		}else if(this->scope.isGlobalScope()){
			if(var_attrs.value().is_global){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.var_def,
					"Global variable should not have the attribute `#global`"
				);
				return Result::ERROR;
			}

			if(var_attrs.value().is_priv){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.var_def,
					"Global variable should not have the attribute `#priv`"
				);
				return Result::ERROR;
			}
			
		}else{
			is_global = var_attrs.value().is_global;
		}


		if(is_global){
			const sema::GlobalVar::ID new_sema_var = this->context.sema_buffer.createGlobalVar(
				instr.var_def.kind,
				this->source.getID(),
				instr.var_def.ident,
				std::string(),
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				std::optional<sema::Expr>(value_term_info.getExpr()),
				type_id,
				var_attrs.value().is_pub,
				var_attrs.value().is_priv,
				this->symbol_proc_id
			);

			if(this->add_ident_to_scope(var_ident, instr.var_def, true, new_sema_var).isError()){
				return Result::ERROR;
			}


			if(instr.var_def.kind == AST::VarDef::Kind::CONST){
				auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);

				sema::GlobalVar& sema_var = this->context.sema_buffer.global_vars[new_sema_var];
				sema_var.comptimeJITGlobal = *sema_to_pir.lowerGlobalDecl(new_sema_var);
				sema_to_pir.lowerGlobalDef(new_sema_var);


				///////////////////////////////////
				// The following code commented code is for lowering directly to JIT
				// I'm purposely keeping this here (at least for now)

				// const evo::Expected<void, evo::SmallVector<std::string>> add_module_subset_result = 
				// 	this->context.comptime_jit_engine.addModuleSubsetWithWeakDependencies(
				// 		this->context.pir_module,
				// 		pir::JITEngine::ModuleSubsets{ .globalVars = *sema_var.comptimeJITGlobal, }
				// 	);

				// if(add_module_subset_result.has_value() == false){
				// 	auto infos = evo::SmallVector<Diagnostic::Info>();
				// 	for(const std::string& error : add_module_subset_result.error()){
				// 		infos.emplace_back(std::format("Message from LLVM: \"{}\"", error));
				// 	}

				// 	this->emit_fatal(
				// 		Diagnostic::Code::MISC_LLVM_ERROR,
				// 		instr.var_def,
				// 		Diagnostic::createFatalMessage("Failed to setup PIR JIT interface for const global variable"),
				// 		std::move(infos)
				// 	);
				// 	return Result::ERROR;
				// }
			}

		}else{
			if(var_attrs.value().is_pub){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.var_def,
					"Member variable should not have the attribute `#pub`"
				);
				return Result::ERROR;
			}
			
			BaseType::Struct& current_struct = this->context.type_manager.getStruct(
				this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
			);

			{
				const auto lock = std::scoped_lock(current_struct.memberVarsLock);
				current_struct.memberVars.emplace_back(
					instr.var_def.kind,
					instr.var_def.ident,
					*type_id,
					BaseType::Struct::MemberVar::DefaultValue(
						value_term_info.getExpr(), value_term_info.value_stage == TermInfo::ValueStage::COMPTIME
					)
				);
			}

			if(this->add_ident_to_scope(
				var_ident, instr.var_def.ident, false, sema::ScopeLevel::MemberVarFlag{}, instr.var_def.ident
			).isError()){
				return Result::ERROR;
			}
		}

		this->propagate_finished_decl_def();
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_when_cond(const Instruction::WhenCond& instr) -> Result {
		TermInfo& cond_term_info = this->get_term_info(instr.cond);
		if(this->check_term_isnt_type(cond_term_info, instr.when_cond.cond).isError()){ return Result::ERROR; }

		if(this->type_check<true, true>(
			this->context.getTypeManager().getTypeBool(),
			cond_term_info,
			"Condition in when conditional",
			instr.when_cond.cond
		).ok == false){
			return Result::ERROR;
		}

		SymbolProc::WhenCondInfo& when_cond_info = this->symbol_proc.extra_info.as<SymbolProc::WhenCondInfo>();
		auto passed_symbols = std::queue<SymbolProc::ID>();

		SymbolProc* encapsulating_symbol_proc = this->symbol_proc.parent;
		while(
			encapsulating_symbol_proc != nullptr
			&& encapsulating_symbol_proc->getASTNode().kind() == AST::Kind::WHEN_CONDITIONAL
		){
			encapsulating_symbol_proc = encapsulating_symbol_proc->parent;
		}

		const bool cond = this->context.sema_buffer.getBoolValue(cond_term_info.getExpr().boolValueID()).value;
		if(cond){
			for(const SymbolProc::ID& then_id : when_cond_info.then_ids){
				SymbolProc& then_symbol = this->context.symbol_proc_manager.getSymbolProc(then_id);
				then_symbol.sema_scope_id = this->context.sema_buffer.scope_manager.copyScope(
					*this->symbol_proc.sema_scope_id
				);

				if(encapsulating_symbol_proc != nullptr){
					then_symbol.decl_waited_on_by.emplace_back(encapsulating_symbol_proc->getID());
					encapsulating_symbol_proc->waiting_for.emplace_back(then_id);
				}

				this->set_waiting_for_is_done(then_id, this->symbol_proc_id);
			}

			for(const SymbolProc::ID& else_id : when_cond_info.else_ids){
				passed_symbols.push(else_id);
			}

		}else{
			for(const SymbolProc::ID& else_id : when_cond_info.else_ids){
				SymbolProc& else_symbol = this->context.symbol_proc_manager.getSymbolProc(else_id);
				else_symbol.sema_scope_id = this->context.sema_buffer.scope_manager.copyScope(
					*this->symbol_proc.sema_scope_id
				);

				if(encapsulating_symbol_proc != nullptr){
					else_symbol.decl_waited_on_by.emplace_back(encapsulating_symbol_proc->getID());
					encapsulating_symbol_proc->waiting_for.emplace_back(else_id);
				}

				this->set_waiting_for_is_done(else_id, this->symbol_proc_id);
			}

			for(const SymbolProc::ID& then_id : when_cond_info.then_ids){
				passed_symbols.push(then_id);
			}
		}

		while(passed_symbols.empty() == false){
			SymbolProc::ID passed_symbol_id = passed_symbols.front();
			passed_symbols.pop();


			SymbolProc& passed_symbol = this->context.symbol_proc_manager.getSymbolProc(passed_symbol_id);

			{
				const auto lock = std::scoped_lock(passed_symbol.waiting_for_lock);
				passed_symbol.setStatusPassedOnByWhenCond();
			}
			this->context.symbol_proc_manager.symbol_proc_done();


			{
				const auto lock = std::scoped_lock(passed_symbol.decl_waited_on_lock, passed_symbol.def_waited_on_lock);

				for(const SymbolProc::ID& decl_waited_on_id : passed_symbol.decl_waited_on_by){
					this->set_waiting_for_is_done(decl_waited_on_id, passed_symbol_id);
				}
				for(const SymbolProc::ID& def_waited_on_id : passed_symbol.def_waited_on_by){
					this->set_waiting_for_is_done(def_waited_on_id, passed_symbol_id);
				}
			}


			if(passed_symbol.extra_info.is<SymbolProc::WhenCondInfo>()){
				const SymbolProc::WhenCondInfo& passed_when_cond_info =
					passed_symbol.extra_info.as<SymbolProc::WhenCondInfo>();

				for(const SymbolProc::ID& then_id : passed_when_cond_info.then_ids){
					passed_symbols.push(then_id);
				}

				for(const SymbolProc::ID& else_id : passed_when_cond_info.else_ids){
					passed_symbols.push(else_id);
				}
			}
		}

		this->propagate_finished_def();
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_alias(const Instruction::Alias& instr) -> Result {
		const evo::Result<AliasAttrs> alias_attrs =
			this->analyze_alias_attrs(instr.alias_def, instr.attribute_params_info);
		if(alias_attrs.isError()){ return Result::ERROR; }


		const TermInfo& aliased_type_term = this->get_term_info(instr.aliased_type);

		if(
			aliased_type_term.value_category == TermInfo::ValueCategory::TEMPLATE_TYPE
			|| aliased_type_term.value_category == TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED
		){
			const auto aliased_id = [&]() -> evo::Variant<sema::TemplatedStruct::ID, sema::StructTemplateAlias::ID> {
				if(aliased_type_term.type_id.is<sema::TemplatedStruct::ID>()){
					return aliased_type_term.type_id.as<sema::TemplatedStruct::ID>();
				}else{
					return aliased_type_term.type_id.as<sema::StructTemplateAlias::ID>();
				}
			}();


			const sema::StructTemplateAlias::ID struct_template_alias_id = 
				this->context.sema_buffer.createStructTemplateAlias(
					this->source.getID(),
					instr.alias_def.ident,
					this->scope.getCurrentEncapsulatingSymbolIfExists(),
					aliased_id,
					aliased_type_term.value_category == TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED,
					alias_attrs.value().is_distinct,
					alias_attrs.value().is_pub,
					alias_attrs.value().is_priv
				);

			const std::string_view ident_str = this->source.getTokenBuffer()[instr.alias_def.ident].getString();
			if(this->add_ident_to_scope(ident_str, instr.alias_def, true, struct_template_alias_id).isError()){
				return Result::ERROR;
			}

			this->propagate_finished_decl_def();
			return Result::SUCCESS;
		}

		evo::debugAssert(
			aliased_type_term.value_category == TermInfo::ValueCategory::TYPE, "Unknown type term"
		);

		///////////////////////////////////
		// check type

		const TypeInfo::VoidableID aliased_type = aliased_type_term.type_id.as<TypeInfo::VoidableID>();
		if(aliased_type.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_ALIAS_CANNOT_BE_VOID,
				instr.alias_def.type,
				"Alias cannot be type `Void`"
			);
			return Result::ERROR;
		}


		///////////////////////////////////
		// create

		if(alias_attrs.value().is_distinct){
			const BaseType::ID created_alias = this->context.type_manager.createDistinctAlias(
				BaseType::DistinctAlias(
					this->source.getID(),
					instr.alias_def.ident,
					this->scope.getCurrentEncapsulatingSymbolIfExists(),
					aliased_type.asTypeID(),
					alias_attrs.value().is_pub,
					alias_attrs.value().is_priv
				)
			);

			const std::string_view ident_str = this->source.getTokenBuffer()[instr.alias_def.ident].getString();
			if(this->add_ident_to_scope(ident_str, instr.alias_def, true, created_alias.distinctAliasID()).isError()){
				return Result::ERROR;
			}

			this->context.symbol_proc_manager.addTypeSymbolProc(
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(created_alias)), this->symbol_proc_id
			);
			
		}else{
			const BaseType::ID created_alias = this->context.type_manager.createAlias(
				BaseType::Alias(
					this->source.getID(),
					instr.alias_def.ident,
					this->scope.getCurrentEncapsulatingSymbolIfExists(),
					aliased_type.asTypeID(),
					alias_attrs.value().is_pub,
					alias_attrs.value().is_priv
				)
			);

			const std::string_view ident_str = this->source.getTokenBuffer()[instr.alias_def.ident].getString();
			if(this->add_ident_to_scope(ident_str, instr.alias_def, true, created_alias.aliasID()).isError()){
				return Result::ERROR;
			}

			this->context.symbol_proc_manager.addTypeSymbolProc(
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(created_alias)), this->symbol_proc_id
			);
		}

		this->propagate_finished_decl_def();
		return Result::SUCCESS;
	}



	template<bool IS_INSTANTIATION>
	auto SemanticAnalyzer::instr_struct_decl(const Instruction::StructDecl<IS_INSTANTIATION>& instr) -> Result {
		const evo::Result<StructAttrs> struct_attrs =
			this->analyze_struct_attrs(instr.struct_def, instr.attribute_params_info);
		if(struct_attrs.isError()){ return Result::ERROR; }


		///////////////////////////////////
		// create

		SymbolProc::StructInfo& struct_info = this->symbol_proc.extra_info.as<SymbolProc::StructInfo>();


		const BaseType::ID created_struct = this->context.type_manager.createStruct(
			BaseType::Struct{
				.sourceID          = this->source.getID(),
				.name              = instr.struct_def.ident,
				.parent            = this->scope.getCurrentEncapsulatingSymbolIfExists(),
				.templateID        = instr.struct_template_id,
				.instantiation     = instr.instantiation_id,
				.memberVars        = evo::SmallVector<BaseType::Struct::MemberVar>(),
				.memberVarsABI     = evo::SmallVector<BaseType::Struct::MemberVar*>(),
				.namespacedMembers = &struct_info.member_symbols,
				.scopeLevel        = nullptr,
				.isPub             = struct_attrs.value().is_pub,
				.isPriv            = struct_attrs.value().is_priv,
				.isOrdered         = struct_attrs.value().is_ordered,
				.isPacked          = struct_attrs.value().is_packed,
				.shouldLower       = true,
			}
		);

		struct_info.struct_id = created_struct.structID();

		if constexpr(IS_INSTANTIATION == false){
			const std::string_view ident_str = this->source.getTokenBuffer()[instr.struct_def.ident].getString();
			if(this->add_ident_to_scope(ident_str, instr.struct_def, true, created_struct.structID()).isError()){
				return Result::ERROR;
			}
		}


		///////////////////////////////////
		// setup member statements

		this->push_scope_level(nullptr, created_struct.structID());

		BaseType::Struct& created_struct_ref = this->context.type_manager.getStruct(created_struct.structID());
		created_struct_ref.scopeLevel = &this->get_current_scope_level();


		for(SymbolProc::ID member_stmt_id : struct_info.stmts){
			SymbolProc& member_stmt = this->context.symbol_proc_manager.getSymbolProc(member_stmt_id);


			member_stmt.sema_scope_id = this->context.sema_buffer.scope_manager.copyScope(
				*this->symbol_proc.sema_scope_id
			);

			if(member_stmt.ast_node.kind() == AST::Kind::FUNC_DEF){
				evo::debugAssert(member_stmt.isDeclDone() == false, "Decl already completed for struct member");

				const auto lock = std::scoped_lock(this->symbol_proc.waiting_for_lock, member_stmt.decl_waited_on_lock);
				this->symbol_proc.waiting_for.emplace_back(member_stmt_id);
				member_stmt.decl_waited_on_by.emplace_back(this->symbol_proc_id);

			}else{
				evo::debugAssert(member_stmt.isDefDone() == false, "Def already completed for struct member");

				const auto lock = std::scoped_lock(this->symbol_proc.waiting_for_lock, member_stmt.def_waited_on_lock);
				this->symbol_proc.waiting_for.emplace_back(member_stmt_id);
				member_stmt.def_waited_on_by.emplace_back(this->symbol_proc_id);
			}
		}


		if constexpr(IS_INSTANTIATION){
			struct_info.instantiation->structID = created_struct.structID();
		}

		this->context.symbol_proc_manager.addTypeSymbolProc(
			this->context.type_manager.getOrCreateTypeInfo(TypeInfo(created_struct)), this->symbol_proc_id
		);

		this->propagate_finished_decl();

		if(struct_info.stmts.empty()){
			return Result::SUCCESS;
		}else{
			return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
		}
	}


	auto SemanticAnalyzer::instr_struct_def() -> Result {
		if(this->pop_scope_level<PopScopeLevelKind::SYMBOL_END>().isError()){ return Result::ERROR; }

		const BaseType::Struct::ID created_struct_id =
			this->symbol_proc.extra_info.as<SymbolProc::StructInfo>().struct_id;
		BaseType::Struct& created_struct = this->context.type_manager.getStruct(created_struct_id);


	 	///////////////////////////////////
	 	// checking special member

		//////////////////
		// new

		if(created_struct.newInitOverloads.empty() && created_struct.newAssignOverloads.empty() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_STRUCT_NEW_ASSIGN_WITHOUT_NEW_INIT,
				this->symbol_proc.ast_node,
				"Cannot define a struct with a assignment operator [new] overload "
					"without an initialization operator [new] overload"
			);
			return Result::ERROR;
		}


		//////////////////
		// copy

		if(created_struct.copyAssignOverload.load(std::memory_order::relaxed).has_value()){
			if(created_struct.copyInitOverload.load(std::memory_order::relaxed).funcID.has_value()){
				const sema::Func& copy_init_sema_func = this->context.getSemaBuffer().getFunc(
					*created_struct.copyInitOverload.load(std::memory_order::relaxed).funcID
				);

				const sema::Func& copy_assign_sema_func = this->context.getSemaBuffer().getFunc(
					*created_struct.copyAssignOverload.load(std::memory_order::relaxed)
				);

				if(copy_init_sema_func.attributes.isComptime != copy_assign_sema_func.attributes.isComptime){
					this->emit_error(
						Diagnostic::Code::SEMA_STRUCT_COPY_ASSIGN_DOESNT_MATCH_COPY_INIT,
						this->symbol_proc.ast_node,
						"The initialization operator [copy] does not match the comptime status of the assignment "
							"operator [copy]"
					);
					return Result::ERROR;
				}


				const BaseType::Function& copy_init_func_type =
					this->context.getTypeManager().getFunction(copy_init_sema_func.typeID);

				const BaseType::Function& copy_assign_func_type =
					this->context.getTypeManager().getFunction(copy_assign_sema_func.typeID);


				if(copy_init_func_type.hasErrorReturn() != copy_assign_func_type.hasErrorReturn()){
					this->emit_error(
						Diagnostic::Code::SEMA_STRUCT_COPY_ASSIGN_DOESNT_MATCH_COPY_INIT,
						this->symbol_proc.ast_node,
						"The initialization operator [copy] does not match the erroring status of the assignment "
							"operator [copy]"
					);
					return Result::ERROR;
				}


				if(copy_init_func_type.isUnsafe != copy_assign_func_type.isUnsafe){
					this->emit_error(
						Diagnostic::Code::SEMA_STRUCT_COPY_ASSIGN_DOESNT_MATCH_COPY_INIT,
						this->symbol_proc.ast_node,
						"The initialization operator [copy] does not match the unsafe status of the assignment "
							"operator [copy]"
					);
					return Result::ERROR;
				}

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_STRUCT_COPY_ASSIGN_WITHOUT_COPY_INIT,
					this->symbol_proc.ast_node,
					"Cannot define a struct with a assignment operator [copy] overload "
						"without an initialization operator [copy] overload"
				);
				return Result::ERROR;
			}
		}



		//////////////////
		// move

		if(created_struct.moveAssignOverload.load(std::memory_order::relaxed).has_value()){
			if(created_struct.moveInitOverload.load(std::memory_order::relaxed).funcID.has_value()){
				const sema::Func& move_init_sema_func = this->context.getSemaBuffer().getFunc(
					*created_struct.moveInitOverload.load(std::memory_order::relaxed).funcID
				);

				const sema::Func& move_assign_sema_func = this->context.getSemaBuffer().getFunc(
					*created_struct.moveAssignOverload.load(std::memory_order::relaxed)
				);

				if(move_init_sema_func.attributes.isComptime != move_assign_sema_func.attributes.isComptime){
					this->emit_error(
						Diagnostic::Code::SEMA_STRUCT_MOVE_ASSIGN_DOESNT_MATCH_MOVE_INIT,
						this->symbol_proc.ast_node,
						"The initialization operator [move] does not match the comptime status of the assignment "
							"operator [move]"
					);
					return Result::ERROR;
				}


				const BaseType::Function& move_init_func_type =
					this->context.getTypeManager().getFunction(move_init_sema_func.typeID);

				const BaseType::Function& move_assign_func_type =
					this->context.getTypeManager().getFunction(move_assign_sema_func.typeID);


				if(move_init_func_type.hasErrorReturn() != move_assign_func_type.hasErrorReturn()){
					this->emit_error(
						Diagnostic::Code::SEMA_STRUCT_MOVE_ASSIGN_DOESNT_MATCH_MOVE_INIT,
						this->symbol_proc.ast_node,
						"The initialization operator [move] does not match the erroring status of the assignment "
							"operator [move]"
					);
					return Result::ERROR;
				}


				if(move_init_func_type.isUnsafe != move_assign_func_type.isUnsafe){
					this->emit_error(
						Diagnostic::Code::SEMA_STRUCT_MOVE_ASSIGN_DOESNT_MATCH_MOVE_INIT,
						this->symbol_proc.ast_node,
						"The initialization operator [move] does not match the unsafe status of the assignment "
							"operator [move]"
					);
					return Result::ERROR;
				}

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_STRUCT_MOVE_ASSIGN_WITHOUT_MOVE_INIT,
					this->symbol_proc.ast_node,
					"Cannot define a struct with a assignment operator [move] overload "
						"without an initialization operator [move] overload"
				);
				return Result::ERROR;
			}
		}



		///////////////////////////////////
		// sorting members ABI

		const auto sorting_func = [](
			const BaseType::Struct::MemberVar& lhs, const BaseType::Struct::MemberVar& rhs
		) -> bool {
			return lhs.name.as<Token::ID>().get() < rhs.name.as<Token::ID>().get();
		};

		std::sort(created_struct.memberVars.begin(), created_struct.memberVars.end(), sorting_func);

		// TODO(FEATURE): optimal ordering (when not #ordered)

		for(BaseType::Struct::MemberVar& member_var : created_struct.memberVars){
			created_struct.memberVarsABI.emplace_back(&member_var);
		}

		///////////////////////////////////
		// PIR lowering for comptime

		auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);

		sema_to_pir.lowerStruct(created_struct_id);



		///////////////////////////////////
		// default construction

		this->symbol_proc.data_stack.push(SymbolProc::StructSpecialMemberFuncs());

		auto funcs_to_wait_on = std::unordered_set<sema::Func::ID>();


		if(created_struct.newInitOverloads.empty()){
			created_struct.isDefaultInitializable = true;
			created_struct.isTriviallyDefaultInitializable = true;
			created_struct.isComptimeDefaultInitializable = true;
			created_struct.isNoErrorDefaultInitializable = true;
			created_struct.isSafeDefaultInitializable = true;


			for(const BaseType::Struct::MemberVar& member_var : created_struct.memberVars){
				if(this->context.getTypeManager().isDefaultInitializable(member_var.typeID) == false){
					if(member_var.defaultValue.has_value()){
						created_struct.isTriviallyDefaultInitializable = false;

						if(member_var.defaultValue->isComptime == false){
							created_struct.isComptimeDefaultInitializable = false;
						}
						
					}else{
						created_struct.isDefaultInitializable = false;
						created_struct.isTriviallyDefaultInitializable = false;
						created_struct.isComptimeDefaultInitializable = false;
						created_struct.isNoErrorDefaultInitializable = false;
						break;
					}
				}

				if(this->context.getTypeManager().isNoErrorDefaultInitializable(member_var.typeID) == false){
					created_struct.isDefaultInitializable = false;
					created_struct.isTriviallyDefaultInitializable = false;
					created_struct.isComptimeDefaultInitializable = false;
					created_struct.isNoErrorDefaultInitializable = false;
					break;
				}

				if(created_struct.isComptimeDefaultInitializable){
					if(
						(member_var.defaultValue.has_value() && member_var.defaultValue->isComptime == false)
						|| this->context.getTypeManager().isComptimeDefaultInitializable(member_var.typeID) == false
					){
						created_struct.isComptimeDefaultInitializable = false;
					}
				}

				if(created_struct.isTriviallyDefaultInitializable){
					if(	
						member_var.defaultValue.has_value()
						|| this->context.getTypeManager().isTriviallyDefaultInitializable(member_var.typeID) == false
					){
						created_struct.isTriviallyDefaultInitializable = false;
					}
				}

				if(created_struct.isSafeDefaultInitializable){
					if(this->context.getTypeManager().isSafeDefaultInitializable(member_var.typeID) == false){
						created_struct.isSafeDefaultInitializable = false;
					}
				}
			}

			if(created_struct.isDefaultInitializable && created_struct.isTriviallyDefaultInitializable == false){
				const TypeInfo::ID created_struct_type_id = 
					this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(created_struct_id)));

				const BaseType::ID default_init_func_type = this->context.type_manager.getOrCreateFunction(
					BaseType::Function(
						evo::SmallVector<BaseType::Function::Param>(),
						evo::SmallVector<TypeInfo::VoidableID>{created_struct_type_id},
						evo::SmallVector<TypeInfo::VoidableID>(),
						!created_struct.isSafeDefaultInitializable,
						true,
						false
					)
				);

				const sema::Func::ID created_default_init_new_id = this->context.sema_buffer.createFunc(
					this->source.getID(),
					sema::Func::CompilerCreatedOpOverload(
						created_struct.name.as<Token::ID>(), Token::Kind::KEYWORD_NEW
					),
					std::string(),
					EncapsulatingSymbolID(created_struct_id),
					default_init_func_type.funcID(),
					evo::SmallVector<sema::Func::Param>(),
					evo::SmallVector<Token::ID>{created_struct.name.as<Token::ID>()},
					evo::SmallVector<Token::ID>(),
					std::nullopt,
					0,
					false,
					sema::Func::Attributes{
						.isPub      = false,
						.isPriv     = false,
						.isComptime = created_struct.isComptimeDefaultInitializable,
						.isNoReturn = false,
						.isExport   = false,
						.isImplicit = false,
					}
				);


				sema::Func& created_default_init_new = this->context.sema_buffer.funcs[created_default_init_new_id];

				const sema::Expr return_param = sema::Expr(this->context.sema_buffer.createReturnParam(0, 0));

				for(size_t i = 0; const BaseType::Struct::MemberVar& member_var : created_struct.memberVars){
					EVO_DEFER([&](){ i += 1; });

					const sema::Expr member_var_expr = [&](){
						for(
							uint32_t j = 0;
							const BaseType::Struct::MemberVar* member_var_abi : created_struct.memberVarsABI
						){
							if(member_var_abi == &member_var){
								return sema::Expr(this->context.sema_buffer.createAccessor(
									return_param, created_struct_type_id, j
								));
							}

							j += 1;
						}
						evo::debugFatalBreak("Didn't find ABI member");
					}();

					if(member_var.defaultValue.has_value()){
						created_default_init_new.stmtBlock.emplace_back(
							this->context.sema_buffer.createAssign(member_var_expr, member_var.defaultValue->value)
						);
						continue;
					}


					if(this->context.getTypeManager().isTriviallyDefaultInitializable(member_var.typeID)){ continue; }

					const TypeInfo& member_type = this->context.getTypeManager().getTypeInfo(member_var.typeID);


					if(member_type.isOptional()){
						created_default_init_new.stmtBlock.emplace_back(
							this->context.sema_buffer.createAssign(
								member_var_expr,
								sema::Expr(this->context.sema_buffer.createDefaultNew(member_var.typeID, true))
							)
						);
						continue;
					}

					created_default_init_new.stmtBlock.emplace_back(
						this->context.sema_buffer.createAssign(
							member_var_expr,
							sema::Expr(this->context.sema_buffer.createDefaultNew(member_var.typeID, true))
						)
					);
				}

				created_default_init_new.stmtBlock.emplace_back(this->context.sema_buffer.createReturn());

				created_default_init_new.isTerminated = true;
				created_default_init_new.status = sema::Func::Status::DEF_DONE;

				created_struct.newInitOverloads.emplace_back(created_default_init_new_id);

				if(created_struct.isComptimeDefaultInitializable){
					this->symbol_proc.data_stack.top().as<SymbolProc::StructSpecialMemberFuncs>().init_func = 
						created_default_init_new_id;
				}
			}

		}else{
			for(const sema::Func::ID& new_init_overload_id : created_struct.newInitOverloads){
				const sema::Func& new_init_overload = this->context.getSemaBuffer().getFunc(new_init_overload_id);
				const BaseType::Function& new_init_overload_func_type =
					this->context.getTypeManager().getFunction(new_init_overload.typeID);

				if(new_init_overload.minNumArgs > 0){ continue; }

				created_struct.isDefaultInitializable = true;

				if(new_init_overload.attributes.isComptime){
					created_struct.isComptimeDefaultInitializable = true;
				}

				if(new_init_overload_func_type.errorTypes.empty()){
					created_struct.isNoErrorDefaultInitializable = true;
				}

				created_struct.isSafeDefaultInitializable = !new_init_overload_func_type.isUnsafe;

				break;
			}
		}



		///////////////////////////////////
		// default deleting

		if(created_struct.deleteOverload.load(std::memory_order::relaxed).has_value() == false){
			bool is_trivially_deletable = true;
			bool is_comptime_deletable = true;


			for(const BaseType::Struct::MemberVar& member_var : created_struct.memberVars){
				if(this->context.getTypeManager().isTriviallyDeletable(member_var.typeID) == false){
					is_trivially_deletable = false;
					break;
				}

				if(is_comptime_deletable == false){ continue; }
				if(this->context.getTypeManager().isComptimeDeletable(
					member_var.typeID, this->context.getSemaBuffer()
				) == false){
					is_comptime_deletable = false;
				}
			}


			if(is_trivially_deletable == false){
				const TypeInfo::ID created_struct_type_id = 
					this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(created_struct_id)));

				const BaseType::ID default_delete_func_type = this->context.type_manager.getOrCreateFunction(
					BaseType::Function(
						evo::SmallVector<BaseType::Function::Param>{
							BaseType::Function::Param(
								created_struct_type_id, BaseType::Function::Param::Kind::MUT, false
							),
						},
						evo::SmallVector<TypeInfo::VoidableID>{TypeInfo::VoidableID::Void()},
						evo::SmallVector<TypeInfo::VoidableID>(),
						false,
						false,
						false
					)
				);

				const sema::Func::ID created_default_delete_id = this->context.sema_buffer.createFunc(
					this->source.getID(),
					sema::Func::CompilerCreatedOpOverload(
						created_struct.name.as<Token::ID>(), Token::Kind::KEYWORD_DELETE
					),
					std::string(),
					EncapsulatingSymbolID(created_struct_id),
					default_delete_func_type.funcID(),
					evo::SmallVector<sema::Func::Param>{
						sema::Func::Param(created_struct.name.as<Token::ID>(), std::nullopt)
					},
					evo::SmallVector<Token::ID>(),
					evo::SmallVector<Token::ID>(),
					std::nullopt,
					1,
					false,
					sema::Func::Attributes{
						.isPub      = false,
						.isPriv     = false,
						.isComptime = is_comptime_deletable,
						.isNoReturn = false,
						.isExport   = false,
						.isImplicit = false,
					}
				);


				sema::Func& created_default_delete = this->context.sema_buffer.funcs[created_default_delete_id];

				const sema::Expr this_param = sema::Expr(this->context.sema_buffer.createParam(0, 0));

				for(const BaseType::Struct::MemberVar& member_var : created_struct.memberVars | std::views::reverse){
					if(this->context.getTypeManager().isTriviallyDeletable(member_var.typeID)){ continue; }

					const sema::Expr member_var_expr = [&](){
						for(
							uint32_t j = 0;
							const BaseType::Struct::MemberVar* member_var_abi : created_struct.memberVarsABI
						){
							if(member_var_abi == &member_var){
								return sema::Expr(this->context.sema_buffer.createAccessor(
									this_param, created_struct_type_id, j
								));
							}

							j += 1;
						}
						evo::debugFatalBreak("Didn't find ABI member");
					}();


					if(this->get_special_member_call_dependents<SpecialMemberKind::DELETE, false>(
						member_var.typeID,
						TermInfo::ValueCategory::CONCRETE_MUT,
						funcs_to_wait_on,
						Diagnostic::Location::NONE
					).isError()){
						evo::debugFatalBreak("Automatic creation of operator [delete] should not be able to fail");
					}
					created_default_delete.stmtBlock.emplace_back(
						this->context.sema_buffer.createDelete(member_var_expr, member_var.typeID)
					);

				}

				created_default_delete.stmtBlock.emplace_back(this->context.sema_buffer.createReturn());

				created_default_delete.isTerminated = true;
				created_default_delete.status = sema::Func::Status::DEF_DONE;

				created_struct.deleteOverload = created_default_delete_id;

				if(is_comptime_deletable){
					this->symbol_proc.data_stack.top().as<SymbolProc::StructSpecialMemberFuncs>().delete_func = 
						created_default_delete_id;
				}
			}
		}


		///////////////////////////////////
		// default move 
		//		(assumes that this runs BEFORE default copy)

		const BaseType::Struct::DeletableOverload copy_init_overload =
			created_struct.copyInitOverload.load(std::memory_order::relaxed);

		const BaseType::Struct::DeletableOverload move_init_overload =
			created_struct.moveInitOverload.load(std::memory_order::relaxed);

		if(move_init_overload.wasDeleted() == false && move_init_overload.funcID.has_value() == false){
			if(copy_init_overload.wasDeleted()){
				created_struct.moveInitOverload = BaseType::Struct::DeletableOverload(
					BaseType::Struct::DeletableOverload::State::IMPLICIT_OTHER_EXPLICITLY_DELETED
				);

			}else if(copy_init_overload.funcID.has_value()){
				created_struct.moveInitOverload = BaseType::Struct::DeletableOverload(copy_init_overload.funcID);

			}else{
				if(created_struct.moveAssignOverload.load(std::memory_order::relaxed).has_value()){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
						*created_struct.moveAssignOverload.load(std::memory_order::relaxed),
						"Operator [move] assignment overload cannot be defined without an operator [move] "
							"initialization overload"
					);
					return Result::ERROR;
				}


				bool is_movable = true;
				bool is_trivially_movable = true;
				bool is_comptime_movable = true;
				bool is_safe_movable = true;

				for(const BaseType::Struct::MemberVar& member_var : created_struct.memberVars){
					if(this->context.getTypeManager().isMovable(member_var.typeID) == false){
						is_movable = false;
						is_trivially_movable = false;
						is_comptime_movable = false;
						is_safe_movable = false;

						created_struct.moveInitOverload = BaseType::Struct::DeletableOverload(
							BaseType::Struct::DeletableOverload::State::IMPLICIT_MEMBER_DELETED
						);
						break;
					}

					if(
						is_trivially_movable
						&& this->context.getTypeManager().isTriviallyMovable(member_var.typeID) == false
					){
						is_trivially_movable = false;
					}


					if(is_comptime_movable == false){ continue; }
					if(this->context.getTypeManager().isComptimeMovable(
						member_var.typeID, this->context.getSemaBuffer()
					) == false){
						is_comptime_movable = false;
					}

					if(is_safe_movable == false){ continue; }
					if(this->context.getTypeManager().isSafeMovable(
						member_var.typeID, this->context.getSemaBuffer()
					) == false){
						is_safe_movable = false;
					}
				}



				if(is_movable && is_trivially_movable == false){
					const TypeInfo::ID created_struct_type_id = 
						this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(created_struct_id)));

					const BaseType::ID default_move_func_type = this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>{
								BaseType::Function::Param(
									created_struct_type_id, BaseType::Function::Param::Kind::MUT, false
								),
							},
							evo::SmallVector<TypeInfo::VoidableID>{created_struct_type_id},
							evo::SmallVector<TypeInfo::VoidableID>(),
							!is_safe_movable,
							false,
							false
						)
					);

					const sema::Func::ID created_default_move_id = this->context.sema_buffer.createFunc(
						this->source.getID(),
						sema::Func::CompilerCreatedOpOverload(
							created_struct.name.as<Token::ID>(), Token::Kind::KEYWORD_MOVE
						),
						std::string(),
						EncapsulatingSymbolID(created_struct_id),
						default_move_func_type.funcID(),
						evo::SmallVector<sema::Func::Param>{
							sema::Func::Param(created_struct.name.as<Token::ID>(), std::nullopt)
						},
						evo::SmallVector<Token::ID>{created_struct.name.as<Token::ID>()},
						evo::SmallVector<Token::ID>(),
						std::nullopt,
						1,
						false,
						sema::Func::Attributes{
							.isPub      = false,
							.isPriv     = false,
							.isComptime = is_comptime_movable,
							.isNoReturn = false,
							.isExport   = false,
							.isImplicit = false,
						}
					);


					sema::Func& created_default_move = this->context.sema_buffer.funcs[created_default_move_id];

					const sema::Expr this_param = sema::Expr(this->context.sema_buffer.createParam(0, 0));
					const sema::Expr output_param = sema::Expr(this->context.sema_buffer.createReturnParam(0, 1));

					for(const BaseType::Struct::MemberVar& member_var : created_struct.memberVars){
						auto this_member = std::optional<sema::Expr>();
						auto output_member = std::optional<sema::Expr>();

						for(
							uint32_t j = 0;
							const BaseType::Struct::MemberVar* member_var_abi : created_struct.memberVarsABI
						){
							if(member_var_abi == &member_var){
								this_member = sema::Expr(this->context.sema_buffer.createAccessor(
									this_param, created_struct_type_id, j
								));

								output_member = sema::Expr(this->context.sema_buffer.createAccessor(
									output_param, created_struct_type_id, j
								));

								break;
							}

							j += 1;
						}


						if(this->get_special_member_call_dependents<SpecialMemberKind::MOVE_INIT, false>(
							member_var.typeID,
							TermInfo::ValueCategory::CONCRETE_MUT,
							funcs_to_wait_on,
							Diagnostic::Location::NONE
						).isError()){
							evo::debugFatalBreak("Automatic creation of operator [move] should not be able to fail");
						}

						created_default_move.stmtBlock.emplace_back(
							this->context.sema_buffer.createAssign(
								*output_member,
								sema::Expr(this->context.sema_buffer.createMove(*this_member, member_var.typeID, true))
							)
						);
					}

					created_default_move.stmtBlock.emplace_back(this->context.sema_buffer.createReturn());

					created_default_move.isTerminated = true;
					created_default_move.status = sema::Func::Status::DEF_DONE;

					created_struct.moveInitOverload = BaseType::Struct::DeletableOverload(created_default_move_id);

					if(is_comptime_movable){
						this->symbol_proc.data_stack.top().as<SymbolProc::StructSpecialMemberFuncs>().move_func = 
							created_default_move_id;
					}
				}
			}
		}


		///////////////////////////////////
		// default copy
		//		(assumes that this runs AFTER default move)

		if(copy_init_overload.wasDeleted() == false && copy_init_overload.funcID.has_value() == false){
			if(move_init_overload.wasDeleted()){
				using DeletableOverloadState = BaseType::Struct::DeletableOverload::State;

				switch(move_init_overload.state){
					case DeletableOverloadState::NOT_DELETED: {
						evo::debugFatalBreak("Already found that move wasn't deleted");
					} break;

					case DeletableOverloadState::EXPLICITLY_DELETED: {
						created_struct.copyInitOverload = BaseType::Struct::DeletableOverload(
							DeletableOverloadState::IMPLICIT_OTHER_EXPLICITLY_DELETED
						);
					} break;

					case DeletableOverloadState::IMPLICIT_MEMBER_DELETED: {
						created_struct.copyInitOverload = BaseType::Struct::DeletableOverload(
							DeletableOverloadState::IMPLICIT_MEMBER_DELETED
						);
					} break;

					case DeletableOverloadState::IMPLICIT_OTHER_EXPLICITLY_DELETED: {
						evo::debugFatalBreak("Already found that copy was deleted");
					} break;
				}

				

			}else{
				if(created_struct.copyAssignOverload.load(std::memory_order::relaxed).has_value()){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
						*created_struct.copyAssignOverload.load(std::memory_order::relaxed),
						"Operator [copy] assignment overload cannot be defined without an operator [copy] "
							"initialization overload"
					);
					return Result::ERROR;
				}

				bool is_copyable = true;
				bool is_trivially_copyable = true;
				bool is_comptime_copyable = true;
				bool is_safe_copyable = true;

				for(const BaseType::Struct::MemberVar& member_var : created_struct.memberVars){
					if(this->context.getTypeManager().isCopyable(member_var.typeID) == false){
						is_copyable = false;
						is_trivially_copyable = false;
						is_comptime_copyable = false;
						is_safe_copyable = false;

						created_struct.copyInitOverload = BaseType::Struct::DeletableOverload(
							BaseType::Struct::DeletableOverload::State::IMPLICIT_MEMBER_DELETED
						);
						continue;
					}

					if(
						is_trivially_copyable
						&& this->context.getTypeManager().isTriviallyCopyable(member_var.typeID) == false
					){
						is_trivially_copyable = false;
						break;
					}


					if(is_comptime_copyable == false){ continue; }
					if(this->context.getTypeManager().isComptimeCopyable(
						member_var.typeID, this->context.getSemaBuffer()
					) == false){
						is_comptime_copyable = false;
					}

					if(is_safe_copyable == false){ continue; }
					if(this->context.getTypeManager().isSafeCopyable(
						member_var.typeID, this->context.getSemaBuffer()
					) == false){
						is_safe_copyable = false;
					}
				}



				if(is_copyable && is_trivially_copyable == false){
					const TypeInfo::ID created_struct_type_id = 
						this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(created_struct_id)));

					const BaseType::ID default_copy_func_type = this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>{
								BaseType::Function::Param(
									created_struct_type_id, BaseType::Function::Param::Kind::MUT, false
								),
							},
							evo::SmallVector<TypeInfo::VoidableID>{created_struct_type_id},
							evo::SmallVector<TypeInfo::VoidableID>(),
							!is_safe_copyable,
							false,
							false
						)
					);

					const sema::Func::ID created_default_copy_id = this->context.sema_buffer.createFunc(
						this->source.getID(),
						sema::Func::CompilerCreatedOpOverload(
							created_struct.name.as<Token::ID>(), Token::Kind::KEYWORD_COPY
						),
						std::string(),
						EncapsulatingSymbolID(created_struct_id),
						default_copy_func_type.funcID(),
						evo::SmallVector<sema::Func::Param>{
							sema::Func::Param(created_struct.name.as<Token::ID>(), std::nullopt)
						},
						evo::SmallVector<Token::ID>{created_struct.name.as<Token::ID>()},
						evo::SmallVector<Token::ID>(),
						std::nullopt,
						1,
						false,
						sema::Func::Attributes{
							.isPub      = false,
							.isPriv     = false,
							.isComptime = is_comptime_copyable,
							.isNoReturn = false,
							.isExport   = false,
							.isImplicit = false,
						}
					);


					sema::Func& created_default_copy = this->context.sema_buffer.funcs[created_default_copy_id];

					const sema::Expr this_param = sema::Expr(this->context.sema_buffer.createParam(0, 0));
					const sema::Expr output_param = sema::Expr(this->context.sema_buffer.createReturnParam(0, 1));

					for(const BaseType::Struct::MemberVar& member_var : created_struct.memberVars){
						auto this_member = std::optional<sema::Expr>();
						auto output_member = std::optional<sema::Expr>();

						for(
							uint32_t j = 0;
							const BaseType::Struct::MemberVar* member_var_abi : created_struct.memberVarsABI
						){
							if(member_var_abi == &member_var){
								this_member = sema::Expr(this->context.sema_buffer.createAccessor(
									this_param, created_struct_type_id, j
								));

								output_member = sema::Expr(this->context.sema_buffer.createAccessor(
									output_param, created_struct_type_id, j
								));

								break;
							}

							j += 1;
						}



						if(this->get_special_member_call_dependents<SpecialMemberKind::COPY_INIT, false>(
							member_var.typeID,
							TermInfo::ValueCategory::CONCRETE_MUT,
							funcs_to_wait_on,
							Diagnostic::Location::NONE
						).isError()){
							evo::debugFatalBreak("Automatic creation of operator [copy] should not be able to fail");
						}

						created_default_copy.stmtBlock.emplace_back(
							this->context.sema_buffer.createAssign(
								*output_member,
								sema::Expr(this->context.sema_buffer.createCopy(*this_member, member_var.typeID, true))
							)
						);
					}

					created_default_copy.stmtBlock.emplace_back(this->context.sema_buffer.createReturn());

					created_default_copy.isTerminated = true;
					created_default_copy.status = sema::Func::Status::DEF_DONE;

					created_struct.copyInitOverload = BaseType::Struct::DeletableOverload(created_default_copy_id);

					if(is_comptime_copyable){
						this->symbol_proc.data_stack.top().as<SymbolProc::StructSpecialMemberFuncs>().copy_func = 
							created_default_copy_id;
					}
				}
			}
		}




		///////////////////////////////////
		// wait on funcs

		bool waiting_on_any = false;
		for(const sema::Func::ID func_to_wait_on_id : funcs_to_wait_on){
			const sema::Func& func_to_wait_on = this->context.getSemaBuffer().getFunc(func_to_wait_on_id);
			if(func_to_wait_on.symbolProcID.has_value() == false){ continue; }

			SymbolProc& wait_on_func = this->context.symbol_proc_manager.getSymbolProc(*func_to_wait_on.symbolProcID);

			switch(wait_on_func.waitOnDeclIfNeeded(this->symbol_proc_id, this->context, *func_to_wait_on.symbolProcID)){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                 break;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*func_to_wait_on.symbolProcID);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                    waiting_on_any = true; break;
				case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: return Result::ERROR;
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
			}
		}

		if(waiting_on_any){
			return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
		}else{
			return Result::SUCCESS;
		}
	}



	auto SemanticAnalyzer::instr_struct_created_sepcial_members_pir_if_needed() -> Result {
		auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);


		const SymbolProc::StructSpecialMemberFuncs& struct_special_member_funcs = 
			this->symbol_proc.data_stack.top().as<SymbolProc::StructSpecialMemberFuncs>();


		const auto lower_func = [&](sema::Func::ID target_func_id) -> evo::Result<> {
			sema::Func& target_func = this->context.sema_buffer.funcs[target_func_id];


			target_func.comptimeJITFunc = sema_to_pir.lowerFuncDeclComptime(target_func_id);

			sema_to_pir.lowerFuncDef(target_func_id);

			///////////////////////////////////
			// The following code commented code is for lowering directly to JIT
			// I'm purposely keeping this here (at least for now)

			// target_func.comptimeJITInterfaceFunc = sema_to_pir.createFuncJITInterface(
			// 	target_func_id, *target_func.comptimeJITFunc
			// );


			// auto module_subset_funcs = evo::StaticVector<pir::Function::ID, 2>{
			// 	*target_func.comptimeJITFunc, *target_func.comptimeJITInterfaceFunc
			// };

			// const evo::Expected<void, evo::SmallVector<std::string>> add_module_subset_result = 
			// 	this->context.comptime_jit_engine.addModuleSubsetWithWeakDependencies(
			// 		this->context.pir_module,
			// 		pir::JITEngine::ModuleSubsets{ .funcs = module_subset_funcs, }
			// 	);

			// if(add_module_subset_result.has_value() == false){
			// 	auto infos = evo::SmallVector<Diagnostic::Info>();
			// 	for(const std::string& error : add_module_subset_result.error()){
			// 		infos.emplace_back(std::format("Message from LLVM: \"{}\"", error));
			// 	}

			// 	this->emit_fatal(
			// 		Diagnostic::Code::MISC_LLVM_ERROR,
			// 		this->symbol_proc.extra_info.as<SymbolProc::StructInfo>().struct_id,
			// 		Diagnostic::createFatalMessage(
			// 			"Failed to setup PIR JIT interface generated default operator [new]"
			// 		),
			// 		std::move(infos)
			// 	);
			// 	return evo::resultError;
			// }

			return evo::Result<>();
		};



		if(struct_special_member_funcs.init_func.has_value()){
			if(lower_func(*struct_special_member_funcs.init_func).isError()){ return Result::ERROR; }
		}

		if(struct_special_member_funcs.delete_func.has_value()){
			if(lower_func(*struct_special_member_funcs.delete_func).isError()){ return Result::ERROR; }
		}

		if(struct_special_member_funcs.copy_func.has_value()){
			if(lower_func(*struct_special_member_funcs.copy_func).isError()){ return Result::ERROR; }
		}

		if(struct_special_member_funcs.move_func.has_value()){
			if(lower_func(*struct_special_member_funcs.move_func).isError()){ return Result::ERROR; }
		}



		this->symbol_proc.data_stack.pop();


		///////////////////////////////////
		// done

		this->context.type_manager.getStruct(
			this->symbol_proc.extra_info.as<SymbolProc::StructInfo>().struct_id
		).defCompleted = true;

		this->propagate_finished_def();

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_template_struct(const Instruction::TemplateStruct& instr) -> Result {
		size_t minimum_num_template_args = 0;
		auto params = evo::SmallVector<BaseType::StructTemplate::Param>();

		const AST::TemplatePack& ast_template_pack = 
			this->source.getASTBuffer().getTemplatePack(*instr.struct_def.templatePack);

		using TemplateParamInfo = SymbolProc::Instruction::TemplateParamInfo;
		for(size_t i = 0; const TemplateParamInfo& template_param_info : instr.template_param_infos){
			EVO_DEFER([&](){ i += 1; });

			auto type_id = std::optional<TypeInfoID>();
			if(template_param_info.type_id.has_value()){
				const TypeInfo::VoidableID type_info_voidable_id = this->get_type(*template_param_info.type_id);
				if(type_info_voidable_id.isVoid()){
					this->emit_error(
						Diagnostic::Code::SEMA_TEMPLATE_PARAM_CANNOT_BE_TYPE_VOID,
						template_param_info.param.type,
						"Template parameter cannot be type `Void`"
					);
					return Result::ERROR;
				}
				type_id = type_info_voidable_id.asTypeID();
			}

			TermInfo* default_value = nullptr;
			if(template_param_info.default_value.has_value()){
				default_value = &this->get_term_info(*template_param_info.default_value);

				if(type_id.has_value()){
					if(default_value->isSingleValue() == false){
						if(default_value->isMultiValue()){
							this->emit_error(
								Diagnostic::Code::SEMA_TEMPLATE_PARAM_EXPR_DEFAULT_MUST_BE_EXPR,
								*template_param_info.param.defaultValue,
								"Default of an expression template parameter must be a single expression"
							);	
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_TEMPLATE_PARAM_EXPR_DEFAULT_MUST_BE_EXPR,
								*template_param_info.param.defaultValue,
								"Default of an expression template parameter must be an expression"
							);
						}
						return Result::ERROR;
					}

					const TypeCheckInfo type_check_info = this->type_check<true, true>(
						*type_id,
						*default_value,
						"Default value of template parameter",
						*template_param_info.param.defaultValue
					);
					if(type_check_info.ok == false){
						return Result::ERROR;
					}

				}else{
					if(default_value->value_category != TermInfo::ValueCategory::TYPE){
						this->emit_error(
							Diagnostic::Code::SEMA_TEMPLATE_PARAM_TYPE_DEFAULT_MUST_BE_TYPE,
							*template_param_info.param.defaultValue,
							"Default of a [Type] template parameter must be an type"
						);
						return Result::ERROR;
					}
				}
			}else{
				minimum_num_template_args += 1;
			}

			if(default_value == nullptr){
				params.emplace_back(
					this->source.getASTBuffer().getType(ast_template_pack.params[i].type), type_id, std::monostate()
				);

			}else if(default_value->value_category == TermInfo::ValueCategory::TYPE){
				params.emplace_back(
					this->source.getASTBuffer().getType(ast_template_pack.params[i].type),
					type_id,
					default_value->type_id.as<TypeInfo::VoidableID>()
				);

			}else{
				params.emplace_back(
					this->source.getASTBuffer().getType(ast_template_pack.params[i].type),
					type_id,
					default_value->getExpr()
				);
			}
		}


		const BaseType::ID created_struct_type_id = this->context.type_manager.createStructTemplate(
			BaseType::StructTemplate(
				this->source.getID(),
				instr.struct_def.ident,
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				std::move(params),
				minimum_num_template_args
			)
		);
		
		const sema::TemplatedStruct::ID new_templated_struct = this->context.sema_buffer.createTemplatedStruct(
			created_struct_type_id.structTemplateID(), this->symbol_proc
		);

		const std::string_view ident_str = this->source.getTokenBuffer()[instr.struct_def.ident].getString();
		if(this->add_ident_to_scope(ident_str, instr.struct_def, true, new_templated_struct).isError()){
			return Result::ERROR;
		}

		this->propagate_finished_decl_def();

		return Result::SUCCESS;
	};


	auto SemanticAnalyzer::instr_union_decl(const Instruction::UnionDecl& instr) -> Result {
		const evo::Result<UnionAttrs> union_attrs = 
			this->analyze_union_attrs(instr.union_def, instr.attribute_params_info);
		if(union_attrs.isError()){ return Result::ERROR; }



		///////////////////////////////////
		// create

		SymbolProc::UnionInfo& union_info = this->symbol_proc.extra_info.as<SymbolProc::UnionInfo>();


		const BaseType::ID created_union = this->context.type_manager.createUnion(
			BaseType::Union(
				this->source.getID(),
				instr.union_def.ident,
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				evo::SmallVector<BaseType::Union::Field>(),
				&union_info.member_symbols,
				nullptr,
				union_attrs.value().is_pub,
				union_attrs.value().is_priv,
				union_attrs.value().is_untagged
			)
		);

		union_info.union_id = created_union.unionID();


		const std::string_view ident_str = this->source.getTokenBuffer()[instr.union_def.ident].getString();
		if(this->add_ident_to_scope(ident_str, instr.union_def, true, created_union.unionID()).isError()){
			return Result::ERROR;
		}

		this->context.symbol_proc_manager.addTypeSymbolProc(
			this->context.type_manager.getOrCreateTypeInfo(TypeInfo(created_union)), this->symbol_proc_id
		);



		///////////////////////////////////
		// setup scope

		this->push_scope_level(nullptr, created_union.unionID());

		BaseType::Union& created_union_ref = this->context.type_manager.getUnion(created_union.unionID());
		created_union_ref.scopeLevel = &this->get_current_scope_level();


		for(const SymbolProc::ID& member_stmt_id : union_info.stmts){
			SymbolProc& member_stmt = this->context.symbol_proc_manager.getSymbolProc(member_stmt_id);

			member_stmt.sema_scope_id = this->context.sema_buffer.scope_manager.copyScope(
				*this->symbol_proc.sema_scope_id
			);
		}


		///////////////////////////////////
		// done

		this->propagate_finished_decl();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_union_add_fields(const Instruction::UnionAddFields& instr) -> Result {
		SymbolProc::UnionInfo& union_info = this->symbol_proc.extra_info.as<SymbolProc::UnionInfo>();

		BaseType::Union& union_type = this->context.type_manager.getUnion(union_info.union_id);

		union_type.fields.reserve(instr.field_types.size());
		for(size_t i = 0; SymbolProc::TypeID field_symbol_proc_type_id : instr.field_types){
			const TypeInfo::VoidableID field_type_id = this->get_type(field_symbol_proc_type_id);

			const AST::UnionDef::Field& ast_field = instr.union_def.fields[union_type.fields.size()];

			if(union_type.isUntagged){
				if(field_type_id.isVoid()){
					this->emit_error(
						Diagnostic::Code::SEMA_UNION_UNTAGGED_WITH_VOID_FIELD,
						ast_field.type,
						"Fields in untagged unions cannot be type \"Void\""
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isTriviallyDeletable(field_type_id.asTypeID()) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_UNION_UNTAGGED_NON_TRIVIALLY_DELETABLE_FIELD,
						ast_field.type,
						"Fields in untagged unions must be trivially deletable"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isTriviallyCopyable(field_type_id.asTypeID()) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_UNION_UNTAGGED_NON_TRIVIALLY_COPYABLE_FIELD,
						ast_field.type,
						"Fields in untagged unions must be trivially copyable"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isTriviallyMovable(field_type_id.asTypeID()) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_UNION_UNTAGGED_NON_TRIVIALLY_MOVABLE_FIELD,
						ast_field.type,
						"Fields in untagged unions must be trivially movable"
					);
					return Result::ERROR;
				}
			}

			

			union_type.fields.emplace_back(ast_field.ident, field_type_id);

			const std::string_view ident_str = this->source.getTokenBuffer()[ast_field.ident].getString();
			if(this->add_ident_to_scope(
				ident_str, ast_field.ident, true, sema::ScopeLevel::UnionFieldFlag{}, ast_field.ident, uint32_t(i)
			).isError()){
				return Result::ERROR;
			}

			i += 1;
		}


		///////////////////////////////////
		// wait on stmts

		bool waiting_on_any = false;
		for(const SymbolProc::ID& member_stmt_id : union_info.stmts){
			SymbolProc& member_stmt = this->context.symbol_proc_manager.getSymbolProc(member_stmt_id);

			switch(member_stmt.waitOnDeclIfNeeded(this->symbol_proc_id, this->context, member_stmt_id)){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                 break;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(member_stmt_id);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                    waiting_on_any = true; break;
				case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: return Result::ERROR;
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
			}
		}

		if(waiting_on_any){
			return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
		}else{
			return Result::SUCCESS;
		}
	}

	auto SemanticAnalyzer::instr_union_def() -> Result {
		SymbolProc::UnionInfo& union_info = this->symbol_proc.extra_info.as<SymbolProc::UnionInfo>();

		BaseType::Union& union_type = this->context.type_manager.getUnion(union_info.union_id);

		union_type.defCompleted = true;


		auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);

		sema_to_pir.lowerUnion(union_info.union_id);

		this->propagate_finished_def();

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_enum_decl(const Instruction::EnumDecl& instr) -> Result {
		BaseType::Primitive::ID underlying_type_id = BaseType::Primitive::ID::dummy();

		if(instr.underlying_type.has_value()){
			const TypeInfo::VoidableID computed_underlying_type = this->get_type(*instr.underlying_type);

			if(this->context.getTypeManager().isIntegral(computed_underlying_type) == false){
				this->emit_error(
					Diagnostic::Code::SEMA_ENUM_INVALID_UNDERLYING_TYPE,
					*instr.enum_def.underlyingType,
					"Invalid underlying type for enum",
					Diagnostic::Info("Note: underlying type for enums must be integral")
				);
				return Result::ERROR;
			}

			underlying_type_id = this->context.getTypeManager()
				.getTypeInfo(computed_underlying_type.asTypeID())
				.baseTypeID()
				.primitiveID();

		}else{
			underlying_type_id =
				this->context.type_manager.getOrCreatePrimitiveBaseType(Token::Kind::TYPE_UI_N, 32).primitiveID();
		}


		const evo::Result<EnumAttrs> enum_attrs = 
			this->analyze_enum_attrs(instr.enum_def, instr.attribute_params_info);
		if(enum_attrs.isError()){ return Result::ERROR; }


		///////////////////////////////////
		// create

		SymbolProc::EnumInfo& enum_info = this->symbol_proc.extra_info.as<SymbolProc::EnumInfo>();


		const BaseType::ID created_enum = this->context.type_manager.createEnum(
			BaseType::Enum(
				this->source.getID(),
				instr.enum_def.ident,
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				evo::SmallVector<BaseType::Enum::Enumerator>(),
				underlying_type_id,
				&enum_info.member_symbols,
				nullptr,
				enum_attrs.value().is_pub,
				enum_attrs.value().is_priv
			)
		);

		enum_info.enum_id = created_enum.enumID();


		const std::string_view ident_str = this->source.getTokenBuffer()[instr.enum_def.ident].getString();
		if(this->add_ident_to_scope(ident_str, instr.enum_def, true, created_enum.enumID()).isError()){
			return Result::ERROR;
		}

		this->context.symbol_proc_manager.addTypeSymbolProc(
			this->context.type_manager.getOrCreateTypeInfo(TypeInfo(created_enum)), this->symbol_proc_id
		);



		///////////////////////////////////
		// setup scope

		this->push_scope_level(nullptr, created_enum.enumID());

		BaseType::Enum& created_enum_ref = this->context.type_manager.getEnum(created_enum.enumID());
		created_enum_ref.scopeLevel = &this->get_current_scope_level();


		for(const SymbolProc::ID& member_stmt_id : enum_info.stmts){
			SymbolProc& member_stmt = this->context.symbol_proc_manager.getSymbolProc(member_stmt_id);

			member_stmt.sema_scope_id = this->context.sema_buffer.scope_manager.copyScope(
				*this->symbol_proc.sema_scope_id
			);
		}


		///////////////////////////////////
		// done

		this->propagate_finished_decl();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_enum_add_enumerators(const Instruction::EnumAddEnumerators& instr) -> Result {
		const SymbolProc::EnumInfo& enum_info = this->symbol_proc.extra_info.as<SymbolProc::EnumInfo>();
			
		BaseType::Enum& target_enum = this->context.type_manager.getEnum(enum_info.enum_id);

		const unsigned underlying_bits =
			unsigned(this->context.getTypeManager().numBits(BaseType::ID(target_enum.underlyingTypeID), false));

		const TypeInfo::ID underlying_type_info_id = this->context.type_manager.getOrCreateTypeInfo(
			TypeInfo(BaseType::ID(target_enum.underlyingTypeID))
		);

		auto enumerator_value_counter = core::GenericInt(underlying_bits, 0);
		for(size_t i = 0; const AST::EnumDef::Enumerator& enumerator : instr.enum_def.enumerators){
			if(enumerator.value.has_value()){
				TermInfo& value_term_info = this->get_term_info(*instr.enumerator_values[i]);

				if(value_term_info.value_stage != TermInfo::ValueStage::COMPTIME){
					this->emit_error(
						Diagnostic::Code::SEMA_EXPR_NOT_COMPTIME,
						*enumerator.value,
						"Enumerator value is not comptime"
					);
					return Result::ERROR;
				}

				if(this->type_check<true, true>(
					underlying_type_info_id, value_term_info, "Value for enumerator", *enumerator.value
				).ok == false){
					return Result::ERROR;
				}

				const sema::IntValue& int_value =
					this->context.getSemaBuffer().getIntValue(value_term_info.getExpr().intValueID());

				target_enum.enumerators.emplace_back(enumerator.ident, int_value.value.trunc(underlying_bits));
				enumerator_value_counter = 
					int_value.value.trunc(underlying_bits).uadd(core::GenericInt(underlying_bits, 1)).result;

			}else{
				target_enum.enumerators.emplace_back(enumerator.ident, enumerator_value_counter);
				enumerator_value_counter = enumerator_value_counter.uadd(core::GenericInt(underlying_bits, 1)).result;
			}

			i += 1;
		}

		///////////////////////////////////
		// wait on stmts

		bool waiting_on_any = false;
		for(const SymbolProc::ID& member_stmt_id : enum_info.stmts){
			SymbolProc& member_stmt = this->context.symbol_proc_manager.getSymbolProc(member_stmt_id);

			switch(member_stmt.waitOnDeclIfNeeded(this->symbol_proc_id, this->context, member_stmt_id)){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                 break;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(member_stmt_id);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                    waiting_on_any = true; break;
				case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: return Result::ERROR;
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
			}
		}

		if(waiting_on_any){
			return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
		}else{
			return Result::SUCCESS;
		}
	}


	auto SemanticAnalyzer::instr_enum_def() -> Result {
		SymbolProc::EnumInfo& enum_info = this->symbol_proc.extra_info.as<SymbolProc::EnumInfo>();
		BaseType::Enum& enum_type = this->context.type_manager.getEnum(enum_info.enum_id);
		enum_type.defCompleted = true;
		this->propagate_finished_def();

		return Result::SUCCESS;
	}






	auto SemanticAnalyzer::instr_func_decl_extract_deducers(const Instruction::FuncDeclExtractDeducers& instr)
	-> Result {
		evo::debugAssert(
			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().instantiation != nullptr,
			"Should only use this instruction if is a function instantiation"
		);

		const TypeInfo::VoidableID param_type = this->get_type(instr.param_type);

		const DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
			param_type.asTypeID(),
			*this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().instantiation_param_arg_types[instr.param_index]
		);

		switch(deducer_match_output.outcome()){
			case DeducerMatchOutput::Outcome::MATCH: {
				if(this->add_deduced_terms_to_scope(deducer_match_output.deducedTerms()).isError()){
					return Result::ERROR;
				}else{
					return Result::SUCCESS;
				}
			} break;

			case DeducerMatchOutput::Outcome::NO_MATCH: {
				SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();

				func_info.instantiation->errored_reason = 
					sema::TemplatedFunc::Instantiation::ErroredReasonParamDeductionFailed(instr.param_index);

				this->propagate_finished_decl();
				return Result::ERROR_NO_REPORT;
			} break;

			case DeducerMatchOutput::Outcome::RESULT: {
				return deducer_match_output.result();
			} break;
		}

		evo::debugFatalBreak("Unknown deducer match outcome");
	}


	template<bool IS_INSTANTIATION>
	auto SemanticAnalyzer::instr_func_decl(const Instruction::FuncDecl<IS_INSTANTIATION>& instr) -> Result {
		const evo::Result<FuncAttrs> func_attrs =
			this->analyze_func_attrs(instr.func_def, instr.attribute_params_info);
		if(func_attrs.isError()){ return Result::ERROR; }

		SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();


		const auto is_invalid_commutative_check = [&]() -> evo::Result<> {
			if(func_attrs.value().is_commutative){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.func_def,
					"This function cannot have attribute #commutative"
				);
				return evo::resultError;
			}
			return evo::Result<>();
		};

		const auto is_invalid_swapped_check = [&]() -> evo::Result<> {
			if(func_attrs.value().is_swapped){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.func_def,
					"This function cannot have attribute #swapped"
				);
				return evo::resultError;
			}
			return evo::Result<>();
		};

		const auto is_invalid_implicit_check = [&]() -> evo::Result<> {
			if(func_attrs.value().is_implicit){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
					instr.func_def,
					"This function cannot have attribute #implicit"
				);
				return evo::resultError;
			}
			return evo::Result<>();
		};

		switch(this->source.getTokenBuffer()[instr.func_def.name].kind()){
			case Token::lookupKind("+"):   case Token::lookupKind("+%"): case Token::lookupKind("+|"):
			case Token::lookupKind("-"):   case Token::lookupKind("-%"): case Token::lookupKind("-|"):
			case Token::lookupKind("*"):   case Token::lookupKind("*%"): case Token::lookupKind("*|"):
			case Token::lookupKind("/"):   case Token::lookupKind("%"):  case Token::lookupKind("=="):
			case Token::lookupKind("!="):  case Token::lookupKind("<"):  case Token::lookupKind("<="):
			case Token::lookupKind(">"):   case Token::lookupKind(">="): case Token::lookupKind("!"):
			case Token::lookupKind("&&"):  case Token::lookupKind("||"): case Token::lookupKind("<<"):
			case Token::lookupKind("<<|"): case Token::lookupKind(">>"): case Token::lookupKind("&"):
			case Token::lookupKind("|"):   case Token::lookupKind("^"):  case Token::lookupKind("~"): {
				if(is_invalid_implicit_check().isError()){ return Result::ERROR; }
			} break;

			case Token::Kind::KEYWORD_NEW: {
				if(is_invalid_commutative_check().isError()){ return Result::ERROR; }
				if(is_invalid_swapped_check().isError()){ return Result::ERROR; }
				// check for valid #implicit later
			} break;

			case Token::Kind::KEYWORD_AS: {
				if(is_invalid_commutative_check().isError()){ return Result::ERROR; }
				if(is_invalid_swapped_check().isError()){ return Result::ERROR; }
			} break;

			default: {
				if(is_invalid_commutative_check().isError()){ return Result::ERROR; }
				if(is_invalid_swapped_check().isError()){ return Result::ERROR; }
				if(is_invalid_implicit_check().isError()){ return Result::ERROR; }
			} break;
		}


		///////////////////////////////////
		// create func type

		const ASTBuffer& ast_buffer = this->source.getASTBuffer();


		auto params = evo::SmallVector<BaseType::Function::Param>();
		params.reserve(instr.func_def.params.size());

		auto sema_params = evo::SmallVector<sema::Func::Param>();
		sema_params.reserve(instr.func_def.params.size());

		uint32_t min_num_args = 0;
		bool has_in_param = false;
		bool has_this_param = false;

		for(size_t i = 0; const std::optional<SymbolProc::TypeID>& symbol_proc_param_type_id : instr.params()){
			EVO_DEFER([&](){ i += 1; });

			const AST::FuncDef::Param& param = instr.func_def.params[i];
			
			evo::debugAssert(
				symbol_proc_param_type_id.has_value() == (param.name.kind() != AST::Kind::THIS),
				"[this] is the only must not have a type, and everything else must have a type"
			);


			const BaseType::Function::Param::Kind type_param_kind = [&](){
				switch(param.kind){
					case AST::FuncDef::Param::Kind::READ: return BaseType::Function::Param::Kind::READ;
					case AST::FuncDef::Param::Kind::MUT:  return BaseType::Function::Param::Kind::MUT;
					case AST::FuncDef::Param::Kind::IN:   return BaseType::Function::Param::Kind::IN;
				}
				evo::debugFatalBreak("Unknown ast param kind");
			}();


			if(symbol_proc_param_type_id.has_value()){ // regular param
				const TypeInfo::VoidableID decl_param_type_id = this->get_type(*symbol_proc_param_type_id);

				if(decl_param_type_id.isVoid()){
					this->emit_error(
						Diagnostic::Code::SEMA_PARAM_TYPE_VOID, *param.type, "Function parameter cannot be type `Void`"
					);
					return Result::ERROR;
				}

				const bool decl_param_type_is_deducer =
					this->context.getTypeManager().isTypeDeducer(decl_param_type_id.asTypeID());


				auto [param_type_id, param_type] = [&]() -> std::pair<TypeInfo::ID, const TypeInfo&> {
					if(decl_param_type_is_deducer){
						const TypeInfo::ID type_id =
							*func_info.instantiation_param_arg_types[i - size_t(has_this_param)];

						return std::pair<TypeInfo::ID, const TypeInfo&>(
							type_id, this->context.getTypeManager().getTypeInfo(type_id)
						);
					}else{
						return std::pair<TypeInfo::ID, const TypeInfo&>(
							decl_param_type_id.asTypeID(),
							this->context.getTypeManager().getTypeInfo(decl_param_type_id.asTypeID())
						);
					}
				}();



				if(param_type.baseTypeID().kind() == BaseType::Kind::INTERFACE){
					this->emit_error(
						Diagnostic::Code::SEMA_PARAM_TYPE_INTERFACE,
						*param.type,
						"Function parameter cannot be an interface type"
					);
					return Result::ERROR;
				}

				if(param_type.isUninitPointer()){
					this->emit_error(
						Diagnostic::Code::SEMA_PARAM_TYPE_UNINIT_PTR,
						*param.type,
						"Type of function parameter cannot be a uninitialized-qualified pointer"
					);
					return Result::ERROR;
				}



				// saving types to check if param should be copy
				// 	(need to do later after definitions of types are gotten)
				if(param.kind == AST::FuncDef::Param::Kind::READ){
					func_info.param_type_to_check_if_is_copy.emplace_back(param_type_id);
				}else{
					func_info.param_type_to_check_if_is_copy.emplace_back();
				}


				if(param.kind == AST::FuncDef::Param::Kind::IN){
					has_in_param = true;
				}

				params.emplace_back(param_type_id, type_param_kind, false);

				if(instr.default_param_values[i - size_t(has_this_param)].has_value()){
					TermInfo default_param_value =
						this->get_term_info(*instr.default_param_values[i - size_t(has_this_param)]);

					if(
						this->type_check<true, true>(
							param_type_id,
							default_param_value,
							"Default value of function parameter",
							*instr.func_def.params[i].defaultValue
						).ok == false
					){
						return Result::ERROR;
					}

					sema_params.emplace_back(ast_buffer.getIdent(param.name), default_param_value.getExpr());

				}else{
					sema_params.emplace_back(ast_buffer.getIdent(param.name), std::nullopt);
					min_num_args += 1;
				}

			}else{ // [this] param
				has_this_param = true;

				const std::optional<EncapsulatingSymbolID> current_type_scope = 
					this->scope.getCurrentTypeScopeIfExists();

				if(current_type_scope.has_value() == false){
					// TODO(FUTURE): better messaging
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_SCOPE_FOR_THIS_PARAM,
						param.name,
						"[this] parameters are only valid inside type scope"
					);
					return Result::ERROR;
				}

				if(i != 0){
					this->emit_error(
						Diagnostic::Code::SEMA_THIS_PARAM_NOT_FIRST,
						param.name,
						instr.params()[0].has_value()
							? "[this] parameters must be the first parameter"
							: "Cannot have multiple [this] parameters"
					);
					return Result::ERROR;
				}

				if(param.kind == AST::FuncDef::Param::Kind::IN){
					has_in_param = true;
				}

				current_type_scope->visit([&](const auto& type_scope) -> void {
					using TypeScope = std::decay_t<decltype(type_scope)>;

					if constexpr(
						std::is_same<TypeScope, BaseType::Struct::ID>() 
						|| std::is_same<TypeScope, BaseType::Union::ID>()
						|| std::is_same<TypeScope, BaseType::Enum::ID>()
						|| std::is_same<TypeScope, BaseType::Interface::ID>()
					){
						const TypeInfo::ID this_type = this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(BaseType::ID(type_scope))
						);

						params.emplace_back(this_type, type_param_kind, false);

					}else if constexpr(std::is_same<TypeScope, EncapsulatingSymbolID::InterfaceImplInfo>()){
						params.emplace_back(type_scope.targetTypeID, type_param_kind, false);

					}else if constexpr(std::is_same<TypeScope, sema::Func::ID>()){
						evo::debugFatalBreak("Invalid type object scope");

					}else{
						static_assert(false, "Unknown object scope");
					}
				});

				sema_params.emplace_back(ast_buffer.getThis(param.name), std::nullopt);
				min_num_args += 1;

				func_info.param_type_to_check_if_is_copy.emplace_back();
			}
		}


		if constexpr(IS_INSTANTIATION){
			if(instr.func_def.isVariadic & (instr.num_extra_variadics != 0)){
				const AST::FuncDef::Param& variadic_param = instr.func_def.params.back();

				const std::optional<TypeInfo::ID> variadic_param_type = [&]() -> std::optional<TypeInfo::ID> {
					const TypeInfo::ID got_variadic_param_type_id = this->get_type(*instr.params().back()).asTypeID();

					if(this->context.getTypeManager().isTypeDeducer(got_variadic_param_type_id)){
						return std::nullopt;
					}else{
						return got_variadic_param_type_id;
					}
				}();

				const BaseType::Function::Param::Kind type_param_kind = [&](){
					switch(variadic_param.kind){
						case AST::FuncDef::Param::Kind::READ: return BaseType::Function::Param::Kind::READ;
						case AST::FuncDef::Param::Kind::MUT:  return BaseType::Function::Param::Kind::MUT;
						case AST::FuncDef::Param::Kind::IN:   return BaseType::Function::Param::Kind::IN;
					}
					evo::debugFatalBreak("Unknown ast param kind");
				}();

				for(size_t i = 0; i < instr.num_extra_variadics; i+=1){
					const TypeInfo::ID arg_type_id = [&]() -> TypeInfo::ID {
						if(variadic_param_type.has_value()){
							return *variadic_param_type;
						}else{
							return *func_info.instantiation_param_arg_types[
								instr.params().size() + i - size_t(has_this_param)
							];
						}
					}();

					if(variadic_param.kind == AST::FuncDef::Param::Kind::READ){
						func_info.param_type_to_check_if_is_copy.emplace_back(arg_type_id);
					}else{
						func_info.param_type_to_check_if_is_copy.emplace_back();
					}

					params.emplace_back(arg_type_id, type_param_kind, false);
					sema_params.emplace_back(ast_buffer.getIdent(variadic_param.name), std::nullopt);

					min_num_args += 1;
				}
			}
		}


		auto return_params = evo::SmallVector<TypeInfo::VoidableID>();
		auto return_param_idents = evo::SmallVector<Token::ID>();
		for(size_t i = 0; const SymbolProc::TypeID& symbol_proc_return_param_type_id : instr.returns()){
			EVO_DEFER([&](){ i += 1; });

			const TypeInfo::VoidableID return_param_type_id = this->get_type(symbol_proc_return_param_type_id);

			const AST::FuncDef::Return& ast_return_param = instr.func_def.returns[i];

			if(return_param_type_id.isVoid()){
				if(i == 0){
					if(ast_return_param.ident.has_value()){
						this->emit_error(
							Diagnostic::Code::SEMA_NAMED_VOID_RETURN,
							*ast_return_param.ident,
							"A function return parameter that is type `Void` cannot be named"
						);
						return Result::ERROR;
					}
				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_NOT_FIRST_RETURN_VOID,
						ast_return_param.type,
						"Only the first function return parameter can be type `Void`"
					);
					return Result::ERROR;
				}

			}else{
				const TypeInfo& return_param_type_info =
					this->context.getTypeManager().getTypeInfo(return_param_type_id.asTypeID());

				if(return_param_type_info.baseTypeID().kind() == BaseType::Kind::INTERFACE){
					this->emit_error(
						Diagnostic::Code::SEMA_RETURN_TYPE_INTERFACE,
						ast_return_param.type,
						"Function return type cannot be an interface type"
					);
					return Result::ERROR;
				}
			}


			return_params.emplace_back(return_param_type_id);

			if(ast_return_param.ident.has_value()){
				return_param_idents.emplace_back(*ast_return_param.ident);
			}
		}


		auto error_return_params = evo::SmallVector<TypeInfo::VoidableID>();
		auto error_param_idents = evo::SmallVector<Token::ID>();
		for(size_t i = 0; const SymbolProc::TypeID& symbol_proc_error_return_param_type_id : instr.error_returns()){
			EVO_DEFER([&](){ i += 1; });

			const TypeInfo::VoidableID error_param_type_id = this->get_type(symbol_proc_error_return_param_type_id);

			const AST::FuncDef::Return& ast_error_return_param = instr.func_def.errorReturns[i];

			if(error_param_type_id.isVoid()){
				if(i == 0){
					if(ast_error_return_param.ident.has_value()){
						this->emit_error(
							Diagnostic::Code::SEMA_NAMED_VOID_RETURN,
							*ast_error_return_param.ident,
							"A function error return parameter that is type `Void` cannot be named"
						);
						return Result::ERROR;
					}
				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_NOT_FIRST_RETURN_VOID,
						ast_error_return_param.type,
						"Only the first function error return parameter can be type `Void`"
					);
					return Result::ERROR;
				}

			}else{
				const TypeInfo& error_param_type_info =
					this->context.getTypeManager().getTypeInfo(error_param_type_id.asTypeID());

				if(error_param_type_info.baseTypeID().kind() == BaseType::Kind::INTERFACE){
					this->emit_error(
						Diagnostic::Code::SEMA_RETURN_TYPE_INTERFACE,
						ast_error_return_param.type,
						"Function error return type cannot be an interface type"
					);
					return Result::ERROR;
				}
			}

			error_return_params.emplace_back(error_param_type_id);

			if(ast_error_return_param.ident.has_value()){
				error_param_idents.emplace_back(*ast_error_return_param.ident);
			}
		}



		///////////////////////////////////
		// create func

		const BaseType::ID created_func_base_type = this->context.type_manager.getOrCreateFunction(
			BaseType::Function(
				std::move(params),
				std::move(return_params),
				std::move(error_return_params),
				func_attrs.value().is_unsafe,
				!return_param_idents.empty(),
				!error_param_idents.empty()
			)
		);



		const sema::Func::ID created_func_id = this->context.sema_buffer.createFunc(
			this->source.getID(),
			instr.func_def.name,
			std::string(),
			this->scope.getCurrentEncapsulatingSymbolIfExists(),
			created_func_base_type.funcID(),
			std::move(sema_params),
			std::move(return_param_idents),
			std::move(error_param_idents),
			this->symbol_proc_id,
			min_num_args,
			has_in_param,
			sema::Func::Attributes{
				.isPub      = func_attrs.value().is_pub,
				.isPriv     = func_attrs.value().is_priv,
				.isComptime = !func_attrs.value().is_runtime,
				.isNoReturn = func_attrs.value().is_no_return,
				.isExport   = func_attrs.value().is_export,
				.isImplicit = func_attrs.value().is_implicit,
			},
			instr.instantiation_id
		);

		if(func_info.instantiation != nullptr){
			func_info.instantiation->funcID = created_func_id;

		}else if(
			this->symbol_proc.parent != nullptr
			&& this->symbol_proc.parent->extra_info.is<SymbolProc::InterfaceImplInfo>()
		){
			this->symbol_proc.parent->extra_info.as<SymbolProc::InterfaceImplInfo>().targets.emplace_back(
				TermInfo::ValueCategory::FUNCTION, TermInfo::FuncOverloadList{created_func_id}
			);

		}else if(func_attrs.value().is_entry){
			this->context.entry = created_func_id;

		}else if(
			this->symbol_proc.builtin_symbol_proc_kind == SymbolProcManager::constevalLookupBuiltinSymbolKind("panic")
		){
			this->context.panic = created_func_id;
		}


		sema::Func& created_func = this->context.sema_buffer.funcs[created_func_id];

		if constexpr(IS_INSTANTIATION == false){
			const Token& name_token = this->source.getTokenBuffer()[instr.func_def.name];

			switch(name_token.kind()){
				case Token::Kind::IDENT: {
					if(
						this->symbol_proc.parent == nullptr
						|| this->symbol_proc.parent->extra_info.is<SymbolProc::InterfaceImplInfo>() == false
					){ // add to scope if not inline-def interface impl method
						const std::string_view ident_str = name_token.getString();

						const bool include_shadow_checks = [&]() -> bool {
							if(this->scope.inEncapsulatingSymbol() == false){ return true; }

							const EncapsulatingSymbolID& current_encapsulating_symbol =
								this->scope.getCurrentEncapsulatingSymbol();

							return current_encapsulating_symbol.is<sema::Func::ID>();
						}();

						if(include_shadow_checks){
							if(this->add_ident_to_scope(
								ident_str, instr.func_def, true, created_func_id, this->context
							).isError()){
								return Result::ERROR;
							}
						}else{
							if(this->add_ident_to_scope(
								ident_str,
								instr.func_def,
								false,
								sema::ScopeLevel::MethodOverloadFlag{},
								created_func_id,
								this->context
							).isError()){
								return Result::ERROR;
							}
						}
					}
				} break;

				case Token::Kind::KEYWORD_AS: {
					if(this->scope.inEncapsulatingSymbol() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}


					if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}



					if(created_func.params.size() != 1){
						if(created_func.params.size() > 1){
							if(
								this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
								== Token::Kind::KEYWORD_THIS
							){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_AS_OVERLOAD,
									created_func.params[1].ident.as<Token::ID>(),
									"Operator [as] overload can only have a [this] parameter"
								);
							}else{
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_AS_OVERLOAD,
									created_func.params[0].ident.as<Token::ID>(),
									"Operator [as] overload can only have a [this] parameter"
								);
							}
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_AS_OVERLOAD,
								created_func_id,
								"Operator [as] overload must have a [this] parameter"
							);
						}

						return Result::ERROR;
					}

					if(
						this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
						!= Token::Kind::KEYWORD_THIS
					){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_AS_OVERLOAD,
							created_func.params[1].ident.as<Token::ID>(),
							"Operator [as] overload can only have a [this] parameter"
						);
						return Result::ERROR;
					}

					const BaseType::Function& created_func_type =
						this->context.getTypeManager().getFunction(created_func_base_type.funcID());

					if(created_func_type.returnTypes.size() != 1){
						const Diagnostic::Location location = [&]() -> Diagnostic::Location {
							if(created_func.hasNamedReturns()){
								return this->get_location(created_func.returnParamIdents[1]);
							}else{
								return this->get_location(created_func.name.as<Token::ID>());
							}
						}();

						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_AS_OVERLOAD,
							location,
							"Operator [as] overload can only have single return"
						);
						return Result::ERROR;
					}

					if(created_func_type.returnTypes[0].isVoid()){
						const Diagnostic::Location location = [&]() -> Diagnostic::Location {
							if(created_func.hasNamedReturns()){
								return this->get_location(created_func.returnParamIdents[0]);
							}else{
								return this->get_location(created_func.name.as<Token::ID>());
							}
						}();

						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_AS_OVERLOAD,
							location,
							"Operator [as] overload must return a value"
						);
						return Result::ERROR;
					}


					if(created_func_type.errorTypes.empty() == false){
						const Diagnostic::Location location = [&]() -> Diagnostic::Location {
							if(created_func.hasNamedErrors()){
								return this->get_location(created_func.errorParamIdents[0]);
							}else{
								return this->get_location(created_func.name.as<Token::ID>());
							}
						}();

						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_AS_OVERLOAD,
							location,
							"Operator [as] overload cannot error"
						);
						return Result::ERROR;
					}


					BaseType::Struct& current_struct = this->context.type_manager.getStruct(
						this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
					);

					const TypeInfo::ID conversion_type = created_func_type.returnTypes[0].asTypeID();

					const auto lock = std::scoped_lock(current_struct.operatorAsOverloadsLock);

					const auto find = current_struct.operatorAsOverloads.find(conversion_type);
					if(find != current_struct.operatorAsOverloads.end()){
						const Diagnostic::Location location = [&]() -> Diagnostic::Location {
							if(created_func.hasNamedReturns()){
								return this->get_location(created_func.returnParamIdents[0]);
							}else{
								return this->get_location(created_func.name.as<Token::ID>());
							}
						}();

						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_AS_OVERLOAD,
							location,
							"Operator [as] overload for this type already defined",
							Diagnostic::Info("Defined here:", this->get_location(find->second))
						);
						return Result::ERROR;
					}

					current_struct.operatorAsOverloads.emplace(conversion_type, created_func_id);
				} break;


				case Token::Kind::KEYWORD_NEW: {
					if(this->scope.inEncapsulatingSymbol() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					const BaseType::Function& created_func_type =
						this->context.getTypeManager().getFunction(created_func_base_type.funcID());

					BaseType::Struct& current_struct = this->context.type_manager.getStruct(
						this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
					);

					if(
						created_func.params.empty() == false
						&& this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
							== Token::Kind::KEYWORD_THIS
					){ // assignment
						if(created_func_type.returnsVoid() == false){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_NEW_OVERLOAD,
								instr.func_def,
								"Assignment operator `new` cannot have any return values"
							);
							return Result::ERROR;
						}

						if(created_func.attributes.isImplicit && created_func_type.params.size() != 2){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
								instr.func_def,
								"This function cannot have attribute #implicit"
							);
							return Result::ERROR;
						}

						{
							const auto lock = std::scoped_lock(current_struct.newAssignOverloadsLock);

							for(sema::Func::ID new_reassign_overload_id : current_struct.newAssignOverloads){
								const sema::Func& new_reassign_overload =
									this->context.getSemaBuffer().getFunc(new_reassign_overload_id);

								if(new_reassign_overload.isEquivalentOverload(created_func, this->context)){
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_NEW_OVERLOAD,
										instr.func_def,
										"Assignment operator [new] overload has an overload "
											"that collides with this declaration",
										Diagnostic::Info(
											"First defined here:", this->get_location(new_reassign_overload)
										)
									);
									return Result::ERROR;
								}
							}

							current_struct.newAssignOverloads.emplace_back(created_func_id);
						}

					}else{ // initialization
						const TypeInfo::ID expected_return_type = this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(
								BaseType::ID(this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>())
							)
						);

						if(
							created_func_type.returnTypes.size() != 1
							|| created_func_type.returnTypes[0] != expected_return_type
						){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_NEW_OVERLOAD,
								instr.func_def,
								"Initialization operator `new` must return the newly created value"
							);
							return Result::ERROR;
						}

						if(created_func_type.hasNamedReturns == false){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_NEW_OVERLOAD,
								instr.func_def,
								"Initialization operator `new` must have a named return"
							);
							return Result::ERROR;
						}

						if(created_func.attributes.isImplicit && created_func_type.params.size() != 1){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_ATTRIBUTE_USE,
								instr.func_def,
								"This function cannot have attribute #implicit"
							);
							return Result::ERROR;
						}

						{
							const auto lock = std::scoped_lock(current_struct.newInitOverloadsLock);

							for(sema::Func::ID new_init_overload_id : current_struct.newInitOverloads){
								const sema::Func& new_init_overload =
									this->context.getSemaBuffer().getFunc(new_init_overload_id);

								if(new_init_overload.isEquivalentOverload(created_func, this->context)){
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_NEW_OVERLOAD,
										instr.func_def,
										"Initialization operator [new] overload has an overload "
											"that collides with this declaration",
										Diagnostic::Info(
											"First defined here:", this->get_location(new_init_overload)
										)
									);
									return Result::ERROR;
								}
							}

							current_struct.newInitOverloads.emplace_back(created_func_id);
						}
					}
				} break;

				case Token::Kind::KEYWORD_DELETE: {
					if(this->scope.inEncapsulatingSymbol() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					const BaseType::Function& created_func_type =
						this->context.getTypeManager().getFunction(created_func_base_type.funcID());

					if(created_func_type.isUnsafe){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
							instr.func_def,
							"Operator [delete] cannot have the attribute `#unsafe`"
						);
						return Result::ERROR;
					}


					if(created_func.params.size() != 1){
						if(created_func.params.empty()){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
								instr.func_def,
								"Operator [delete] overload must have a [this] parameter"
							);
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
								instr.func_def.params[1],
								"Operator [delete] overload can only have a [this] parameter"
							);
						}
						return Result::ERROR;
					}

					if(
						this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
						!= Token::Kind::KEYWORD_THIS
					){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
							instr.func_def.params[0],
							"Operator [delete] can only have a [this] parameter"
						);
						return Result::ERROR;
					}



					BaseType::Struct& current_struct = this->context.type_manager.getStruct(
						this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
					);


					if(created_func_type.returnsVoid() == false){
						if(created_func.hasNamedReturns()){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
								created_func.returnParamIdents[0],
								"Operator [delete] overload must return `Void`"
							);
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
								instr.func_def.returns[0].type,
								"Operator [delete] overload must return `Void`"
							);
						}
						return Result::ERROR;
					}

					if(created_func_type.hasErrorReturn()){
						if(created_func.hasNamedErrors()){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
								created_func.errorParamIdents[0],
								"Operator [delete] cannot error"
							);
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
								instr.func_def.errorReturns[0].type,
								"Operator [delete] cannot error"
							);
						}
						return Result::ERROR;
					}


					auto expected = std::optional<sema::Func::ID>();
					if(current_struct.deleteOverload.compare_exchange_strong(expected, created_func_id) == false){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_DELETE_OVERLOAD,
							instr.func_def,
							"Operator [delete] was already defined for this type",
							Diagnostic::Info(
								"First defined here:",
								this->get_location(*current_struct.deleteOverload.load(std::memory_order::relaxed))
							)
						);
						return Result::ERROR;
					}
				} break;

				case Token::Kind::KEYWORD_COPY: {
					if(this->scope.inEncapsulatingSymbol() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					const BaseType::Function& created_func_type =
						this->context.getTypeManager().getFunction(created_func_base_type.funcID());

					BaseType::Struct& current_struct = this->context.type_manager.getStruct(
						this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
					);


					const TypeInfo::ID struct_type_info_id = this->context.type_manager.getOrCreateTypeInfo(
						TypeInfo(BaseType::ID(this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()))
					);


					switch(created_func.params.size()){
						case 0: {
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
								instr.func_def,
								"Operator [copy] overload must have a [this] parameter"
							);
							return Result::ERROR;
						} break;

						case 1: {
							if(
								this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
								!= Token::Kind::KEYWORD_THIS
							){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def.params[0],
									"Operator [copy] overload must have a [this] parameter"
								);
								return Result::ERROR;
							}

							if(created_func_type.params[0].kind == BaseType::Function::Param::Kind::IN){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def,
									"Operator [copy] initialization overload [this] parameter cannot be kind [in]"
								);
								return Result::ERROR;
							}

							if(created_func_type.returnTypes.size() != 1){
								if(created_func_type.returnTypes.empty()){
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
										instr.func_def,
										"Operator [copy] initialization overload must return the newly created value"
									);
								}else{
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
										instr.func_def.returns[1],
										"Operator [copy] initialization overload must return the newly created value"
									);
								}
								return Result::ERROR;
							}


							if(created_func_type.returnTypes[0] != struct_type_info_id){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def.returns[0].type,
									"Operator [copy] initialization overload must return `This` (or equivalent type)"
								);
								return Result::ERROR;
							}


							if(created_func_type.errorTypes.empty() == false){
								this->emit_error(
									Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
									instr.func_def.errorReturns[0],
									"Erroring operator [copy] is unimplemented"
								);
								return Result::ERROR;
							}

							auto expected = BaseType::Struct::DeletableOverload();
							if(current_struct.copyInitOverload.compare_exchange_strong(
								expected, BaseType::Struct::DeletableOverload(created_func_id)
							) == false){
								if(expected.wasDeleted()){
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
										instr.func_def,
										"Operator [copy] was already explicitly deleted"
									);

								}else{
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
										instr.func_def,
										"Operator [copy] initialization was already defined for this type",
										Diagnostic::Info(
											"First defined here:",
											this->get_location(
												*current_struct.copyInitOverload.load(std::memory_order::relaxed).funcID
											)
										)
									);
								}

								return Result::ERROR;
							}
						} break;

						case 2: {
							if(
								this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
								!= Token::Kind::KEYWORD_THIS
							){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def.params[0],
									"Operator [copy] overload must have a [this] parameter"
								);
								return Result::ERROR;
							}

							if(created_func_type.params[0].kind == BaseType::Function::Param::Kind::IN){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def,
									"Operator [copy] assignment overload [this] parameter cannot be kind [in]"
								);
								return Result::ERROR;
							}

							if(created_func_type.params[1].typeID != struct_type_info_id){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def.params[1],
									"Argument index 1 of operator [copy] assignment overload must be `This` "
										"(or equivalent type)"
								);
								return Result::ERROR;
							}

							if(created_func_type.returnsVoid() == false){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def.returns[0],
									"Operator [copy] assignment overload cannot return any values"
								);
								return Result::ERROR;
							}

							if(created_func_type.errorTypes.empty() == false){
								this->emit_error(
									Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
									instr.func_def.errorReturns[0],
									"Erroring operator [copy] is unimplemented"
								);
								return Result::ERROR;
							}

							auto expected = std::optional<sema::FuncID>();
							if(current_struct.copyAssignOverload.compare_exchange_strong(
								expected, created_func_id
							) == false){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def,
									"Operator [copy] assignment was already defined for this type",
									Diagnostic::Info(
										"First defined here:",
										this->get_location(
											*current_struct.copyAssignOverload.load(std::memory_order::relaxed)
										)
									)
								);
								return Result::ERROR;
							}

							if(current_struct.copyInitOverload.load(std::memory_order::relaxed).wasDeleted()){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
									instr.func_def,
									"Operator [copy] was already explicitly deleted"
								);
								return Result::ERROR;
							}
						} break;

						default: {
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
								instr.func_def.params[2],
								"Too many arguments for operator [copy] overload"
							);
							return Result::ERROR;
						} break;
					}
				} break;

				case Token::Kind::KEYWORD_MOVE: {
					if(this->scope.inEncapsulatingSymbol() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					const BaseType::Function& created_func_type =
						this->context.getTypeManager().getFunction(created_func_base_type.funcID());

					BaseType::Struct& current_struct = this->context.type_manager.getStruct(
						this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
					);


					const TypeInfo::ID struct_type_info_id = this->context.type_manager.getOrCreateTypeInfo(
						TypeInfo(BaseType::ID(this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()))
					);


					switch(created_func.params.size()){
						case 0: {
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
								instr.func_def,
								"Operator [move] overload must have a [this] parameter"
							);
							return Result::ERROR;
						} break;

						case 1: {
							if(
								this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
								!= Token::Kind::KEYWORD_THIS
							){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def.params[0],
									"Operator [move] overload must have a [this] parameter"
								);
								return Result::ERROR;
							}

							if(created_func_type.params[0].kind == BaseType::Function::Param::Kind::IN){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def,
									"Operator [move] initialization overload [this] parameter cannot be kind [in]"
								);
								return Result::ERROR;
							}

							if(created_func_type.returnTypes.size() != 1){
								if(created_func_type.returnTypes.empty()){
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
										instr.func_def,
										"Operator [move] initialization overload must return the newly created value"
									);
								}else{
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
										instr.func_def.returns[1],
										"Operator [move] initialization overload must return the newly created value"
									);
								}
								return Result::ERROR;
							}


							if(created_func_type.returnTypes[0] != struct_type_info_id){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def.returns[0].type,
									"Operator [move] initialization overload must return `This` (or equivalent type)"
								);
								return Result::ERROR;
							}


							if(created_func_type.errorTypes.empty() == false){
								this->emit_error(
									Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
									instr.func_def.errorReturns[0],
									"Erroring operator [move] is unimplemented"
								);
								return Result::ERROR;
							}

							auto expected = BaseType::Struct::DeletableOverload();
							if(current_struct.moveInitOverload.compare_exchange_strong(
								expected, BaseType::Struct::DeletableOverload(created_func_id)
							) == false){
								if(expected.wasDeleted()){
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
										instr.func_def,
										"Operator [move] was already explicitly deleted"
									);

								}else{
									this->emit_error(
										Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
										instr.func_def,
										"Operator [move] initialization was already defined for this type",
										Diagnostic::Info(
											"First defined here:",
											this->get_location(
												*current_struct.moveInitOverload.load(std::memory_order::relaxed).funcID
											)
										)
									);
								}

								return Result::ERROR;
							}
						} break;

						case 2: {
							if(
								this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
								!= Token::Kind::KEYWORD_THIS
							){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def.params[0],
									"Operator [move] assignment overload must have a [this] parameter"
								);
								return Result::ERROR;
							}

							if(created_func_type.params[0].kind == BaseType::Function::Param::Kind::IN){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def,
									"Operator [move] assignment overload [this] parameter cannot be kind [in]"
								);
								return Result::ERROR;
							}

							if(created_func_type.params[1].typeID != struct_type_info_id){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def.params[1],
									"Argument index 1 of operator [move] assignment overload must be `This` "
										"(or equivalent type)"
								);
								return Result::ERROR;
							}

							if(created_func_type.returnsVoid() == false){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def.returns[0],
									"Operator [move] assignment overload cannot return any values"
								);
								return Result::ERROR;
							}

							if(created_func_type.errorTypes.empty() == false){
								this->emit_error(
									Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
									instr.func_def.errorReturns[0],
									"Erroring operator [move] is unimplemented"
								);
								return Result::ERROR;
							}

							auto expected = std::optional<sema::FuncID>();
							if(current_struct.moveAssignOverload.compare_exchange_strong(
								expected, created_func_id
							) == false){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def,
									"Operator [move] assignment was already defined for this type",
									Diagnostic::Info(
										"First defined here:",
										this->get_location(
											*current_struct.moveAssignOverload.load(std::memory_order::relaxed)
										)
									)
								);
								return Result::ERROR;
							}

							if(current_struct.moveInitOverload.load(std::memory_order::relaxed).wasDeleted()){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
									instr.func_def,
									"Operator [move] was already explicitly deleted"
								);
								return Result::ERROR;
							}
						} break;

						default: {
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
								instr.func_def.params[2],
								"Too many arguments for operator [move] overload"
							);
							return Result::ERROR;
						} break;
					}
				} break;

				case Token::lookupKind("+"):    case Token::lookupKind("+%"):  case Token::lookupKind("+|"):
				case Token::lookupKind("-"):    case Token::lookupKind("-%"):  case Token::lookupKind("-|"):
				case Token::lookupKind("*"):    case Token::lookupKind("*%"):  case Token::lookupKind("*|"):
				case Token::lookupKind("/"):    case Token::lookupKind("%"):   case Token::lookupKind("=="):
				case Token::lookupKind("!="):   case Token::lookupKind("<"):   case Token::lookupKind("<="):
				case Token::lookupKind(">"):    case Token::lookupKind(">="):  case Token::lookupKind("&&"):
				case Token::lookupKind("||"):   case Token::lookupKind("<<"):  case Token::lookupKind("<<|"):
				case Token::lookupKind(">>"):   case Token::lookupKind("&"):   case Token::lookupKind("|"):
				case Token::lookupKind("^"):

				case Token::lookupKind("+="):   case Token::lookupKind("+%="): case Token::lookupKind("+|="):
				case Token::lookupKind("-="):   case Token::lookupKind("-%="): case Token::lookupKind("-|="):
				case Token::lookupKind("*="):   case Token::lookupKind("*%="): case Token::lookupKind("*|="):
				case Token::lookupKind("/="):   case Token::lookupKind("%="):  case Token::lookupKind("<<="):
				case Token::lookupKind("<<|="): case Token::lookupKind(">>="): case Token::lookupKind("&="):
				case Token::lookupKind("|="):   case Token::lookupKind("^="): {
					if(this->scope.inEncapsulatingSymbol() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					const BaseType::Function& created_func_type =
						this->context.getTypeManager().getFunction(created_func_base_type.funcID());

					BaseType::Struct& current_struct = this->context.type_manager.getStruct(
						this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
					);


					const TypeInfo::ID struct_type_info_id = this->context.type_manager.getOrCreateTypeInfo(
						TypeInfo(BaseType::ID(this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()))
					);


					if(created_func_type.params.size() != 2){
						if(created_func_type.params.size() == 0){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
								instr.func_def,
								"Infix operator overload doesn't have enough parameters"
							);
							return Result::ERROR;

						}else if(created_func_type.params.size() == 1){
							if(name_token.kind() == Token::lookupKind("-")){
								if(this->create_prefix_overload(
									created_func_type,
									current_struct,
									instr.func_def,
									created_func_id,
									created_func,
									func_attrs.value().is_commutative,
									func_attrs.value().is_swapped,
									name_token
								).isError()){
									return Result::ERROR;
								}

								break;
							}else{
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
									instr.func_def.params[0],
									"Infix operator overload doesn't have enough parameters"
								);
								return Result::ERROR;
							}
							
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
								instr.func_def.params[2],
								"Infix operator overload has too many parameters"
							);
							return Result::ERROR;
						}
					}

					if(
						this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
						!= Token::Kind::KEYWORD_THIS
					){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
							instr.func_def.params[0],
							"Infix operator overload must have a [this] parameter"
						);
						return Result::ERROR;
					}


					if(created_func_type.returnTypes.size() > 1){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
							instr.func_def.returns[1],
							"Infix operator overload cannot have multiple return values"
						);
						return Result::ERROR;
					}


					switch(name_token.kind()){
						case Token::lookupKind("+"):    case Token::lookupKind("+%"):   case Token::lookupKind("+|"):
						case Token::lookupKind("-"):    case Token::lookupKind("-%"):   case Token::lookupKind("-|"):
						case Token::lookupKind("*"):    case Token::lookupKind("*%"):   case Token::lookupKind("*|"):
						case Token::lookupKind("/"):    case Token::lookupKind("%"):    case Token::lookupKind("<<"):
						case Token::lookupKind("<<|"):  case Token::lookupKind(">>"):   case Token::lookupKind("&"):
						case Token::lookupKind("|"):    case Token::lookupKind("^"): {
							if(created_func_type.returnsVoid()){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
									instr.func_def.returns[0].type,
									std::format(
										"Infix [{}] overload must return a value", Token::printKind(name_token.kind())
									)
								);
								return Result::ERROR;
							}
						} break;

						case Token::lookupKind("=="): case Token::lookupKind("!="): case Token::lookupKind("<"):
						case Token::lookupKind("<="): case Token::lookupKind(">"):  case Token::lookupKind(">="):
						case Token::lookupKind("&&"): case Token::lookupKind("||"): {
							if(created_func_type.returnTypes[0] != TypeManager::getTypeBool()){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
									instr.func_def.returns[0].type,
									std::format(
										"Infix [{}] overload must return a `Bool`", Token::printKind(name_token.kind())
									)
								);
								return Result::ERROR;
							}
						} break;

						case Token::lookupKind("+="):   case Token::lookupKind("+%="): case Token::lookupKind("+|="):
						case Token::lookupKind("-="):   case Token::lookupKind("-%="): case Token::lookupKind("-|="):
						case Token::lookupKind("*="):   case Token::lookupKind("*%="): case Token::lookupKind("*|="):
						case Token::lookupKind("/="):   case Token::lookupKind("%="):  case Token::lookupKind("<<="):
						case Token::lookupKind("<<|="): case Token::lookupKind(">>="): case Token::lookupKind("&="):
						case Token::lookupKind("|="):   case Token::lookupKind("^="): {
							if(created_func_type.returnsVoid() == false){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
									instr.func_def.returns[0].type,
									std::format(
										"Infix [{}] overload cannot return a value", Token::printKind(name_token.kind())
									)
								);
								return Result::ERROR;
							}
						}
					}


					if(created_func_type.hasErrorReturn()){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
							instr.func_def.errorReturns[0],
							"Infix operator overload that error are unimplemented"
						);
						return Result::ERROR;
					}



					const auto add_overload = [&](BaseType::Struct& target_struct, bool swapped) -> evo::Result<> {
						const auto lock = std::scoped_lock(target_struct.infixOverloadsLock);

						const auto [begin_overloads_range, end_overloads_range] = 
							target_struct.infixOverloads.equal_range(name_token.kind());

						const sema::Func::ID overload_func_id_to_add = [&](){
							if(swapped){
								const BaseType::ID swapped_type_id = this->context.type_manager.getOrCreateFunction(
									BaseType::Function(
										evo::SmallVector<BaseType::Function::Param>{
											created_func_type.params[1], created_func_type.params[0]
										},
										evo::copy(created_func_type.returnTypes),
										evo::copy(created_func_type.errorTypes),
										created_func_type.isUnsafe,
										created_func_type.hasNamedReturns,
										created_func_type.hasNamedErrorReturns
									)
								);

								const sema::Func::ID created_swapped_func_id = this->context.sema_buffer.createFunc(
									this->source.getID(),
									created_func.name,
									std::string(),
									this->scope.getCurrentEncapsulatingSymbolIfExists(),
									swapped_type_id.funcID(),
									evo::SmallVector<sema::Func::Param>{created_func.params[1], created_func.params[0]},
									created_func.returnParamIdents,
									created_func.errorParamIdents,
									this->symbol_proc_id,
									2,
									created_func.hasInParam,
									sema::Func::Attributes{
										.isPub      = false,
										.isPriv     = false,
										.isComptime = created_func.attributes.isComptime,
										.isNoReturn = false,
										.isExport   = false,
										.isImplicit = false,
									}
								);

								sema::Func& created_swapped_func =
									this->context.sema_buffer.funcs[created_swapped_func_id];

								created_swapped_func.stmtBlock.emplace_back(
									this->context.sema_buffer.createReturn(
										sema::Expr(
											this->context.sema_buffer.createFuncCall(
												created_func_id,
												evo::SmallVector<sema::Expr>{
													sema::Expr(this->context.sema_buffer.createParam(1, 1)),
													sema::Expr(this->context.sema_buffer.createParam(0, 0))
												}
											)
										),
										std::nullopt
									)
								);

								created_swapped_func.isTerminated = true;
								created_swapped_func.status = sema::Func::Status::DEF_DONE;

								func_info.flipped_version = created_swapped_func_id;

								return created_swapped_func_id;
								
							}else{
								return created_func_id;
							}
						}();


						const sema::Func& overload_func_to_add =
							this->context.getSemaBuffer().getFunc(overload_func_id_to_add);


						const auto overloads_range = evo::IterRange(begin_overloads_range, end_overloads_range);
						for(const auto& [_, existing_func_id] : overloads_range){
							const sema::Func& existing_func =
								this->context.getSemaBuffer().getFunc(existing_func_id);
							
							if(overload_func_to_add.isEquivalentOverload(existing_func, this->context)){
								this->emit_error(
									Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
									instr.func_def,
									"This operator overload was already defined",
									Diagnostic::Info(
										"Previously defined here:", this->get_location(existing_func_id)
									)
								);
								return evo::resultError;
							}
						}

						target_struct.infixOverloads.emplace(name_token.kind(), overload_func_id_to_add);
						return evo::Result<>();
					};



					if(func_attrs.value().is_commutative){
						if(struct_type_info_id == created_func_type.params[1].typeID){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
								instr.func_def,
								"Infix operator overload where the LHS and RHS are the same type "
									"cannot have attribute #commutative"
							);
							return Result::ERROR;
						}


						// normal
						if(add_overload(current_struct, false).isError()){ return Result::ERROR; }

						// swapped
						if(struct_type_info_id != created_func_type.params[1].typeID){
							const TypeInfo& other_type = 
								this->context.getTypeManager().getTypeInfo(created_func_type.params[1].typeID);

							if(other_type.baseTypeID().kind() == BaseType::Kind::STRUCT){
								BaseType::Struct& other_struct =
									this->context.type_manager.getStruct(other_type.baseTypeID().structID());

								if(add_overload(other_struct, true).isError()){ return Result::ERROR; }

							}else{
								if(add_overload(current_struct, true).isError()){ return Result::ERROR; }
							}
						}

					}else if(func_attrs.value().is_swapped){
						if(struct_type_info_id == created_func_type.params[1].typeID){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_INFIX_OVERLOAD,
								instr.func_def,
								"Infix operator overload where the LHS and RHS are the same type "
									"cannot have attribute #swapped"
							);
							return Result::ERROR;
						}

						const TypeInfo& other_type = 
							this->context.getTypeManager().getTypeInfo(created_func_type.params[1].typeID);

						if(other_type.baseTypeID().kind() == BaseType::Kind::STRUCT){
							BaseType::Struct& other_struct =
								this->context.type_manager.getStruct(other_type.baseTypeID().structID());

							if(add_overload(other_struct, true).isError()){ return Result::ERROR; }

						}else{
							if(add_overload(current_struct, true).isError()){ return Result::ERROR; }
						}
						
					}else{
						if(add_overload(current_struct, false).isError()){ return Result::ERROR; }
					}
				} break;

				case Token::lookupKind("!"): case Token::lookupKind("~"): {
					if(this->scope.inEncapsulatingSymbol() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					const BaseType::Function& created_func_type =
						this->context.getTypeManager().getFunction(created_func_base_type.funcID());

					BaseType::Struct& current_struct = this->context.type_manager.getStruct(
						this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
					);


					if(this->create_prefix_overload(
						created_func_type,
						current_struct,
						instr.func_def,
						created_func_id,
						created_func,
						func_attrs.value().is_commutative,
						func_attrs.value().is_swapped,
						name_token
					).isError()){
						return Result::ERROR;
					}
				} break;

				case Token::lookupKind("["): {
					if(this->scope.inEncapsulatingSymbol() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
							instr.func_def,
							"Operator overload cannot be a free function"
						);
						return Result::ERROR;
					}

					const BaseType::Function& created_func_type =
						this->context.getTypeManager().getFunction(created_func_base_type.funcID());

					BaseType::Struct& current_struct = this->context.type_manager.getStruct(
						this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
					);

					if(created_func_type.params.size() < 2){
						if(created_func_type.params.empty()){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_INDEXER_OVERLOAD,
								instr.func_def,
								"Operator indexer overload must have a `this` parameter"
							);
							return Result::ERROR;
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_INDEXER_OVERLOAD,
								instr.func_def,
								"Operator indexer overload must have at least 1 index parameter"
							);
							return Result::ERROR;
						}
					}

					if(
						this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
						!= Token::Kind::KEYWORD_THIS
					){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_INDEXER_OVERLOAD,
							instr.func_def.params[0],
							"Indexer operator overload must have a [this] parameter"
						);
						return Result::ERROR;
					}


					if(created_func_type.returnsVoid()){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_INDEXER_OVERLOAD,
							instr.func_def.returns[0].type,
							"Indexer operator overload must return a value"
						);
						return Result::ERROR;
					}


					if(created_func_type.hasErrorReturn()){
						this->emit_error(
							Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
							instr.func_def,
							"erroring indexer overload is unimplemented"
						);
						return Result::ERROR;
					}


					//////////////////
					// create

					const auto lock = std::scoped_lock(current_struct.indexerOverloadsLock);

					for(const sema::Func::ID existing_func_id : current_struct.indexerOverloads){
						const sema::Func& existing_func =
							this->context.getSemaBuffer().getFunc(existing_func_id);
						
						if(created_func.isEquivalentOverload(existing_func, this->context)){
							this->emit_error(
								Diagnostic::Code::SEMA_INVALID_OPERATOR_INDEXER_OVERLOAD,
								instr.func_def,
								"This operator overload was already defined",
								Diagnostic::Info(
									"Previously defined here:", this->get_location(existing_func_id)
								)
							);
							return Result::ERROR;
						}
					}

					current_struct.indexerOverloads.emplace_back(created_func_id);
				} break;
			}
		}


		this->push_scope_level(&created_func.stmtBlock, created_func_id);


		///////////////////////////////////
		// done

		this->propagate_finished_decl();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_func_pre_body(const Instruction::FuncPreBody& instr) -> Result {
		const sema::Func::ID current_func_id = this->scope.getCurrentEncapsulatingSymbol().as<sema::Func::ID>();
		sema::Func& current_func = this->context.sema_buffer.funcs[current_func_id];

		BaseType::Function& func_type = this->context.type_manager.getFunction(current_func.typeID);
		const SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();



		//////////////////
		// check valid interface method default impl

		if(
			this->symbol_proc.parent == nullptr
			|| this->symbol_proc.parent->extra_info.is<SymbolProc::InterfaceImplInfo>() == false
		){
			if(
				this->scope.getCurrentInterfaceSymbolIfExists().has_value() && current_func.isMethod(this->context)
			){
				this->emit_error(
					Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
					instr.func_def,
					"Interface methods with [this] parameter with default implementation are unimplemented"
				);
				return Result::ERROR;
			}
		}



		//////////////////
		// check valid in parameter

		for(size_t i = 0; const BaseType::Function::Param& param : func_type.params){
			if(
				param.kind == BaseType::Function::Param::Kind::IN
				&& this->context.getTypeManager().isCopyable(param.typeID) == false
				&& this->context.getTypeManager().isMovable(param.typeID) == false
			){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_special_member_fail<SpecialMemberFailKind::COPY>(param.typeID, infos);
				this->diagnostic_print_special_member_fail<SpecialMemberFailKind::MOVE>(param.typeID, infos);
				this->emit_error(
					Diagnostic::Code::SEMA_IN_PARAM_NOT_COPYABLE_OR_MOVABLE,
					*instr.func_def.params[i].type,
					"Function [in] parameter type must be copyable and/or movable",
					std::move(infos)
				);
				return Result::ERROR;
			}

			i += 1;
		}


		//////////////////
		// check param is copy

		for(size_t i = 0; const std::optional<TypeInfo::ID>& type_id : func_info.param_type_to_check_if_is_copy){
			EVO_DEFER([&](){ i += 1; });

			if(type_id.has_value() == false){ continue; }

			if(
				this->context.getTypeManager().isTriviallyCopyable(*type_id)
				&& this->context.getTypeManager().isTriviallySized(*type_id)
			){
				func_type.params[i].shouldCopy = true;
			}
		}


		if(func_info.flipped_version.has_value()){
			const sema::Func& flipped_version = this->context.getSemaBuffer().getFunc(*func_info.flipped_version);
			BaseType::Function& flipped_version_type = this->context.type_manager.getFunction(flipped_version.typeID);

			for(size_t i = 0; i < func_type.params.size(); i+=1){
				flipped_version_type.params[func_type.params.size()-i-1].shouldCopy = func_type.params[i].shouldCopy;
			}
		}



		//////////////////
		// check special functions have correct signature

		if(this->context.entry == current_func_id){
			if(func_type.params.empty() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ENTRY,
					current_func.params[0].ident.as<Token::ID>(),
					"Functions with the [#entry] attribute cannot have parameters"
				);
				return Result::ERROR;
			}

			if(instr.func_def.returns[0].ident.has_value()){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ENTRY,
					instr.func_def.returns[0],
					"Functions with the [#entry] attribute cannot have named returns"
				);
				return Result::ERROR;
			}

			if(
				func_type.returnTypes[0].isVoid() ||
				this->context.type_manager.decayType<false, false>(func_type.returnTypes[0].asTypeID())
					!= TypeManager::getTypeUI8()
			){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(func_type.returnTypes[0].asTypeID(), infos, "Returned type: ");
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ENTRY,
					instr.func_def.returns[0].type,
					"Functions with the [#entry] attribute must return [UI8]",
					std::move(infos)
				);
				return Result::ERROR;
			}

			if(func_type.errorTypes.empty() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ENTRY,
					instr.func_def.errorReturns[0],
					"Functions with the [#entry] attribute cannot have error returns"
				);
				return Result::ERROR;
			}

			if(func_type.isUnsafe){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ENTRY,
					instr.func_def,
					"Functions with the `#entry` attribute cannot have the attribute `#unsafe`"
				);
				return Result::ERROR;
			}


		}else if(this->context.panic == current_func_id){
			if(func_type.params.size() != 1){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_PANIC,
					instr.func_def,
					"Builtin panic function requires 1 parameter"
				);
				return Result::ERROR;
			}

			if(
				func_type.params[0] !=
				BaseType::Function::Param(TypeManager::getTypeStringRef(), BaseType::Function::Param::Kind::READ, false)
			){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_PANIC,
					instr.func_def,
					"Builtin panic function invaid parameter"
				);
				return Result::ERROR;
			}

			if(func_type.returnsVoid() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_PANIC,
					instr.func_def,
					"Builtin panic function must return `Void`"
				);
				return Result::ERROR;	
			}

			if(func_type.hasErrorReturn()){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_PANIC,
					instr.func_def,
					"Builtin panic function cannot have error returns"
				);
				return Result::ERROR;
			}

			if(func_type.isUnsafe){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_PANIC,
					instr.func_def,
					"Builtin panic function cannot be unsafe"
				);
				return Result::ERROR;
			}

			if(current_func.attributes.isComptime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_PANIC,
					instr.func_def,
					"Builtin panic function must be comptime"
				);
				return Result::ERROR;
			}

			if(current_func.attributes.isNoReturn == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_PANIC,
					instr.func_def,
					"Builtin panic function must have attribute `#noReturn`"
				);
				return Result::ERROR;
			}
		}


		//////////////////
		// check noReturn has valid signature

		if(current_func.attributes.isNoReturn){
			if(func_type.returnsVoid() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_NO_RETURN,
					instr.func_def,
					"Functions with the `#noReturn` attribute must return `Void`"
				);
				return Result::ERROR;
			}

			if(func_type.hasErrorReturn()){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_NO_RETURN,
					instr.func_def,
					"Functions with the `#noReturn` attribute cannot have error returns"
				);
				return Result::ERROR;
			}

			if(this->source.getTokenBuffer()[instr.func_def.name].kind() != Token::Kind::IDENT){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_NO_RETURN,
					instr.func_def,
					"Operator overloads cannot have attribute `#noReturn`"
				);
				return Result::ERROR;
			}
		}


		//////////////////
		// prepare pir

		if(current_func.attributes.isComptime){
			auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);

			current_func.comptimeJITFunc = sema_to_pir.lowerFuncDeclComptime(current_func_id);


			if(func_info.flipped_version.has_value()){
				sema::Func& flipped_version = this->context.sema_buffer.funcs[*func_info.flipped_version];

				flipped_version.comptimeJITFunc = sema_to_pir.lowerFuncDeclComptime(*func_info.flipped_version);
			}

			this->propagate_finished_pir_decl();
		}


		//////////////////
		// setup scope

		if(func_type.isUnsafe){
			this->get_current_scope_level().setIsUnsafe();
		}


		//////////////////
		// adding params to scope

		uint32_t abi_index = 0;

		for(uint32_t i = 0; const AST::FuncDef::Param& param : instr.func_def.params){
			EVO_DEFER([&](){
				abi_index += 1;
				i += 1;
			});

			if(param.name.kind() == AST::Kind::THIS){
				this->scope.addThisParam(this->context.sema_buffer.createParam(i, abi_index));
				continue;
			}


			const std::string_view param_name = this->source.getTokenBuffer()[
				this->source.getASTBuffer().getIdent(param.name)
			].getString();


			if(instr.func_def.isVariadic && i + 1 == instr.func_def.params.size()){
				const uint32_t num_variadics = uint32_t(current_func.params.size() - instr.func_def.params.size() + 1);

				if(this->add_ident_to_scope(
					param_name, param, true, this->context.sema_buffer.createVariadicParam(i, abi_index, num_variadics)
				).isError()){
					return Result::ERROR;
				}

				for(uint32_t j = 0; j < num_variadics; j+=1){
					const sema::Param::ID actual_variadic_param_id =
						this->context.sema_buffer.createParam(i + j, abi_index + j);

					this->add_ident_value_state(
						actual_variadic_param_id, sema::ScopeLevel::ValueState::INIT
					);

					this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().actual_variadic_params.emplace_back(
						actual_variadic_param_id
					);
				}

				abi_index += num_variadics - 1;

			}else{
				const sema::Param::ID sema_param_id = this->context.sema_buffer.createParam(i, abi_index);
				if(this->add_ident_to_scope(param_name, param, true, sema_param_id).isError()){ return Result::ERROR; }
				this->add_ident_value_state(sema_param_id, sema::ScopeLevel::ValueState::INIT);
			}
		}


		if(func_type.hasNamedReturns){
			for(uint32_t i = 0; const AST::FuncDef::Return& return_param : instr.func_def.returns){
				EVO_DEFER([&](){ i += 1; });

				const std::string_view return_param_name =
					this->source.getTokenBuffer()[*return_param.ident].getString();

				const sema::ReturnParam::ID created_return_param_id =
					this->context.sema_buffer.createReturnParam(i, abi_index);

				if(this->add_ident_to_scope(return_param_name, return_param, true, created_return_param_id).isError()){
					return Result::ERROR;
				}

				switch(this->source.getTokenBuffer()[current_func.name.as<Token::ID>()].kind()){
					case Token::Kind::KEYWORD_NEW: case Token::Kind::KEYWORD_COPY: case Token::Kind::KEYWORD_MOVE: {
						const TypeInfo& return_type = 
							this->context.getTypeManager().getTypeInfo(func_type.returnTypes[i].asTypeID());
						const BaseType::Struct& return_struct_type =
							this->context.getTypeManager().getStruct(return_type.baseTypeID().structID());

						if(return_struct_type.memberVars.empty()) [[unlikely]] {
							// mark the output param already initialized if has no members
							this->add_ident_value_state(
								created_return_param_id, sema::ScopeLevel::ValueState::INIT
							);
							
						}else{
							this->add_ident_value_state(
								created_return_param_id, sema::ScopeLevel::ValueState::INITIALIZING
							);

							for(uint32_t j = 0; j < return_struct_type.memberVars.size(); j+=1){
								this->add_ident_value_state(
									sema::ReturnParamAccessorValueStateID(created_return_param_id, j),
									sema::ScopeLevel::ValueState::UNINIT
								);
							}

							SymbolProc::FuncInfo& func_info_mut =
								this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();
							func_info_mut.num_members_of_initializing_are_uninit = return_struct_type.memberVars.size();
						}

					} break;

					default: {
						this->add_ident_value_state(
							created_return_param_id, sema::ScopeLevel::ValueState::UNINIT
						);
					} break;
				}

				abi_index += 1;
			}
		}else{
			if(this->source.getTokenBuffer()[current_func.name.as<Token::ID>()].kind() == Token::Kind::KEYWORD_DELETE){
				const TypeInfo& this_type = this->context.getTypeManager().getTypeInfo(func_type.params[0].typeID);
				const BaseType::Struct& this_struct_type =
					this->context.getTypeManager().getStruct(this_type.baseTypeID().structID());

				for(uint32_t i = 0; i < this_struct_type.memberVarsABI.size(); i+=1){
					this->add_ident_value_state(
						sema::OpDeleteThisAccessorValueStateID(i), sema::ScopeLevel::ValueState::INIT
					);
				}
			}
		}


		if(func_type.hasNamedErrorReturns){
			// account for the RET param
			if(func_type.returnsVoid() == false && func_type.hasNamedReturns == false){
				abi_index += 1;
			}
			
			for(uint32_t i = 0; const AST::FuncDef::Return& error_return_param : instr.func_def.errorReturns){
				EVO_DEFER([&](){ i += 1; });

				const sema::ErrorReturnParam::ID created_error_return_param_id =
					this->context.sema_buffer.createErrorReturnParam(i, abi_index);

				if(this->add_ident_to_scope(
					this->source.getTokenBuffer()[*error_return_param.ident].getString(),
					error_return_param,
					true, 
					created_error_return_param_id
				).isError()){
					return Result::ERROR;
				}

				this->add_ident_value_state(
					created_error_return_param_id, sema::ScopeLevel::ValueState::UNINIT
				);
			}
		}

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_func_def(const Instruction::FuncDef& instr) -> Result {
		const sema::Func::ID current_func_id = this->scope.getCurrentEncapsulatingSymbol().as<sema::Func::ID>();
		sema::Func& current_func = this->context.sema_buffer.funcs[current_func_id];
		const BaseType::Function& func_type = this->context.getTypeManager().getFunction(current_func.typeID);


		if(this->get_current_scope_level().isTerminated()){
			current_func.isTerminated = true;

		}else{
			if(func_type.returnsVoid() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ISNT_TERMINATED,
					instr.func_def,
					"Function isn't terminated",
					Diagnostic::Info(
						"A function that doesn't return `Void` is terminated when all control paths end in a "
						"[return], [error], [unreachable], or a function call that has the attribute [#noReturn]"
					)
				);
				return Result::ERROR;
			}
		}


		{ // add to interface method if it's a default method
			const std::optional<EncapsulatingSymbolID> current_interface_symbol = 
				this->scope.getCurrentInterfaceSymbolIfExists();

			if(
				current_interface_symbol.has_value()
				&&  (
						this->symbol_proc.parent == nullptr
						|| this->symbol_proc.parent->extra_info.is<SymbolProc::InterfaceImplInfo>() == false
					)
			){
				BaseType::Interface& current_interface = this->context.type_manager.getInterface(
					current_interface_symbol->as<BaseType::Interface::ID>()
				);
				current_interface.methods.emplace_back(
					this->scope.getCurrentEncapsulatingSymbol().as<sema::Func::ID>()
				);
			}
		}


		current_func.status = sema::Func::Status::DEF_DONE;
		this->propagate_finished_def();


		if(current_func.attributes.isComptime){
			bool any_waiting = false;
			const SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();
			for(sema::Func::ID dependent_func_id : func_info.dependent_funcs){
				if(dependent_func_id == current_func_id){ continue; }

				const sema::Func& dependent_func = this->context.getSemaBuffer().getFunc(dependent_func_id);

				if(dependent_func.symbolProcID.has_value() == false){ continue; }

				SymbolProc& dependent_func_symbol_proc = 
					this->context.symbol_proc_manager.getSymbolProc(*dependent_func.symbolProcID);

				const SymbolProc::WaitOnResult wait_on_result = dependent_func_symbol_proc.waitOnPIRDeclIfNeeded(
					this->symbol_proc_id, this->context, *dependent_func.symbolProcID
				);

				switch(wait_on_result){
					case SymbolProc::WaitOnResult::NOT_NEEDED:
						break;

					case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
						this->context.symbol_proc_manager.symbol_proc_unsuspended();
						this->context.add_task_to_work_manager(*dependent_func.symbolProcID);
						[[fallthrough]];
					}

					case SymbolProc::WaitOnResult::WAITING:
						any_waiting = true; break;

					case SymbolProc::WaitOnResult::WAS_ERRORED:
						return Result::ERROR;

					case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:
						evo::debugFatalBreak("Shouldn't be possible");

					case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:
						evo::debugFatalBreak("Shouldn't be possible");
				}
			}


			if(any_waiting){
				if(this->symbol_proc.shouldContinueRunning()){
					return Result::SUCCESS;
				}else{
					return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
				}

			}else{
				return Result::SUCCESS;
			}
		}

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_func_prepare_comptime_pir_if_needed(
		const Instruction::FuncPrepareComptimePIRIfNeeded& instr [[maybe_unused]]
	) -> Result {
		const sema::Func& current_func = this->get_current_func();

		if(current_func.attributes.isComptime){
			const sema::Func::ID sema_func_id = this->scope.getCurrentEncapsulatingSymbol().as<sema::Func::ID>();

			{
				auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);

				
				sema_to_pir.lowerFuncDef(sema_func_id);


				///////////////////////////////////
				// The following code commented code is for lowering directly to JIT
				// I'm purposely keeping this here (at least for now)

				// const BaseType::Function& func_type = this->context.getTypeManager().getFunction(current_func.typeID);
				// sema::Func& sema_func = this->context.sema_buffer.funcs[sema_func_id];

				// const SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();

				// auto module_subset_funcs = evo::StaticVector<pir::Function::ID, 4>();
				// module_subset_funcs.emplace_back(*sema_func.comptimeJITFunc);


				// // create jit interface if needed
				// if(func_type.returnsVoid() == false && func_type.returnTypes.size() == 1){
				// 	sema_func.comptimeJITInterfaceFunc = sema_to_pir.createFuncJITInterface(
				// 		sema_func_id, *sema_func.comptimeJITFunc
				// 	);
				// 	module_subset_funcs.emplace_back(*sema_func.comptimeJITInterfaceFunc);


				// 	if(func_info.flipped_version.has_value()){
				// 		sema::Func& flipped_version = this->context.sema_buffer.funcs[*func_info.flipped_version];

				// 		sema_to_pir.lowerFuncDef(*func_info.flipped_version);
				// 		module_subset_funcs.emplace_back(*flipped_version.comptimeJITFunc);

				// 		flipped_version.comptimeJITInterfaceFunc = sema_to_pir.createFuncJITInterface(
				// 			*func_info.flipped_version, *flipped_version.comptimeJITFunc
				// 		);
				// 		module_subset_funcs.emplace_back(*flipped_version.comptimeJITInterfaceFunc);
				// 	}
				// }


				// const evo::Expected<void, evo::SmallVector<std::string>> add_module_subset_result = 
				// 	this->context.comptime_jit_engine.addModuleSubsetWithWeakDependencies(
				// 		this->context.pir_module,
				// 		pir::JITEngine::ModuleSubsets{ .funcs = module_subset_funcs, }
				// 	);

				// if(add_module_subset_result.has_value() == false){
				// 	auto infos = evo::SmallVector<Diagnostic::Info>();
				// 	for(const std::string& error : add_module_subset_result.error()){
				// 		infos.emplace_back(std::format("Message from LLVM: \"{}\"", error));
				// 	}

				// 	this->emit_fatal(
				// 		Diagnostic::Code::MISC_LLVM_ERROR,
				// 		instr.func_def,
				// 		Diagnostic::createFatalMessage("Failed to setup PIR JIT interface for comptime function"),
				// 		std::move(infos)
				// 	);
				// 	return Result::ERROR;
				// }
			}



			bool any_waiting = false;
			for(
				sema::Func::ID dependent_func_id
				: this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs
			){
				if(dependent_func_id == sema_func_id){ continue; }

				const sema::Func& dependent_func = this->context.getSemaBuffer().getFunc(dependent_func_id);

				if(dependent_func.symbolProcID.has_value() == false){ continue; }

				SymbolProc& dependent_func_symbol_proc = 
					this->context.symbol_proc_manager.getSymbolProc(*dependent_func.symbolProcID);

				const SymbolProc::WaitOnResult wait_on_result = dependent_func_symbol_proc.waitOnPIRDefIfNeeded(
					this->symbol_proc_id, this->context, *dependent_func.symbolProcID
				);

				switch(wait_on_result){
					case SymbolProc::WaitOnResult::NOT_NEEDED:
						break;

					case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
						this->context.symbol_proc_manager.symbol_proc_unsuspended();
						this->context.add_task_to_work_manager(*dependent_func.symbolProcID);
						[[fallthrough]];
					}

					case SymbolProc::WaitOnResult::WAITING:
						any_waiting = true; break;

					case SymbolProc::WaitOnResult::WAS_ERRORED:
						return Result::ERROR;

					case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:
						evo::debugFatalBreak("Shouldn't be possible");

					case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:
						evo::debugFatalBreak("Shouldn't be possible");
				}
			}
			for(
				sema::GlobalVar::ID dependent_var_id
				: this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_vars
			){
				const sema::GlobalVar& dependent_var = this->context.sema_buffer.getGlobalVar(dependent_var_id);
				SymbolProc& dependent_var_symbol_proc =
					this->context.symbol_proc_manager.getSymbolProc(*dependent_var.symbolProcID);

				const SymbolProc::WaitOnResult wait_on_result = dependent_var_symbol_proc.waitOnDefIfNeeded(
					this->symbol_proc_id, this->context, *dependent_var.symbolProcID
				);

				switch(wait_on_result){
					case SymbolProc::WaitOnResult::NOT_NEEDED:
						break;

					case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
						this->context.symbol_proc_manager.symbol_proc_unsuspended();
						this->context.add_task_to_work_manager(*dependent_var.symbolProcID);
						[[fallthrough]];
					}

					case SymbolProc::WaitOnResult::WAITING:
						any_waiting = true; break;

					case SymbolProc::WaitOnResult::WAS_ERRORED:
						return Result::ERROR;

					case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:
						evo::debugFatalBreak("Shouldn't be possible");

					case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:
						evo::debugFatalBreak("Shouldn't be possible");
				}
			}

			if(any_waiting){
				if(this->symbol_proc.shouldContinueRunning()){
					return Result::SUCCESS;
				}else{
					return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
				}

			}else{
				return Result::SUCCESS;
			}
		}

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_func_comptime_pir_ready_if_needed() -> Result {
		const sema::Func& current_func = this->get_current_func();

		if(current_func.attributes.isComptime){
			this->propagate_finished_pir_def();
		}

		if(this->pop_scope_level<PopScopeLevelKind::SYMBOL_END>().isError()){ return Result::ERROR; }

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_template_func_begin(const Instruction::TemplateFuncBegin& instr) -> Result {
		{
			const Token::Kind name_token_kind = this->source.getTokenBuffer()[instr.func_def.name].kind();

			if(name_token_kind != Token::Kind::IDENT){
				if(instr.func_def.templatePack.has_value()){
					this->emit_error(
						Diagnostic::Code::SEMA_TEMPLATED_OPERATOR_OVERLOAD,
						instr.func_def.name,
						"Operator overload cannot have a template parameter pack"
					);
					return Result::ERROR;

				}else if(name_token_kind != Token::Kind::KEYWORD_NEW){
					this->emit_error(
						Diagnostic::Code::SEMA_TEMPLATED_OPERATOR_OVERLOAD,
						instr.func_def.name,
						"This operator overload cannot be template"
					);
					return Result::ERROR;
				}
			}
		}
		

		size_t minimum_num_template_args = 0;
		auto template_params = evo::SmallVector<sema::TemplatedFunc::TemplateParam>();

		for(const SymbolProc::Instruction::TemplateParamInfo& template_param_info : instr.template_param_infos){
			auto type_id = std::optional<TypeInfo::ID>();
			if(template_param_info.type_id.has_value()){
				const TypeInfo::VoidableID type_info_voidable_id = this->get_type(*template_param_info.type_id);
				if(type_info_voidable_id.isVoid()){
					this->emit_error(
						Diagnostic::Code::SEMA_TEMPLATE_PARAM_CANNOT_BE_TYPE_VOID,
						template_param_info.param.type,
						"Template parameter cannot be type `Void`"
					);
					return Result::ERROR;
				}
				type_id = type_info_voidable_id.asTypeID();
			}

			TermInfo* default_value = nullptr;
			if(template_param_info.default_value.has_value()){
				default_value = &this->get_term_info(*template_param_info.default_value);

				if(type_id.has_value()){
					if(default_value->isSingleValue() == false){
						if(default_value->isMultiValue()){
							this->emit_error(
								Diagnostic::Code::SEMA_TEMPLATE_PARAM_EXPR_DEFAULT_MUST_BE_EXPR,
								*template_param_info.param.defaultValue,
								"Default of an expression template parameter must be a single expression"
							);	
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_TEMPLATE_PARAM_EXPR_DEFAULT_MUST_BE_EXPR,
								*template_param_info.param.defaultValue,
								"Default of an expression template parameter must be an expression"
							);
						}
						return Result::ERROR;
					}

					const TypeCheckInfo type_check_info = this->type_check<true, true>(
						*type_id,
						*default_value,
						"Default value of template parameter",
						*template_param_info.param.defaultValue
					);
					if(type_check_info.ok == false){
						return Result::ERROR;
					}

				}else{
					if(default_value->value_category != TermInfo::ValueCategory::TYPE){
						this->emit_error(
							Diagnostic::Code::SEMA_TEMPLATE_PARAM_TYPE_DEFAULT_MUST_BE_TYPE,
							*template_param_info.param.defaultValue,
							"Default of a [Type] template parameter must be an type"
						);
						return Result::ERROR;
					}
				}
			}else{
				minimum_num_template_args += 1;
			}

			if(default_value == nullptr){
				template_params.emplace_back(type_id, std::monostate());

			}else if(default_value->value_category == TermInfo::ValueCategory::TYPE){
				template_params.emplace_back(type_id, default_value->type_id.as<TypeInfo::VoidableID>());

			}else{
				template_params.emplace_back(type_id, default_value->getExpr());
			}
		}


		const sema::TemplatedFunc::ID new_templated_func_id = this->context.sema_buffer.createTemplatedFunc(
			this->symbol_proc,
			minimum_num_template_args,
			std::move(template_params),
			evo::SmallVector<bool>(instr.func_def.params.size(), false),
			instr.func_def.isVariadic
		);

		this->symbol_proc.extra_info.emplace<SymbolProc::TemplateFuncInfo>(
			new_templated_func_id, this->context.sema_buffer.templated_funcs[new_templated_func_id]
		);

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_template_set_param_is_deducer(
		const Instruction::TemplateFuncSetParamIsDeducer& instr
	) -> Result {
		SymbolProc::TemplateFuncInfo& template_func_info = 
			this->symbol_proc.extra_info.as<SymbolProc::TemplateFuncInfo>();
		template_func_info.templated_func.paramIsDeducer[instr.param_index] = true;

		return Result::SUCCESS;
	}

	
	auto SemanticAnalyzer::instr_template_func_end(const Instruction::TemplateFuncEnd& instr) -> Result {
		const Token& name_token = this->source.getTokenBuffer()[instr.func_def.name];

		if(name_token.kind() == Token::Kind::IDENT){
			const std::string_view ident_str = name_token.getString();
			const sema::TemplatedFunc::ID templated_func_id =
				this->symbol_proc.extra_info.as<SymbolProc::TemplateFuncInfo>().templated_func_id;


			const bool include_shadow_checks = [&]() -> bool {
				if(this->scope.inEncapsulatingSymbol() == false){ return true; }

				const EncapsulatingSymbolID& current_encapsulating_symbol =
					this->scope.getCurrentEncapsulatingSymbol();

				return current_encapsulating_symbol.is<sema::Func::ID>();
			}();

			if(include_shadow_checks){
				if(this->add_ident_to_scope(ident_str, instr.func_def, true, templated_func_id).isError()){
					return Result::ERROR;
				}
			}else{
				if(this->add_ident_to_scope(
					ident_str,
					instr.func_def,
					false,
					sema::ScopeLevel::MethodOverloadFlag{},
					templated_func_id
				).isError()){
					return Result::ERROR;
				}
			}


			this->propagate_finished_decl_def();

			return Result::SUCCESS;

		}else{
			evo::debugAssert(name_token.kind() == Token::Kind::KEYWORD_NEW);
			
			this->emit_error(
				Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
				instr.func_def.name,
				"This operator overload being a template is unimplemented"
			);
			return Result::ERROR;
		}

	}



	auto SemanticAnalyzer::instr_deleted_special_method(const Instruction::DeletedSpecialMethod& instr) -> Result {
		if(this->scope.inEncapsulatingSymbol() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
				instr.deleted_special_method,
				"Operator overload cannot be a free function"
			);
			return Result::ERROR;
		}

		if(this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_OPERATOR_OVERLOAD_NOT_IN_TYPE,
				instr.deleted_special_method,
				"Operator overload cannot be a free function"
			);
			return Result::ERROR;
		}

		BaseType::Struct& current_struct = this->context.type_manager.getStruct(
			this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()
		);

		const Token::Kind deleted_kind = this->source.getTokenBuffer()[instr.deleted_special_method.memberToken].kind();


		switch(deleted_kind){
			case Token::Kind::KEYWORD_COPY: {
				auto init_expected = BaseType::Struct::DeletableOverload();
				if(current_struct.copyInitOverload.compare_exchange_strong(
					init_expected,
					BaseType::Struct::DeletableOverload(BaseType::Struct::DeletableOverload::State::EXPLICITLY_DELETED)
				) == false){
					if(init_expected.wasDeleted()){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
							instr.deleted_special_method,
							"Operator overload [copy] was already explicitly deleted"
						);
					}else{
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
							*init_expected.funcID,
							"Operator overload [copy] was already explicitly deleted"
						);
					}
					return Result::ERROR;
				}

				if(current_struct.copyAssignOverload.load(std::memory_order::relaxed).has_value()){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_OPERATOR_COPY_OVERLOAD,
						*current_struct.copyAssignOverload.load(std::memory_order::relaxed),
						"Operator overload [copy] was explicitly deleted"
					);
					return Result::ERROR;
				}
			} break;

			case Token::Kind::KEYWORD_MOVE: {
				auto init_expected = BaseType::Struct::DeletableOverload();
				if(current_struct.moveInitOverload.compare_exchange_strong(
					init_expected,
					BaseType::Struct::DeletableOverload(BaseType::Struct::DeletableOverload::State::EXPLICITLY_DELETED)
				) == false){
					if(init_expected.wasDeleted()){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
							instr.deleted_special_method,
							"Operator overload [move] was already explicitly deleted"
						);
					}else{
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
							*init_expected.funcID,
							"Operator overload [move] was explicitly deleted"
						);
					}
					return Result::ERROR;
				}

				if(current_struct.moveAssignOverload.load(std::memory_order::relaxed).has_value()){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_OPERATOR_MOVE_OVERLOAD,
						*current_struct.moveAssignOverload.load(std::memory_order::relaxed),
						"Operator overload [move] was explicitly deleted"
					);
					return Result::ERROR;
				}
			} break;

			default: {
				evo::debugFatalBreak("Unknown or unsupported deletable overload");
			} break;
		}


		this->propagate_finished_decl_def();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_func_alias_def(const Instruction::FuncAliasDef& instr) -> Result {
		const evo::Result<FuncAliasAttrs> func_alias = this->analyze_func_alias_attrs(
			instr.func_alias_def, instr.attribute_params_info
		);
		if(func_alias.isError()){ return Result::ERROR; }


		const TermInfo& target_term_info = this->get_term_info(instr.target);

		if(target_term_info.type_id.is<TermInfo::FuncOverloadList>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_FUNC_ALIAS_MUST_BE_FUNC,
				instr.func_alias_def.func,
				"Target of function alias must be a function"
			);
			return Result::ERROR;
		}


		const sema::FuncAlias::ID created_func_alias_id = this->context.sema_buffer.createFuncAlias(
			this->source.getID(),
			instr.func_alias_def.ident,
			this->scope.getCurrentEncapsulatingSymbolIfExists(),
			target_term_info.type_id.as<TermInfo::FuncOverloadList>(),
			func_alias.value().is_pub,
			func_alias.value().is_priv
		);

		const std::string_view ident_str = this->source.getTokenBuffer()[instr.func_alias_def.ident].getString();
		if(this->add_ident_to_scope(ident_str, instr.func_alias_def, true, created_func_alias_id).isError()){
			return Result::ERROR;
		}

		this->propagate_finished_decl_def();
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_interface_prepare(const Instruction::InterfacePrepare& instr) -> Result {
		const evo::Result<InterfaceAttrs> interface_attrs = this->analyze_interface_attrs(
			instr.interface_def, instr.attribute_params_info
		);
		if(interface_attrs.isError()){ return Result::ERROR; }

		const BaseType::ID created_interface_type_id = this->context.type_manager.createInterface(
			BaseType::Interface(
				this->source.getID(),
				instr.interface_def.ident,
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				this->symbol_proc_id,
				interface_attrs.value().is_pub,
				interface_attrs.value().is_priv,
				interface_attrs.value().is_polymorphic
			)
		);

		const std::string_view ident_str = this->source.getTokenBuffer()[instr.interface_def.ident].getString();
		if(this->add_ident_to_scope(
			ident_str, instr.interface_def, true, created_interface_type_id.interfaceID()
		).isError()){
			return Result::ERROR;
		}

		this->push_scope_level(nullptr, created_interface_type_id.interfaceID());
		this->get_current_scope_level().setDontDoShadowingChecks();

		this->context.symbol_proc_manager.addTypeSymbolProc(
			this->context.type_manager.getOrCreateTypeInfo(TypeInfo(created_interface_type_id)),
			this->symbol_proc_id
		);


		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_interface_decl() -> Result {
		BaseType::Interface::ID current_interface_id =
			this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Interface::ID>();

		BaseType::Interface& current_interface = this->context.type_manager.getInterface(current_interface_id);

		if(current_interface.isPolymorphic){
			for(const sema::Func::ID method_id : current_interface.methods){
				const sema::Func& method = this->context.getSemaBuffer().getFunc(method_id);
				const BaseType::Function& method_type = this->context.getTypeManager().getFunction(method.typeID);

				for(TypeInfo::VoidableID return_type : method_type.returnTypes){
					if(this->context.getTypeManager().isTypeDeducer(return_type)){
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_INVALID_METHOD,
							method_id,
							"Method of a polymorphic interface cannot return type deducers"
						);
						return Result::ERROR;
					}
				}
			}


			auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);
			sema_to_pir.lowerInterface(current_interface_id);
		}

		this->propagate_finished_decl();

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_interface_def() -> Result {
		BaseType::Interface::ID current_interface_id =
			this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Interface::ID>();

		this->context.type_manager.getInterface(current_interface_id).defCompleted = true;

		if(this->pop_scope_level<PopScopeLevelKind::SYMBOL_END>().isError()){ return Result::ERROR; }

		this->propagate_finished_def();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_interface_func_def(const Instruction::InterfaceFuncDef& instr) -> Result {
		const sema::Func::ID current_method_id = this->scope.getCurrentEncapsulatingSymbol().as<sema::Func::ID>();
		sema::Func& current_method = this->context.sema_buffer.funcs[current_method_id];

		if(instr.func_def.block.has_value()){ // has default 
			if(this->get_current_scope_level().isTerminated()){
				current_method.isTerminated = true;

			}else{
				const BaseType::Function& func_type = this->context.getTypeManager().getFunction(current_method.typeID);

				if(func_type.returnsVoid() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_TERMINATED,
						instr.func_def,
						"Function isn't terminated",
						Diagnostic::Info(
							"A function is terminated when all control paths end in a [return], [error], [unreachable],"
							" or a function call that has the attribute [#noReturn]"
						)
					);
					return Result::ERROR;
				}
			}

			current_method.status = sema::Func::Status::DEF_DONE;

		}else{
			current_method.status = sema::Func::Status::INTERFACE_METHOD_NO_DEFAULT;
		}

		if(this->pop_scope_level<PopScopeLevelKind::SYMBOL_END>().isError()){ return Result::ERROR; }
		this->propagate_finished_def();

		BaseType::Interface& current_interface = this->context.type_manager.getInterface(
			this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Interface::ID>()
		);
		current_interface.methods.emplace_back(current_method_id);

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_interface_impl_decl(const Instruction::InterfaceImplDecl& instr) -> Result {
		const TypeInfo::VoidableID target_type_id = this->get_type(instr.target);

		if(target_type_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_INTERFACE_IMPL_TARGET_NOT_INTERFACE,
				instr.interface_impl.target,
				"Interface impl target is not an interface"
			);
			return Result::ERROR;
		}

		const TypeInfo& target_type = this->context.getTypeManager().getTypeInfo(target_type_id.asTypeID());

		if(target_type.qualifiers().empty() == false || target_type.baseTypeID().kind() != BaseType::Kind::INTERFACE){
			this->emit_error(
				Diagnostic::Code::SEMA_INTERFACE_IMPL_TARGET_NOT_INTERFACE,
				instr.interface_impl.target,
				"Interface impl target is not an interface"
			);
			return Result::ERROR;
		}

		const BaseType::Interface::ID target_interface_id = target_type.baseTypeID().interfaceID();
		BaseType::Interface& target_interface = this->context.type_manager.getInterface(target_interface_id);

		if(
			this->scope.inEncapsulatingSymbol() == false
			|| this->scope.getCurrentEncapsulatingSymbol().is<BaseType::Struct::ID>() == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_INTERFACE_IMPL_NOT_DEFINED_IN_STRUCT,
				instr.interface_impl,
				"Interface impl must be defined in type scope"
			);
			return Result::ERROR;
		}

		const BaseType::Struct::ID current_struct_id =
			this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>();
		const BaseType::Struct& current_struct = this->context.getTypeManager().getStruct(current_struct_id);

		BaseType::Interface::Impl& interface_impl =
			this->context.type_manager.createInterfaceImpl(instr.interface_impl);

		this->symbol_proc.extra_info.emplace<SymbolProc::InterfaceImplInfo>(
			target_interface_id,
			target_interface,
			SymbolProc::InterfaceImplInfo::ParentTypeInfo(
				*current_struct.namespacedMembers, *current_struct.scopeLevel, current_struct.sourceID.as<Source::ID>()
			),
			&interface_impl
		);

		this->push_scope_level();

		this->propagate_finished_decl();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_interface_in_def_impl_decl(const Instruction::InterfaceInDefImplDecl& instr)
	-> Result {
		const TypeInfo::VoidableID target_type_id = this->get_type(instr.target);

		if(target_type_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_INTERFACE_IMPL_TARGET_NOT_INTERFACE,
				instr.interface_impl.target,
				"Interface impl target cannot be `Void`"
			);
			return Result::ERROR;
		}

		if(this->symbol_proc.builtin_symbol_proc_kind.has_value()){
			const BaseType::Interface::ID builtin_interface_id = [&]() -> BaseType::Interface::ID {
				const BuiltinModule& pthr_module = this->context.getSourceManager()[BuiltinModule::ID::PTHR];

				switch(*this->symbol_proc.builtin_symbol_proc_kind){
					case SymbolProcManager::constevalLookupBuiltinSymbolKind("array.Iterable"): {
						return pthr_module.getSymbol("Iterable")->as<BaseType::ID>().interfaceID();
					} break;

					case SymbolProcManager::constevalLookupBuiltinSymbolKind("array.IterableRT"): {
						return pthr_module.getSymbol("IterableRT")->as<BaseType::ID>().interfaceID();
					} break;

					case SymbolProcManager::constevalLookupBuiltinSymbolKind("arrayRef.IterableRef"): {
						return pthr_module.getSymbol("IterableRef")->as<BaseType::ID>().interfaceID();
					} break;

					case SymbolProcManager::constevalLookupBuiltinSymbolKind("arrayRef.IterableRefRT"): {
						return pthr_module.getSymbol("IterableRefRT")->as<BaseType::ID>().interfaceID();
					} break;

					case SymbolProcManager::constevalLookupBuiltinSymbolKind("arrayMutRef.IterableMutRef"): {
						return pthr_module.getSymbol("IterableMutRef")->as<BaseType::ID>().interfaceID();
					} break;

					case SymbolProcManager::constevalLookupBuiltinSymbolKind("arrayMutRef.IterableMutRefRT"): {
						return pthr_module.getSymbol("IterableMutRefRT")->as<BaseType::ID>().interfaceID();
					} break;

					default: {
						evo::debugFatalBreak("Invalid builtin symbol kind");
					} break;
				}
			}();

			this->push_scope_level(nullptr, builtin_interface_id);
		}


		const BaseType::Interface::ID target_interface_id =
			this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Interface::ID>();

		BaseType::Interface& target_interface = this->context.type_manager.getInterface(target_interface_id);


		if(this->context.getTypeManager().isTypeDeducer(target_type_id.asTypeID())){
			BaseType::Interface::DeducerImpl& interface_deudcer_impl =
				this->context.type_manager.createInterfaceDeducerImpl(
					target_type_id.asTypeID(), instr.interface_impl_node, this->symbol_proc_id
				);

			this->symbol_proc.extra_info.emplace<SymbolProc::InterfaceImplInfo>(
				target_interface_id, target_interface, target_type_id.asTypeID(), &interface_deudcer_impl
			);

			this->push_scope_level();

		}else{
			BaseType::Interface::Impl& interface_impl =
				this->context.type_manager.createInterfaceImpl(instr.interface_impl);

			this->symbol_proc.extra_info.emplace<SymbolProc::InterfaceImplInfo>(
				target_interface_id, target_interface, target_type_id.asTypeID(), &interface_impl
			);

			this->push_scope_level(
				nullptr, EncapsulatingSymbolID::InterfaceImplInfo(target_type_id.asTypeID(), target_interface_id)
			);
		}


		this->propagate_finished_decl();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_interface_deducer_impl_instantiation_decl(
		const Instruction::InterfaceDeducerImplInstantiationDecl& instr
	) -> Result {
		const BaseType::Interface::ID target_interface_id =
			this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Interface::ID>();
		BaseType::Interface& target_interface = this->context.type_manager.getInterface(target_interface_id);


		this->symbol_proc.extra_info.emplace<SymbolProc::InterfaceImplInfo>(
			target_interface_id, target_interface, instr.instantiation_type_id, &instr.created_impl
		);


		this->push_scope_level(
			nullptr, EncapsulatingSymbolID::InterfaceImplInfo(instr.instantiation_type_id, target_interface_id)
		);

		this->propagate_finished_decl();

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_interface_impl_method_lookup(const Instruction::InterfaceImplMethodLookup& instr)
	-> Result {
		SymbolProc::InterfaceImplInfo& info = this->symbol_proc.extra_info.as<SymbolProc::InterfaceImplInfo>();

		const std::string_view target_ident_str = this->source.getTokenBuffer()[instr.method_name].getString();

		const WaitOnSymbolProcResult wait_on_symbol_proc_result = this->wait_on_symbol_proc<false>(
			&info.type_info.as<SymbolProc::InterfaceImplInfo::ParentTypeInfo>().namespaced_members,
			target_ident_str
		);

		switch(wait_on_symbol_proc_result){
			case WaitOnSymbolProcResult::NOT_FOUND: case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
				this->wait_on_symbol_proc_emit_error(
					wait_on_symbol_proc_result,
					instr.method_name,
					std::format("Interface has no method named \"{}\"", target_ident_str)
				);
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED: case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::NEED_TO_WAIT: {
				return Result::NEED_TO_WAIT;
			} break;

			case WaitOnSymbolProcResult::SEMAS_READY: {
				// do nothing...
			} break;
		}


		evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError> expr_ident = 
			this->analyze_expr_ident_in_scope_level<false, ScopeAccessRequirement::NONE>(
				instr.method_name,
				target_ident_str,
				info.type_info.as<SymbolProc::InterfaceImplInfo::ParentTypeInfo>().scope_level,
				true,
				true,
				&this->context.getSourceManager()[
					info.type_info.as<SymbolProc::InterfaceImplInfo::ParentTypeInfo>().source_id
				]
			);


		if(expr_ident.has_value() == false){
			switch(expr_ident.error()){
				case AnalyzeExprIdentInScopeLevelError::DOESNT_EXIST: {
					evo::debugFatalBreak("Decl is done, but can't find sema of symbol");
				} break;

				case AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF: {
					evo::debugFatalBreak(
						"Sema doesn't have completed info for decl despite SymbolProc saying it should"
					);
				} break;

				case AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED: return Result::ERROR;
			}
		}


		info.targets.emplace_back(std::move(*expr_ident));

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_interface_in_def_impl_method(const Instruction::InterfaceInDefImplMethod& instr)
	-> Result {
		SymbolProc::InterfaceImplInfo& info = this->symbol_proc.extra_info.as<SymbolProc::InterfaceImplInfo>();

		if(info.interface_impl.is<BaseType::Interface::Impl*>()){ // in non-deducer impl
			SymbolProc& sub_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(instr.symbol_proc_id);

			evo::debugAssert(sub_symbol_proc.isLocalSymbol(), "Should not call this instruction on a non-local symbol");


			sub_symbol_proc.sema_scope_id = 
				this->context.sema_buffer.scope_manager.copyScope(*this->symbol_proc.sema_scope_id);

			this->context.symbol_proc_manager.num_procs_not_done += 1;

			{
				const auto lock = std::scoped_lock(sub_symbol_proc.waiting_for_lock);
				sub_symbol_proc.setStatusInQueue();
				this->context.add_task_to_work_manager(instr.symbol_proc_id);
			}


			const SymbolProc::WaitOnResult wait_on_result = 
				sub_symbol_proc.waitOnDeclIfNeeded(this->symbol_proc_id, this->context, instr.symbol_proc_id);

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                return Result::SUCCESS;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(instr.symbol_proc_id);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                   return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
				case SymbolProc::WaitOnResult::WAS_ERRORED:               return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:evo::debugFatalBreak("Not possible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:     return Result::ERROR;
			}

			evo::unreachable();

		}else{ // in deducer impl
			info.interface_impl.as<BaseType::Interface::DeducerImpl*>()->methods.emplace_back(instr.symbol_proc_id);

			this->context.symbol_proc_manager.getSymbolProc(instr.symbol_proc_id).setStatusInDefDeducerImplMethod();
				
			return Result::SUCCESS;
		}
	}



	auto SemanticAnalyzer::instr_interface_impl_def(const Instruction::InterfaceImplDef& instr) -> Result {
		SymbolProc::InterfaceImplInfo& info = this->symbol_proc.extra_info.as<SymbolProc::InterfaceImplInfo>();

		if(info.interface_impl.is<BaseType::Interface::Impl*>()){
			return this->impl_instr_interface_impl_def_non_deducer(instr);
		}else{
			return this->impl_instr_interface_impl_def_deducer();
		}
	}


	auto SemanticAnalyzer::instr_interface_impl_comptime_pir() -> Result {
		SymbolProc::InterfaceImplInfo& info = this->symbol_proc.extra_info.as<SymbolProc::InterfaceImplInfo>();

		if(info.target_interface.isPolymorphic){
			const TypeInfo::ID current_type_id = [&](){
				if(info.type_info.is<SymbolProc::InterfaceImplInfo::ParentTypeInfo>()){
					return this->context.type_manager.getOrCreateTypeInfo(
						TypeInfo(BaseType::ID(this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()))
					);
					
				}else{
					return info.type_info.as<TypeInfo::ID>();
				}
			}();

			const BaseType::Interface::Impl& interface_impl = [&]() -> const BaseType::Interface::Impl& {
				const auto lock = std::scoped_lock(info.target_interface.implsLock);
				return info.target_interface.impls.at(current_type_id);
			}();


			auto sema_to_pir = SemaToPIR(this->context, this->context.pir_module, this->context.sema_to_pir_data);

			sema_to_pir.lowerInterfaceVTableComptime(
				info.target_interface_id, current_type_id, interface_impl.methods
			);
		}

		this->propagate_finished_pir_def();

		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_local_var(const Instruction::LocalVar& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.var_def).isError()){ return Result::ERROR; }

		const std::string_view var_ident = this->source.getTokenBuffer()[instr.var_def.ident].getString();

		const evo::Result<VarAttrs> var_attrs = this->analyze_var_attrs(instr.var_def, instr.attribute_params_info);
		if(var_attrs.isError()){ return Result::ERROR; }

		if(var_attrs.value().is_global){
			this->emit_error(
				Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
				instr.var_def,
				"Static variables are currently unimplemented"
			);
			return Result::ERROR;
		}


		TermInfo& value_term_info = this->get_term_info(instr.value);
		if(value_term_info.value_category == TermInfo::ValueCategory::MODULE){
			if(instr.var_def.kind != AST::VarDef::Kind::DEF){
				this->emit_error(
					Diagnostic::Code::SEMA_MODULE_VAR_MUST_BE_DEF,
					*instr.var_def.value,
					"Variable that has a module value must be declared as [def]"
				);
				return Result::ERROR;
			}

			const evo::Result<> add_ident_result = this->add_ident_to_scope(
				var_ident,
				instr.var_def,
				true,
				value_term_info.type_id.as<Source::ID>(),
				instr.var_def.ident,
				this->scope.getCurrentEncapsulatingSymbolIfExists(),
				false,
				false
			);

			return add_ident_result.isError() ? Result::ERROR : Result::SUCCESS;
		}


		if(value_term_info.value_category == TermInfo::ValueCategory::INITIALIZER){
			if(instr.type_id.has_value() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_INITIALIZER_WITHOUT_EXPLICIT_TYPE,
					*instr.var_def.value,
					"Cannot define a variable with an initializer value without an explicit type"
				);
				return Result::ERROR;
			}

			if(this->context.getTypeManager().isTypeDeducer(this->get_type(*instr.type_id))){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_INITIALIZER_WITHOUT_EXPLICIT_TYPE,
					*instr.var_def.value,
					"Cannot define a variable with an initializer value without an explicit type",
					Diagnostic::Info("Note: the type of the variable cannot be deduced from this value")
				);
				return Result::ERROR;
			}

		}else if(value_term_info.value_category == TermInfo::ValueCategory::NULL_VALUE){
			if(instr.type_id.has_value() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_NULL_WITHOUT_EXPLICIT_TYPE,
					*instr.var_def.value,
					"Cannot define a variable with a value [null] value without an explicit type"
				);
				return Result::ERROR;
			}

			if(this->context.getTypeManager().isTypeDeducer(this->get_type(*instr.type_id))){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_NULL_WITHOUT_EXPLICIT_TYPE,
					*instr.var_def.value,
					"Cannot define a variable with a value [null] value without an explicit type",
					Diagnostic::Info("Note: the type of the variable cannot be deduced from this value")
				);
				return Result::ERROR;	
			}

		}else if(value_term_info.is_ephemeral() == false){
			if(this->check_term_isnt_type(value_term_info, *instr.var_def.value).isError()){ return Result::ERROR; }

			this->emit_error(
				Diagnostic::Code::SEMA_VAR_DEF_NOT_EPHEMERAL,
				*instr.var_def.value,
				"Cannot define a variable with a value that is not ephemeral, an initializer value, or [null]"
			);
			return Result::ERROR;
		}

			
		if(value_term_info.isMultiValue()){
			this->emit_error(
				Diagnostic::Code::SEMA_MULTI_RETURN_INTO_SINGLE_VALUE,
				*instr.var_def.value,
				"Cannot define a variable with multiple values"
			);
			return Result::ERROR;
		}


		if(instr.type_id.has_value()){
			const TypeInfo::VoidableID got_type_info_id = this->get_type(*instr.type_id);

			if(got_type_info_id.isVoid()){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_TYPE_VOID, *instr.var_def.type, "Variables cannot be type `Void`"
				);
				return Result::ERROR;
			}

			const TypeInfo& got_type_info = this->context.getTypeManager().getTypeInfo(got_type_info_id.asTypeID());

			if(got_type_info.baseTypeID().kind() == BaseType::Kind::INTERFACE){
				this->emit_error(
					Diagnostic::Code::SEMA_VAR_TYPE_INTERFACE,
					*instr.var_def.type,
					"Variables cannot be an interface type"
				);
				return Result::ERROR;
			}


			if(value_term_info.value_category != TermInfo::ValueCategory::INITIALIZER){
				TypeCheckInfo type_check_info = this->type_check<true, true>(
					got_type_info_id.asTypeID(), value_term_info, "Variable definition", *instr.var_def.value
				);

				if(type_check_info.ok == false){
					if(type_check_info.special_result_from_interface_match.has_value()){
						return type_check_info.extractSpecialResultFromInterfaceMatch();
					}else{
						return Result::ERROR;
					}
				}

				if(this->add_deduced_terms_to_scope(type_check_info.deduced_terms).isError()){ return Result::ERROR; }
			}

		}else if(
			instr.var_def.kind != AST::VarDef::Kind::DEF &&
			value_term_info.value_category == TermInfo::ValueCategory::EPHEMERAL_FLUID
		){
			this->emit_error(
				Diagnostic::Code::SEMA_CANNOT_INFER_TYPE,
				*instr.var_def.value,
				"Cannot infer the type of a fluid literal",
				Diagnostic::Info("Did you mean this variable to be [def]? If not, give the variable an explicit type")
			);
			return Result::ERROR;
		}

		const std::optional<TypeInfo::ID> type_id = [&]() -> std::optional<TypeInfo::ID> {
			if(value_term_info.type_id.is<TypeInfo::ID>()){
				return std::optional<TypeInfo::ID>(value_term_info.type_id.as<TypeInfo::ID>());
			}

			if(
				value_term_info.value_category == TermInfo::ValueCategory::INITIALIZER
				|| value_term_info.value_category == TermInfo::ValueCategory::NULL_VALUE
			){
				return this->get_type(*instr.type_id).asTypeID();
			}

			return std::optional<TypeInfo::ID>();
		}();

		const sema::Var::ID new_sema_var = this->context.sema_buffer.createVar(
			instr.var_def.kind, instr.var_def.ident, value_term_info.getExpr(), type_id
		);
		this->get_current_scope_level().stmtBlock().emplace_back(new_sema_var);

		if(this->add_ident_to_scope(var_ident, instr.var_def, true, new_sema_var).isError()){ return Result::ERROR; }

		if(instr.var_def.kind != AST::VarDef::Kind::DEF){
			if(value_term_info.value_category == TermInfo::ValueCategory::INITIALIZER){
				this->add_ident_value_state(new_sema_var, sema::ScopeLevel::ValueState::UNINIT);
			}else{
				this->add_ident_value_state(new_sema_var, sema::ScopeLevel::ValueState::INIT);
			}

			if(type_id.has_value() && this->context.getTypeManager().getTypeInfo(*type_id).isUninitPointer()){
				this->add_ident_value_state(sema::UninitPtrLocalVar(new_sema_var), sema::ScopeLevel::ValueState::UNINIT);
			}
		}

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_local_func_alias(const Instruction::LocalFuncAlias& instr) -> Result {
		if(instr.attribute_params_info.empty() == false){
			const AST::AttributeBlock::Attribute& first_ast_attribute =
				this->source.getASTBuffer().getAttributeBlock(instr.func_alias_def.attributeBlock).attributes[0];

			this->emit_error(
				Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
				first_ast_attribute.attribute,
				std::format(
					"Unknown local function alias attribute #{}",
					this->source.getTokenBuffer()[first_ast_attribute.attribute].getString()
				)
			);
			return Result::ERROR;
		}

		const TermInfo& target_term_info = this->get_term_info(instr.target);

		if(target_term_info.type_id.is<TermInfo::FuncOverloadList>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_FUNC_ALIAS_MUST_BE_FUNC,
				instr.func_alias_def.func,
				"Target of function alias must be a function"
			);
			return Result::ERROR;
		}


		const sema::FuncAlias::ID created_func_alias_id = this->context.sema_buffer.createFuncAlias(
			this->source.getID(),
			instr.func_alias_def.ident,
			this->scope.getCurrentEncapsulatingSymbolIfExists(),
			target_term_info.type_id.as<TermInfo::FuncOverloadList>(),
			false,
			false
		);

		const std::string_view ident_str = this->source.getTokenBuffer()[instr.func_alias_def.ident].getString();
		if(this->add_ident_to_scope(ident_str, instr.func_alias_def, true, created_func_alias_id).isError()){
			return Result::ERROR;
		}

		this->propagate_finished_decl_def();
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_local_alias(const Instruction::LocalAlias& instr) -> Result {
		const evo::Result<LocalAliasAttrs> local_alias_attrs = 
			this->analyze_local_alias_attrs(instr.alias_def, instr.attribute_params_info);
		if(local_alias_attrs.isError()){ return Result::ERROR; }


		const TypeInfo::VoidableID aliased_type = this->get_type(instr.aliased_type);
		if(aliased_type.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_ALIAS_CANNOT_BE_VOID,
				instr.alias_def.type,
				"Alias cannot be type `Void`"
			);
			return Result::ERROR;
		}


		if(local_alias_attrs.value().is_distinct){
			const BaseType::ID created_alias_id = this->context.type_manager.createDistinctAlias(
				BaseType::DistinctAlias(
					this->source.getID(),
					instr.alias_def.ident,
					this->scope.getCurrentEncapsulatingSymbolIfExists(),
					aliased_type.asTypeID(),
					false
				)
			);

			const std::string_view alias_ident = this->source.getTokenBuffer()[instr.alias_def.ident].getString();
			if(this->add_ident_to_scope(
				alias_ident, instr.alias_def.ident, true, created_alias_id.distinctAliasID()
			).isError()){
				return Result::ERROR;
			}
			
		}else{
			const BaseType::ID created_alias_id = this->context.type_manager.createAlias(
				BaseType::Alias(
					this->source.getID(),
					instr.alias_def.ident,
					this->scope.getCurrentEncapsulatingSymbolIfExists(),
					aliased_type.asTypeID(),
					false
				)
			);

			const std::string_view alias_ident = this->source.getTokenBuffer()[instr.alias_def.ident].getString();
			if(this->add_ident_to_scope(
				alias_ident, instr.alias_def.ident, true, created_alias_id.aliasID()
			).isError()){
				return Result::ERROR;
			}
		}
		
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_return(const Instruction::Return& instr) -> Result {
		evo::debugAssert(instr.return_stmt.label.has_value() == false, "Wrong instruction for a labeled return");

		if(this->check_scope_isnt_terminated(instr.return_stmt).isError()){ return Result::ERROR; }

		for(size_t i = this->scope.size() - 1; const sema::ScopeLevel::ID& target_scope_level_id : this->scope){
			EVO_DEFER([&](){ i -= 1; });

			if(i == this->scope.getCurrentEncapsulatingSymbolIndex()){ break; }

			const sema::ScopeLevel& target_scope_level = 
				this->context.sema_buffer.scope_manager.getLevel(target_scope_level_id);

			if(target_scope_level.isDeferMainScope()){
				this->emit_error(
					Diagnostic::Code::SEMA_UNLABELED_RETURN_IN_DEFER,
					instr.return_stmt,
					"Unlabeled return statements are not allowed in [defer]/[errorDefer] blocks"
				);
				return Result::ERROR;
			}
		}

		const sema::Func& current_func = this->get_current_func();
		const BaseType::Function& current_func_type = this->context.getTypeManager().getFunction(current_func.typeID);


		auto return_value = std::optional<sema::Expr>();
		if(instr.return_stmt.value.is<std::monostate>()){ // return;
			if(current_func_type.returnsVoid() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.return_stmt,
					"Functions that have a return type other than `Void` must return a value"
				);
				return Result::ERROR;
			}

			if(current_func_type.hasNamedReturns){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.return_stmt,
					"Incorrect return statement kind for a function named return parameters",
					Diagnostic::Info("Initialize/set all return parameters, and use \"return...;\" instead")
				);
				return Result::ERROR;
			}
			
		}else if(instr.return_stmt.value.is<AST::Node>()){ // return {EXPRESSION};
			evo::debugAssert(instr.value.has_value(), "Return value needs to have value analyzed");

			if(current_func_type.returnsVoid()){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.return_stmt,
					"Functions that have a return type of `Void` cannot return a value"
				);
				return Result::ERROR;
			}

			if(current_func_type.hasNamedReturns){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.return_stmt,
					"Incorrect return statement kind for a function with named return parameters",
					Diagnostic::Info("Initialize/set all return parameters, and use \"return...;\" instead")
				);
				return Result::ERROR;
			}


			TermInfo& return_value_term = this->get_term_info(*instr.value);

			if(return_value_term.is_ephemeral() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_RETURN_NOT_EPHEMERAL,
					instr.return_stmt.value.as<AST::Node>(),
					"Value of return statement is not ephemeral"
				);
				return Result::ERROR;
			}

			if(this->type_check<true, true>(
				current_func_type.returnTypes.front().asTypeID(),
				return_value_term,
				"Return statement",
				instr.return_stmt.value.as<AST::Node>()
			).ok == false){
				return Result::ERROR;
			}

			return_value = return_value_term.getExpr();
			
		}else{ // return...;
			evo::debugAssert(instr.return_stmt.value.is<Token::ID>(), "Unknown return kind");

			if(current_func_type.returnsVoid()){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.return_stmt,
					"Functions that have a return type of `Void` cannot return a value"
				);
				return Result::ERROR;
			}

			if(current_func_type.hasNamedReturns == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.return_stmt,
					"Incorrect return statement kind for single unnamed return parameters",
					Diagnostic::Info("Use \"return {EXPRESSION};\" instead")
				);
				return Result::ERROR;
			}

			const SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();
			if(func_info.num_members_of_initializing_are_uninit != 0){
				if(func_info.num_members_of_initializing_are_uninit == 1){
					this->emit_error(
						Diagnostic::Code::SEMA_NOT_ALL_MEMBERS_OF_OVERLOAD_OUTPUT_ARE_INIT,
						instr.return_stmt,
						"Not all members of the output are initialized",
						Diagnostic::Info("Missing 1 member")
					);

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_NOT_ALL_MEMBERS_OF_OVERLOAD_OUTPUT_ARE_INIT,
						instr.return_stmt,
						"Not all members of the output are initialized",
						Diagnostic::Info(
							std::format("Missing {} members", func_info.num_members_of_initializing_are_uninit)
						)
					);	
				}
				return Result::ERROR;
			}

			// check that all named returns are initialized
			auto infos = evo::SmallVector<Diagnostic::Info>();
			for(const auto [value_state_id, value_state_info] : this->get_current_scope_level().getValueStateInfos()){
				if(value_state_info.info.is<sema::ScopeLevel::ValueStateInfo::ModifyInfo>()){ continue; }
				if(value_state_info.state == sema::ScopeLevel::ValueState::INIT){ continue; }
				if(value_state_id.is<sema::ReturnParam::ID>() == false){ continue; }

				infos.emplace_back("This one:", this->get_location(value_state_id.as<sema::ReturnParam::ID>()));
			}

			if(infos.empty() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_RETURN_NOT_ALL_RET_PARAMS_ARE_INIT,
					instr.return_stmt,
					"Not all return parameters are initialized",
					std::move(infos)
				);
				return Result::ERROR;
			}
		}

		const sema::Return::ID sema_return_id = this->context.sema_buffer.createReturn(return_value, std::nullopt);

		this->get_current_scope_level().stmtBlock().emplace_back(sema_return_id);
		this->get_current_scope_level().setTerminated();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_labeled_return(const Instruction::LabeledReturn& instr) -> Result {
		evo::debugAssert(instr.return_stmt.label.has_value(), "Not a labeled return");

		if(this->check_scope_isnt_terminated(instr.return_stmt).isError()){ return Result::ERROR; }

		const Token::ID target_label_id = ASTBuffer::getIdent(*instr.return_stmt.label);
		const sema::ScopeLevel* scope_level = nullptr;

		const std::string_view return_label = this->source.getTokenBuffer()[target_label_id].getString();

		///////////////////////////////////
		// find scope level

		for(size_t i = this->scope.size() - 1; const sema::ScopeLevel::ID& target_scope_level_id : this->scope){
			EVO_DEFER([&](){ i -= 1; });

			if(i == this->scope.getCurrentEncapsulatingSymbolIndex()){
				this->emit_error(
					Diagnostic::Code::SEMA_RETURN_LABEL_NOT_FOUND,
					*instr.return_stmt.label,
					std::format("Label \"{}\" not found", return_label)
				);
				return Result::ERROR;
			}

			scope_level = &this->context.sema_buffer.scope_manager.getLevel(target_scope_level_id);
			if(scope_level->hasLabel() == false){ continue; }
		
			const std::string_view scope_label = this->source.getTokenBuffer()[scope_level->getLabel()].getString();

			if(return_label == scope_label){ break; }
		}


		///////////////////////////////////
		// analyze return value(s)

		if(scope_level->getLabelNode().is<sema::BlockExpr::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_CANNOT_RETURN_TO_THIS_LABEL,
				*instr.return_stmt.label,
				std::format("Label \"{}\" cannot be returned to", return_label)
			);
			return Result::ERROR;
		}

		const sema::BlockExpr& target_block_expr = this->context.getSemaBuffer().getBlockExpr(
			scope_level->getLabelNode().as<sema::BlockExpr::ID>()
		);

		auto return_value = std::optional<sema::Expr>();
		if(instr.return_stmt.value.is<std::monostate>()){ // return;
			this->emit_error(
				Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
				instr.return_stmt,
				"Expression block must return a value"
			);
			return Result::ERROR;

		}else if(instr.return_stmt.value.is<AST::Node>()){ // return {EXPRESSION};
			evo::debugAssert(instr.value.has_value(), "Return value needs to have value analyzed");

			if(target_block_expr.hasNamedOutputs()){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.return_stmt,
					"Incorrect return statement kind for an expression block with named outputs",
					Diagnostic::Info(
						std::format(
							"Initialize/set all return parameters, and use \"return->{} ...;\" instead", return_label
						)
					)
				);
				return Result::ERROR;
			}


			TermInfo& return_value_term = this->get_term_info(*instr.value);

			if(return_value_term.is_ephemeral() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_RETURN_NOT_EPHEMERAL,
					instr.return_stmt.value.as<AST::Node>(),
					"Return values must be ephemeral"
				);
				return Result::ERROR;
			}

			if(this->type_check<true, true>(
				target_block_expr.outputs.front().typeID,
				return_value_term,
				"Labeled return",
				instr.return_stmt.value.as<AST::Node>()
			).ok == false){
				return Result::ERROR;
			}

			return_value = return_value_term.getExpr();
			
		}else{ // return...;
			evo::debugAssert(instr.return_stmt.value.is<Token::ID>(), "Unknown return kind");
			evo::debugAssert(instr.value.has_value() == false, "`return...;` should not have return value");

			if(target_block_expr.hasNamedOutputs() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.return_stmt,
					"Incorrect return statement kind for single unnamed output value",
					Diagnostic::Info("Use \"return {EXPRESSION};\" instead")
				);
				return Result::ERROR;
			}


			// check that all named returns are initialized
			auto infos = evo::SmallVector<Diagnostic::Info>();
			for(const auto [value_state_id, value_state_info] : this->get_current_scope_level().getValueStateInfos()){
				if(value_state_info.info.is<sema::ScopeLevel::ValueStateInfo::ModifyInfo>()){ continue; }
				if(value_state_info.state == sema::ScopeLevel::ValueState::INIT){ continue; }
				if(value_state_id.is<sema::BlockExprOutput::ID>() == false){ continue; }

				infos.emplace_back("This one:", this->get_location(value_state_id.as<sema::BlockExprOutput::ID>()));
			}

			if(infos.empty() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_RETURN_NOT_ALL_RET_PARAMS_ARE_INIT,
					instr.return_stmt,
					"Not all block expression return parameters are initialized",
					std::move(infos)
				);
				return Result::ERROR;
			}
		}


		const sema::Return::ID sema_return_id = this->context.sema_buffer.createReturn(return_value, target_label_id);

		this->get_current_scope_level().stmtBlock().emplace_back(sema_return_id);
		this->get_current_scope_level().setLabelTerminated();

		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_error(const Instruction::Error& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.error_stmt).isError()){ return Result::ERROR; }

		for(size_t i = this->scope.size() - 1; const sema::ScopeLevel::ID& target_scope_level_id : this->scope){
			EVO_DEFER([&](){ i -= 1; });

			if(i == this->scope.getCurrentEncapsulatingSymbolIndex()){ break; }

			const sema::ScopeLevel& target_scope_level = 
				this->context.sema_buffer.scope_manager.getLevel(target_scope_level_id);

			if(target_scope_level.isDeferMainScope()){
				this->emit_error(
					Diagnostic::Code::SEMA_ERROR_IN_DEFER,
					instr.error_stmt,
					"Error statements are not allowed in [defer]/[errorDefer] blocks"
				);
				return Result::ERROR;
			}
		}

		const sema::Func& current_func = this->get_current_func();
		const BaseType::Function& current_func_type = this->context.getTypeManager().getFunction(current_func.typeID);


		if(current_func_type.hasErrorReturn() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_ERROR_IN_FUNC_WITHOUT_ERRORS,
				instr.error_stmt,
				"Cannot error return in a function that does not have error returns"
			);
			return Result::ERROR;
		}


		auto error_value = std::optional<sema::Expr>();
		if(instr.error_stmt.value.is<std::monostate>()){ // error;
			if(current_func_type.hasErrorReturnParams()){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.error_stmt,
					"Incorrect error return statement kind for a function named error return parameters",
					Diagnostic::Info("Set all error return values and use \"error...;\" instead")
				);
				return Result::ERROR;
			}
			
		}else if(instr.error_stmt.value.is<AST::Node>()){ // error {EXPRESSION};
			evo::debugAssert(instr.value.has_value(), "error return value needs to have value analyzed");

			if(current_func_type.hasNamedErrorReturns){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.error_stmt,
					"Incorrect error return statement kind for a function named error return parameters",
					Diagnostic::Info("Set all error return values and use \"error...;\" instead")
				);
				return Result::ERROR;
			}


			TermInfo& error_value_term = this->get_term_info(*instr.value);

			if(error_value_term.is_ephemeral() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_RETURN_NOT_EPHEMERAL,
					instr.error_stmt.value.as<AST::Node>(),
					"Error return values must be ephemeral"
				);
				return Result::ERROR;
			}

			if(this->type_check<true, true>(
				current_func_type.errorTypes.front().asTypeID(),
				error_value_term,
				"Error return",
				instr.error_stmt.value.as<AST::Node>()
			).ok == false){
				return Result::ERROR;
			}

			error_value = error_value_term.getExpr();
			
		}else{ // error...;
			evo::debugAssert(instr.error_stmt.value.is<Token::ID>(), "Unknown return kind");

			if(current_func_type.hasNamedErrorReturns == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INCORRECT_RETURN_STMT_KIND,
					instr.error_stmt,
					"Incorrect error return statement kind for single unnamed error return parameters",
					Diagnostic::Info("Use \"error {EXPRESSION};\" instead")
				);
				return Result::ERROR;
			}

			// check that all named returns are initialized
			auto infos = evo::SmallVector<Diagnostic::Info>();
			for(const auto [value_state_id, value_state_info] : this->get_current_scope_level().getValueStateInfos()){
				if(value_state_info.info.is<sema::ScopeLevel::ValueStateInfo::ModifyInfo>()){ continue; }
				if(value_state_info.state == sema::ScopeLevel::ValueState::INIT){ continue; }
				if(value_state_id.is<sema::ErrorReturnParam::ID>() == false){ continue; }

				infos.emplace_back("This one:", this->get_location(value_state_id.as<sema::ErrorReturnParam::ID>()));
			}

			if(infos.empty() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_ERROR_NOT_ALL_RET_PARAMS_ARE_INIT,
					instr.error_stmt,
					"Not all error return parameters are initialized",
					std::move(infos)
				);
				return Result::ERROR;
			}
		}

		const sema::Error::ID sema_error_id = this->context.sema_buffer.createError(error_value);

		this->get_current_scope_level().stmtBlock().emplace_back(sema_error_id);
		this->get_current_scope_level().setTerminated();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_unreachable(const Instruction::Unreachable& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.keyword).isError()){ return Result::ERROR; }
		
		this->get_current_scope_level().stmtBlock().emplace_back(sema::Stmt::createUnreachable(instr.keyword));
		this->get_current_scope_level().setTerminated();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_break(const Instruction::Break& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.break_stmt).isError()){ return Result::ERROR; }

		if(instr.break_stmt.label.has_value()){
			const sema::ScopeLevel* scope_level = nullptr;

			const std::string_view return_label = this->source.getTokenBuffer()[*instr.break_stmt.label].getString();

			for(size_t i = this->scope.size() - 1; const sema::ScopeLevel::ID& target_scope_level_id : this->scope){
				EVO_DEFER([&](){ i -= 1; });

				if(i == this->scope.getCurrentEncapsulatingSymbolIndex()){
					this->emit_error(
						Diagnostic::Code::SEMA_BREAK_LABEL_NOT_FOUND,
						*instr.break_stmt.label,
						std::format("Label \"{}\" not found", return_label)
					);
					return Result::ERROR;
				}

				scope_level = &this->context.sema_buffer.scope_manager.getLevel(target_scope_level_id);
				if(scope_level->hasLabel() == false){ continue; }
			
				const std::string_view scope_label = this->source.getTokenBuffer()[scope_level->getLabel()].getString();

				if(return_label == scope_label){ break; }
			}

			if(scope_level->isLoopMainScope() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_CANNOT_BREAK_TO_THIS_LABEL,
					*instr.break_stmt.label,
					std::format("Cannot break to label \"{}\"", return_label)
				);
				return Result::ERROR;
			}

		}else{
			bool found_loop = false;

			for(size_t i = this->scope.size() - 1; const sema::ScopeLevel::ID& target_scope_level_id : this->scope){
				EVO_DEFER([&](){ i -= 1; });

				const sema::ScopeLevel& scope_level =
					this->context.sema_buffer.scope_manager.getLevel(target_scope_level_id);

				if(scope_level.isLoopMainScope()){
					found_loop = true;
					break;
				}
			}

			if(found_loop == false){
				this->emit_error(
					Diagnostic::Code::SEMA_NO_LOOP_TO_BREAK_TO,
					instr.break_stmt,
					"No loop to break to"
				);
				return Result::ERROR;
			}
		}

		const sema::Break::ID new_break_id = this->context.sema_buffer.createBreak(instr.break_stmt.label);
		this->get_current_scope_level().stmtBlock().emplace_back(new_break_id);
		this->get_current_scope_level().setTerminated();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_continue(const Instruction::Continue& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.continue_stmt).isError()){ return Result::ERROR; }

		if(instr.continue_stmt.label.has_value()){
			const sema::ScopeLevel* scope_level = nullptr;

			const std::string_view return_label = this->source.getTokenBuffer()[*instr.continue_stmt.label].getString();

			for(size_t i = this->scope.size() - 1; const sema::ScopeLevel::ID& target_scope_level_id : this->scope){
				EVO_DEFER([&](){ i -= 1; });

				if(i == this->scope.getCurrentEncapsulatingSymbolIndex()){
					this->emit_error(
						Diagnostic::Code::SEMA_CONTINUE_LABEL_NOT_FOUND,
						*instr.continue_stmt.label,
						std::format("Label \"{}\" not found", return_label)
					);
					return Result::ERROR;
				}

				scope_level = &this->context.sema_buffer.scope_manager.getLevel(target_scope_level_id);
				if(scope_level->hasLabel() == false){ continue; }
			
				const std::string_view scope_label = this->source.getTokenBuffer()[scope_level->getLabel()].getString();

				if(return_label == scope_label){ break; }
			}

			if(scope_level->isLoopMainScope() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_CANNOT_CONTINUE_TO_THIS_LABEL,
					*instr.continue_stmt.label,
					std::format("Cannot continue to label \"{}\"", return_label)
				);
				return Result::ERROR;
			}

		}else{
			bool found_loop = false;

			for(size_t i = this->scope.size() - 1; const sema::ScopeLevel::ID& target_scope_level_id : this->scope){
				EVO_DEFER([&](){ i -= 1; });

				const sema::ScopeLevel& scope_level =
					this->context.sema_buffer.scope_manager.getLevel(target_scope_level_id);

				if(scope_level.isLoopMainScope()){
					found_loop = true;
					break;
				}
			}

			if(found_loop == false){
				this->emit_error(
					Diagnostic::Code::SEMA_NO_LOOP_TO_CONTINUE_TO,
					instr.continue_stmt,
					"No loop to continue to"
				);
				return Result::ERROR;
			}
		}

		const sema::Continue::ID new_continue_id = this->context.sema_buffer.createContinue(instr.continue_stmt.label);
		this->get_current_scope_level().stmtBlock().emplace_back(new_continue_id);
		this->get_current_scope_level().setTerminated();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_delete(const Instruction::Delete& instr) -> Result {
		const TermInfo& target = this->get_term_info(instr.delete_expr);

		switch(target.value_state){
			case TermInfo::ValueState::NOT_APPLICABLE: {
				// do nothing, correct
			} break;

			case TermInfo::ValueState::INIT: {
				// do nothing, correct
			} break;

			case TermInfo::ValueState::INITIALIZING: {
				this->emit_error(
					Diagnostic::Code::SEMA_DELETE_ARG_INVALID,
					instr.delete_stmt.value,
					"Argument of [delete] statement is invalid as it isn't fully initialized"
				);
				return Result::ERROR;
			} break;

			case TermInfo::ValueState::UNINIT: {
				this->emit_error(
					Diagnostic::Code::SEMA_DELETE_ARG_INVALID,
					instr.delete_stmt.value,
					"Argument of [delete] statement is invalid as it is uninitialized"
				);
				return Result::ERROR;
			} break;

			case TermInfo::ValueState::MOVED_FROM: {
				if(this->get_package().warn.deleteMovedFromExpr){
					this->emit_warning(
						Diagnostic::Code::SEMA_WARN_DELETE_MOVED_FROM_EXPR,
						instr.delete_stmt.value,
						"Argument of [delete] statement was moved-from"
					);
				}
			} break;
		}


		if(
			this->get_package().warn.deleteTriviallyDeletableType
			&& this->context.getTypeManager().isTriviallyDeletable(target.type_id.as<TypeInfo::ID>())
		){
			this->emit_warning(
				Diagnostic::Code::SEMA_WARN_DELETE_TRIVIALLY_DELETABLE_TYPE,
				instr.delete_stmt.value,
				"Argument of [delete] statement is a trivially deletable type"
			);
		}

		switch(target.getExpr().kind()){
			case sema::Expr::Kind::VAR: {
				// safe, nothing to do...
			} break;

			case sema::Expr::Kind::ACCESSOR: {
				if(
					this->source.getTokenBuffer()[this->get_current_func().name.as<Token::ID>()].kind()
						!= Token::Kind::KEYWORD_DELETE
				){
					if(this->currently_in_unsafe() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
							instr.delete_stmt.value,
							"Unsafe delete while not in an unsafe scope"
						);
						return Result::ERROR;
					}
					break;
				}

				const sema::Accessor& accessor =
					this->context.getSemaBuffer().getAccessor(target.getExpr().accessorID());

				if(accessor.target.kind() != sema::Expr::Kind::PARAM){
					if(this->currently_in_unsafe() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
							instr.delete_stmt.value,
							"Unsafe delete while not in an unsafe scope"
						);
						return Result::ERROR;
					}
					break;
				}

				const sema::Param& accessor_lhs_param =
					this->context.getSemaBuffer().getParam(accessor.target.paramID());

				if(accessor_lhs_param.index != 0){
					if(this->currently_in_unsafe() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
							instr.delete_stmt.value,
							"Unsafe delete while not in an unsafe scope"
						);
						return Result::ERROR;
					}
					break;
				}
			} break;

			default: {
				if(this->currently_in_unsafe() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
						instr.delete_stmt.value,
						"Unsafe delete while not in an unsafe scope"
					);
					return Result::ERROR;
				}
			} break;
		}


		if(this->get_special_member_call_dependents<SpecialMemberKind::DELETE, true>(
			target,
			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
			instr.delete_stmt
		).isError()){
			return Result::ERROR;
		}
		this->get_current_scope_level().stmtBlock().emplace_back(
			this->context.sema_buffer.createDelete(target.getExpr(), target.type_id.as<TypeInfo::ID>())
		);

		if(this->set_ident_value_state_if_needed(
			target.getExpr(), sema::ScopeLevel::ValueState::UNINIT, instr.delete_stmt
		).isError()){
			return Result::ERROR;
		}

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_begin_cond(const Instruction::BeginCond& instr) -> Result {
		TermInfo& cond = this->get_term_info(instr.cond_expr);

		if(cond.value_state != TermInfo::ValueState::INIT && cond.value_state != TermInfo::ValueState::NOT_APPLICABLE){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.conditional.cond,
				"Condition in [if] conditional must be initialized"
			);
			return Result::ERROR;
		}

		if(this->type_check<true, true>(
			TypeManager::getTypeBool(), cond, "Condition in [if] condtional", instr.conditional.cond
		).ok == false){
			return Result::ERROR;
		}

		if(this->get_package().warn.comptimeIfCond && cond.value_stage == TermInfo::ValueStage::COMPTIME){
			this->emit_warning(
				Diagnostic::Code::SEMA_WARN_COMPTIME_IF_COND,
				instr.conditional.cond,
				"Condition in [if] condition is comptime",
				Diagnostic::Info("Consider converting it to a [when] condition")
			);
		}


		const sema::Conditional::ID new_sema_conditional_id = 
			this->context.sema_buffer.createConditional(cond.getExpr());

		this->get_current_scope_level().stmtBlock().emplace_back(new_sema_conditional_id);

		this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().subscopes.emplace(new_sema_conditional_id);

		sema::Conditional& new_sema_conditional = this->context.sema_buffer.conds[new_sema_conditional_id];
		this->push_scope_level(&new_sema_conditional.thenStmts);

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_cond_no_else() -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		this->get_current_scope_level().addSubScope();
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_cond_else() -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }

		const sema::Stmt current_cond_stmt = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().subscopes.top();
		sema::Conditional& current_conditional = this->context.sema_buffer.conds[current_cond_stmt.conditionalID()];

		this->push_scope_level(&current_conditional.elseStmts);

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_cond_else_if() -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_end_cond() -> Result {
		this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().subscopes.pop();
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_end_cond_set(const Instruction::EndCondSet& instr) -> Result {
		if(this->end_sub_scopes(this->get_location(instr.close_brace)).isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_begin_local_when_cond(const Instruction::BeginLocalWhenCond& instr) -> Result {
		TermInfo& cond = this->get_term_info(instr.cond_expr);

		if(this->type_check<true, true>(
			TypeManager::getTypeBool(), cond, "Condition in [when] condtional", instr.when_cond.cond
		).ok == false){
			return Result::ERROR;
		}

		const bool when_cond_value = this->context.getSemaBuffer().getBoolValue(cond.getExpr().boolValueID()).value;

		if(when_cond_value == false){
			this->symbol_proc.setInstructionIndex(instr.else_index);
		}

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_end_local_when_cond(const Instruction::EndLocalWhenCond& instr) -> Result {
		this->symbol_proc.setInstructionIndex(instr.end_index);
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_begin_while(const Instruction::BeginWhile& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.while_stmt).isError()){ return Result::ERROR; }

		TermInfo& cond_term_info = this->get_term_info(instr.cond_expr);

		if(
			cond_term_info.value_state != TermInfo::ValueState::INIT
			&& cond_term_info.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.while_stmt.cond,
				"Condition in [while] loop must be initialized"
			);
			return Result::ERROR;
		}

		if(this->type_check<true, true>(
			TypeManager::getTypeBool(), cond_term_info, "Condition in [while] loop", instr.while_stmt.cond
		).ok == false){
			return Result::ERROR;
		}

		const AST::Block& while_block = this->source.getASTBuffer().getBlock(instr.while_stmt.block);

		const sema::While::ID sema_while_id = this->context.sema_buffer.createWhile(
			cond_term_info.getExpr(), while_block.label
		);
		this->get_current_scope_level().stmtBlock().emplace_back(sema_while_id);

		sema::While& sema_while = this->context.sema_buffer.whiles[sema_while_id];
		if(while_block.label.has_value()){
			this->push_scope_level(sema_while.block, *while_block.label, sema_while_id);
		}else{
			this->push_scope_level(&sema_while.block);
		}

		this->get_current_scope_level().setIsLoopMainScope();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_end_while(const Instruction::EndWhile& instr) -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		if(this->end_sub_scopes(this->get_location(instr.close_brace)).isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_begin_for(const Instruction::BeginFor& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.for_stmt).isError()){ return Result::ERROR; }

		const bool in_comptime_func = this->get_current_func().attributes.isComptime;


		const AST::AttributeBlock& attribute_block =
			this->source.getASTBuffer().getAttributeBlock(instr.for_stmt.attributeBlock);

		if(attribute_block.attributes.empty() == false){
			const std::string_view first_attribute_str =
				this->source.getTokenBuffer()[attribute_block.attributes[0].attribute].getString();

			evo::debugAssert(first_attribute_str != "unroll", "Should be using unroll for instructions, not normal for");

			this->emit_error(
				Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
				attribute_block.attributes[0].attribute,
				std::format("Unknown [for] loop attribute #{}", first_attribute_str)
			);
			return Result::ERROR;
			
		}


		auto index_type_id = std::optional<TypeInfo::ID>();
		if(instr.for_stmt.index.has_value()){
			const TypeInfo::VoidableID got_index_type_id = this->get_type(instr.types[0]);

			if(this->context.getTypeManager().isIntegral(got_index_type_id) == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FOR_INDEX_NOT_INTEGRAL,
					instr.for_stmt.index->type,
					"Index of [for] loop must be integral"
				);
			}

			index_type_id = got_index_type_id.asTypeID();
		}



		BaseType::Interface* interface_iterable            = nullptr;
		BaseType::Interface* interface_iterable_ref        = nullptr;
		BaseType::Interface* interface_iterable_mut_ref    = nullptr;
		BaseType::Interface* interface_iterator            = nullptr;
		BaseType::Interface* interface_mut_iterator        = nullptr;
		BaseType::Interface* interface_iterable_rt         = nullptr;
		BaseType::Interface* interface_iterable_ref_rt     = nullptr;
		BaseType::Interface* interface_iterable_mut_ref_rt = nullptr;
		BaseType::Interface* interface_iterator_rt         = nullptr;
		BaseType::Interface* interface_mut_iterator_rt     = nullptr;
		{
			const BuiltinModule& pthr_module = this->context.getSourceManager()[BuiltinModule::ID::PTHR];

			const auto get_interface = [&](std::string_view interface_name) -> BaseType::Interface* {
				const std::optional<BuiltinModule::Symbol> symbol_find = pthr_module.getSymbol(interface_name);

				evo::debugAssert(symbol_find.has_value(), "Module @pthr does not have symbol \"{}\"", interface_name);
				evo::debugAssert(
					symbol_find->as<BaseType::ID>().kind() == BaseType::Kind::INTERFACE,
					"`@pthr.{}` is not an interface",
					interface_name
				);

				return &this->context.type_manager.getInterface(symbol_find->as<BaseType::ID>().interfaceID());
			};


			interface_iterable         = get_interface("Iterable");
			interface_iterable_ref     = get_interface("IterableRef");
			interface_iterable_mut_ref = get_interface("IterableMutRef");
			interface_iterator         = get_interface("Iterator");
			interface_mut_iterator     = get_interface("MutIterator");

			if(in_comptime_func == false){
				interface_iterable_rt         = get_interface("IterableRT");
				interface_iterable_ref_rt     = get_interface("IterableRefRT");
				interface_iterable_mut_ref_rt = get_interface("IterableMutRefRT");
				interface_iterator_rt         = get_interface("IteratorRT");
				interface_mut_iterator_rt     = get_interface("MutIteratorRT");
			}
		}


		enum class InterfaceKind{
			ITERABLE,
			ITERABLE_REF,
			ITERABLE_MUT_REF,
		};

		struct InterfaceToCheck{
			BaseType::Interface& interface;
			BaseType::Interface& iterator_interface;
			BaseType::Interface* auxiliary_interface;
			InterfaceKind kind;
		};

		auto iterables = evo::SmallVector<sema::For::Iterable>();
		auto param_type_ids = evo::SmallVector<TypeInfo::ID>();
		auto deduced_terms = evo::SmallVector<DeducerMatchOutput::DeducedTerm>();

		for(size_t i = 0; SymbolProc::TermInfoID iterable_id : instr.iterables){
			EVO_DEFER([&](){ i += 1; });

			const TermInfo& iterable = this->get_term_info(iterable_id);

			if(
				iterable.value_state != TermInfo::ValueState::INIT
				&& iterable.value_state != TermInfo::ValueState::NOT_APPLICABLE
			){
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					instr.for_stmt.iterables[i],
					"Iterable in [for] loop must be initialized"
				);
				return Result::ERROR;
			}


			if(iterable.type_id.is<TypeInfo::ID>() == false){
				auto infos = evo::SmallVector<Diagnostic::Info>();

				if(iterable.type_id.is<TermInfo::VariadicParamTypes>()){
					infos.emplace_back(
						"Variadic parameters can only be an interable in a [for] loop if the [for] loop is unrolled"
					);
					infos.emplace_back("Did you mean to give the [for] loop attribute `#unroll`?");
				}

				this->emit_error(
					Diagnostic::Code::SEMA_FOR_INVALID_ITERABLE,
					instr.for_stmt.iterables[i],
					"Invalid iterable in [for] loop",
					std::move(infos)
				);
				return Result::ERROR;
			}


			auto interfaces_to_check = evo::StaticVector<InterfaceToCheck, 6>();

			if(instr.for_stmt.values[i].isMut){
				if(in_comptime_func){
					interfaces_to_check.emplace_back(
						*interface_iterable, *interface_iterator, interface_mut_iterator, InterfaceKind::ITERABLE
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_mut_ref, *interface_mut_iterator, nullptr, InterfaceKind::ITERABLE_MUT_REF
					);
				}else{
					interfaces_to_check.emplace_back(
						*interface_iterable_rt,
						*interface_iterator_rt,
						interface_mut_iterator_rt,
						InterfaceKind::ITERABLE
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_mut_ref_rt,
						*interface_mut_iterator_rt,
						nullptr,
						InterfaceKind::ITERABLE_MUT_REF
					);

					interfaces_to_check.emplace_back(
						*interface_iterable, *interface_iterator, interface_mut_iterator, InterfaceKind::ITERABLE
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_mut_ref, *interface_mut_iterator, nullptr, InterfaceKind::ITERABLE_MUT_REF
					);
				}
			}else{
				if(in_comptime_func){
					interfaces_to_check.emplace_back(
						*interface_iterable, *interface_iterator, interface_mut_iterator, InterfaceKind::ITERABLE
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_ref, *interface_iterator, nullptr, InterfaceKind::ITERABLE_REF
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_mut_ref, *interface_mut_iterator, nullptr, InterfaceKind::ITERABLE_MUT_REF
					);

				}else{
					interfaces_to_check.emplace_back(
						*interface_iterable_rt,
						*interface_iterator_rt,
						interface_mut_iterator_rt,
						InterfaceKind::ITERABLE
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_ref_rt, *interface_iterator_rt, nullptr, InterfaceKind::ITERABLE_REF
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_mut_ref_rt,
						*interface_mut_iterator_rt,
						nullptr,
						InterfaceKind::ITERABLE_MUT_REF
					);

					interfaces_to_check.emplace_back(
						*interface_iterable, *interface_iterator, interface_mut_iterator, InterfaceKind::ITERABLE
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_ref, *interface_iterator, nullptr, InterfaceKind::ITERABLE_REF
					);

					interfaces_to_check.emplace_back( 
						*interface_iterable_mut_ref, *interface_mut_iterator, nullptr, InterfaceKind::ITERABLE_MUT_REF
					);
				}
			}


			const InterfaceToCheck* selected_interface = nullptr;
			for(const InterfaceToCheck& interface_to_check : interfaces_to_check){
				const evo::Expected<bool, Result> implements_result = this->type_implements_interface(
					interface_to_check.interface,
					iterable.type_id.as<TypeInfo::ID>(),
					this->get_location(instr.for_stmt.iterables[i])
				);

				if(implements_result.has_value()){
					if(implements_result.value()){
						selected_interface = &interface_to_check;
						break;

					}else{
						continue;
					}
					
				}else{
					return implements_result.error();
				}
			}

			if(selected_interface == nullptr){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				for(const InterfaceToCheck& interface_to_check : interfaces_to_check){
					infos.emplace_back(
						std::format(
							"Possible interface: @pthr.{}",
							interface_to_check.interface.getName(this->context.getSourceManager())
						)
					);
				}

				this->emit_error(
					Diagnostic::Code::SEMA_FOR_ITERABLE_DOESNT_IMPLEMENT_INTERFACE,
					instr.for_stmt.iterables[i],
					"Iterable in [for] loop does not implement any of the possible interface in this context",
					std::move(infos)
				);
				return Result::ERROR;
			}


			//////////////////
			// check iterator mut (if not caught already)

			if(selected_interface->kind == InterfaceKind::ITERABLE){
				if(instr.for_stmt.values[i].isMut && iterable.is_mutable() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FOR_ITERABLE_NOT_MUT_WHEN_PARAM_IS,
						instr.for_stmt.iterables[i],
						"Iterable in [for] loop is not mutable",
						Diagnostic::Info(
							"Required to be mutable by value parameter",
							this->get_location(instr.for_stmt.values[i].ident)
						)
					);
					return Result::ERROR;
				}
			}


			//////////////////
			// get iterator impls

			const BaseType::Interface::Impl& iterable_impl = [&]() -> const BaseType::Interface::Impl& {
				const auto lock = std::scoped_lock(selected_interface->interface.implsLock);
				return selected_interface->interface.impls.at(iterable.type_id.as<TypeInfo::ID>());
			}();

			{ // check if impl def completed
				const std::optional<SymbolProc::ID> instantiating_symbol_proc_id =
					iterable_impl.instantiatingSymbolProc.load(std::memory_order::relaxed);

				if(instantiating_symbol_proc_id.has_value()){
					const SymbolProc::WaitOnResult wait_on_result = this->context.symbol_proc_manager
						.getSymbolProc(*instantiating_symbol_proc_id)
						.waitOnDefIfNeeded(this->symbol_proc_id, this->context, *instantiating_symbol_proc_id);

					switch(wait_on_result){
						case SymbolProc::WaitOnResult::NOT_NEEDED:                 break;
						case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
							this->context.symbol_proc_manager.symbol_proc_unsuspended();
							this->context.add_task_to_work_manager(*instantiating_symbol_proc_id);
							[[fallthrough]];
						}
						case SymbolProc::WaitOnResult::WAITING:                    return Result::NEED_TO_WAIT;
						case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
						case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: evo::debugFatalBreak("Not possible");
						case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
					}
				}
			}


			const size_t create_iterator_func_index = [&]() -> size_t {
				if(selected_interface->kind == InterfaceKind::ITERABLE){
					return size_t(instr.for_stmt.values[i].isMut);
				}else{
					return 0;
				}
			}();


			const TypeInfo::ID created_iterator_type_id = [&]() -> TypeInfo::ID {
				const sema::Func& create_iterator_func =
					this->context.getSemaBuffer().getFunc(iterable_impl.methods[create_iterator_func_index]);

				const BaseType::Function& create_iterator_func_type =
					this->context.getTypeManager().getFunction(create_iterator_func.typeID);

				const TypeInfo::ID created_iterator_map_type_id =
					create_iterator_func_type.returnTypes[0].asTypeID();

				const TypeInfo& created_iterator_map_type_info =
					this->context.getTypeManager().getTypeInfo(created_iterator_map_type_id);

				const BaseType::InterfaceMap& created_iterator_map_type = 
					this->context.getTypeManager().getInterfaceMap(
						created_iterator_map_type_info.baseTypeID().interfaceMapID()
					);

				return created_iterator_map_type.underlyingTypeID;
			}();

			const BaseType::Interface::Impl& iterator_impl = [&]() -> const BaseType::Interface::Impl& {
				if(create_iterator_func_index == 0){
					const auto lock = std::scoped_lock(selected_interface->iterator_interface.implsLock);
					return selected_interface->iterator_interface.impls.at(created_iterator_type_id);
				}else{
					const auto lock = std::scoped_lock(selected_interface->auxiliary_interface->implsLock);
					return selected_interface->auxiliary_interface->impls.at(created_iterator_type_id);
				}
			}();


			//////////////////
			// check param type

			const sema::Func& get_func = this->context.getSemaBuffer().getFunc(iterator_impl.methods[1]);
			const BaseType::Function& get_func_type =
				this->context.getTypeManager().getFunction(get_func.typeID);
			const TypeInfo::ID get_func_ret_type = get_func_type.returnTypes[0].asTypeID();


			const TypeInfo::ID iterator_get_type_id = this->context.type_manager.getOrCreateTypeInfo(
				this->context.getTypeManager().getTypeInfo(get_func_ret_type).copyWithPoppedQualifier()
			);

			const TypeInfo::VoidableID got_type_id =
				this->get_type(instr.types[i + size_t(instr.for_stmt.index.has_value())]);




			const auto for_param_type_mismatch = [&]() -> void {
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(iterator_get_type_id, infos, "Expected type: ");
				this->diagnostic_print_type_info(got_type_id, infos, "Got type:      ");
				this->emit_error(
					Diagnostic::Code::SEMA_FOR_INVALID_PARAM_TYPE,
					instr.for_stmt.values[i].type,
					"Invalid [for] loop value parameter type",
					std::move(infos)
				);
			};

			if(got_type_id == iterator_get_type_id){
				param_type_ids.emplace_back(got_type_id.asTypeID());

			}else if(got_type_id.isVoid()){
				for_param_type_mismatch();
				return Result::ERROR;

			}else if(
				const TypeInfo::ID got_decayed_type =
					this->context.type_manager.decayType<false, false>(got_type_id.asTypeID());
				got_decayed_type == this->context.type_manager.decayType<false, false>(iterator_get_type_id)
			){
				param_type_ids.emplace_back(got_decayed_type);

			}else if(this->context.getTypeManager().isTypeDeducer(got_type_id.asTypeID()) == false){
				for_param_type_mismatch();
				return Result::ERROR;

			}else{
				DeducerMatchOutput deducer_match_output = 
					this->deducer_matches_and_extract(got_type_id.asTypeID(), iterator_get_type_id);

				switch(deducer_match_output.outcome()){
					case DeducerMatchOutput::Outcome::MATCH: {
						deduced_terms.append_range(std::move(deducer_match_output.deducedTerms()));
						param_type_ids.emplace_back(deducer_match_output.resultantTypeID());
					} break;

					case DeducerMatchOutput::Outcome::NO_MATCH: {
						for_param_type_mismatch();
						return Result::ERROR;
					} break;

					case DeducerMatchOutput::Outcome::RESULT: {
						return deducer_match_output.result();
					} break;
				}
			}

			

			//////////////////
			// iterable passed

			if(in_comptime_func){
				SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();

				func_info.dependent_funcs.emplace(iterable_impl.methods[create_iterator_func_index]);
				func_info.dependent_funcs.emplace(iterator_impl.methods[0]);
				func_info.dependent_funcs.emplace(iterator_impl.methods[1]);
				func_info.dependent_funcs.emplace(iterator_impl.methods[2]);
			}

			iterables.emplace_back(
				iterable.getExpr(), iterable_impl.methods[create_iterator_func_index], iterator_impl
			);
		}



		const AST::Block& for_block = this->source.getASTBuffer().getBlock(instr.for_stmt.block);


		const sema::For::ID sema_for_id = this->context.sema_buffer.createFor(
			std::move(iterables), for_block.label, index_type_id.has_value()
		);
		this->get_current_scope_level().stmtBlock().emplace_back(sema_for_id);

		sema::For& sema_for = this->context.sema_buffer.fors[sema_for_id];
		if(for_block.label.has_value()){
			this->push_scope_level(sema_for.block, *for_block.label, sema_for_id);
		}else{
			this->push_scope_level(&sema_for.block);
		}


		if(index_type_id.has_value()){
			const std::string_view index_ident_str =
				this->source.getTokenBuffer()[instr.for_stmt.index->ident].getString();

			const sema::ForParam::ID created_sema_id =
				this->context.sema_buffer.createForParam(instr.for_stmt.index->ident, *index_type_id, true, false);

			if(this->add_ident_to_scope(index_ident_str, instr.for_stmt.index->ident, true, created_sema_id).isError()){
				return Result::ERROR;
			}

			sema_for.params.emplace_back(instr.for_stmt.index->ident, *index_type_id, sema::Expr(created_sema_id));
		}


		for(size_t i = 0; i < instr.for_stmt.values.size(); i+=1){
			const Token::ID value_ident_tok_id = instr.for_stmt.values[i].ident;

			const std::string_view index_ident_str =
				this->source.getTokenBuffer()[value_ident_tok_id].getString();

			const sema::ForParam::ID created_sema_id = this->context.sema_buffer.createForParam(
				value_ident_tok_id, param_type_ids[i], false, instr.for_stmt.values[i].isMut
			);

			if(this->add_ident_to_scope(index_ident_str, value_ident_tok_id, true, created_sema_id).isError()){
				return Result::ERROR;
			}

			sema_for.params.emplace_back(value_ident_tok_id, param_type_ids[i], sema::Expr(created_sema_id));
		}

		if(this->add_deduced_terms_to_scope(deduced_terms).isError()){
			return Result::ERROR;
		}


		this->get_current_scope_level().setIsLoopMainScope();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_end_for(const Instruction::EndFor& instr) -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		if(this->end_sub_scopes(this->get_location(instr.close_brace)).isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_begin_for_unroll(const Instruction::BeginForUnroll& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.for_stmt).isError()){ return Result::ERROR; }

		const AST::AttributeBlock& attribute_block =
			this->source.getASTBuffer().getAttributeBlock(instr.for_stmt.attributeBlock);

		for(const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "unroll"){ continue; }

			this->emit_error(
				Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
				attribute.attribute,
				std::format("Unknown [for] loop attribute #{}", attribute_str)
			);
			return Result::ERROR;
		}

		if(instr.index_type_id.has_value()){
			if(this->context.getTypeManager().isIntegral(this->get_type(*instr.index_type_id)) == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FOR_INDEX_NOT_INTEGRAL,
					instr.for_stmt.index->type,
					"Index of [for] loop must be integral"
				);
			}
			return Result::ERROR;
		}

		auto iterables_size = std::optional<size_t>();
		for(size_t i = 0; SymbolProc::TermInfoID iterable_id : instr.iterables){
			EVO_DEFER([&](){ i += 1; });

			const TermInfo& iterable = this->get_term_info(iterable_id);

			if(iterable.value_category != TermInfo::ValueCategory::VARIADIC_PARAM){
				this->emit_error(
					Diagnostic::Code::SEMA_FOR_INVALID_ITERABLE,
					instr.for_stmt.iterables[i],
					"Invalid iterable in unrolled [for] loop"
				);
				return Result::ERROR;
			}

			if(iterables_size.has_value()){
				if(*iterables_size != iterable.type_id.as<TermInfo::VariadicParamTypes>().type_ids.size()){
					this->emit_error(
						Diagnostic::Code::SEMA_FOR_INVALID_ITERABLE,
						instr.for_stmt.iterables[i],
						"Iterable in unrolled [for] loop is a different size"
					);
					return Result::ERROR;
				}

			}else{
				iterables_size = iterable.type_id.as<TermInfo::VariadicParamTypes>().type_ids.size();
			}
		}

		const AST::Block& for_block = this->source.getASTBuffer().getBlock(instr.for_stmt.block);

		const sema::ForUnroll::ID sema_for_unroll_id = this->context.sema_buffer.createForUnroll(
			for_block.label, evo::SmallVector<sema::StmtBlock>(*iterables_size)
		);
		this->get_current_scope_level().stmtBlock().emplace_back(sema_for_unroll_id);

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_for_unroll_cond(const Instruction::ForUnrollCond& instr) -> Result {
		const TermInfo& first_iterable = this->get_term_info(instr.iterables[0]);
		if(first_iterable.type_id.as<TermInfo::VariadicParamTypes>().type_ids.size() == instr.get_index()){
			this->symbol_proc.setInstructionIndex(instr.end_index);
			return Result::SUCCESS;
		}


		// this needs to be done BEFORE pushing scope in case needs to wait
		auto deduced_terms = evo::SmallVector<DeducerMatchOutput::DeducedTerm>();
		auto param_type_ids = evo::SmallVector<TypeInfo::ID>();
		for(size_t i = 0; const SymbolProc::TermInfoID& iterable_id : instr.iterables){
			const TermInfo& iterable = this->get_term_info(iterable_id);

			const TypeInfo::VoidableID for_param_type =
				this->get_type(instr.types[i + size_t(instr.for_stmt.index.has_value())]);
			const TypeInfo::ID variadic_param_type =
				iterable.type_id.as<TermInfo::VariadicParamTypes>().type_ids[instr.get_index()];

			const auto for_param_type_mismatch = [&]() -> void {
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(variadic_param_type, infos, "Expected type: ");
				this->diagnostic_print_type_info(for_param_type, infos, "Got type:      ");
				this->emit_error(
					Diagnostic::Code::SEMA_FOR_INVALID_PARAM_TYPE,
					instr.for_stmt.values[i].type,
					"Invalid [for] loop value parameter type",
					std::move(infos)
				);
			};

			if(for_param_type == variadic_param_type){
				param_type_ids.emplace_back(for_param_type.asTypeID());

			}else if(for_param_type.isVoid()){
				for_param_type_mismatch();
				return Result::ERROR;

			}else if(
				const TypeInfo::ID got_decayed_type =
					this->context.type_manager.decayType<false, false>(for_param_type.asTypeID());
				got_decayed_type == this->context.type_manager.decayType<false, false>(variadic_param_type)
			){
				param_type_ids.emplace_back(got_decayed_type);

			}else if(this->context.getTypeManager().isTypeDeducer(for_param_type.asTypeID()) == false){
				for_param_type_mismatch();
				return Result::ERROR;

			}else{
				DeducerMatchOutput deducer_match_output = 
					this->deducer_matches_and_extract(for_param_type.asTypeID(), variadic_param_type);

				switch(deducer_match_output.outcome()){
					case DeducerMatchOutput::Outcome::MATCH: {
						deduced_terms.append_range(std::move(deducer_match_output.deducedTerms()));
						param_type_ids.emplace_back(deducer_match_output.resultantTypeID());
					} break;

					case DeducerMatchOutput::Outcome::NO_MATCH: {
						for_param_type_mismatch();
						return Result::ERROR;
					} break;

					case DeducerMatchOutput::Outcome::RESULT: {
						return deducer_match_output.result();
					} break;
				}
			}

			i += 1;
		}




		{
			const sema::Stmt current_for_unroll_stmt = this->get_current_scope_level().stmtBlock().back();
			sema::ForUnroll& current_for_unroll =
				this->context.sema_buffer.for_unrolls[current_for_unroll_stmt.forUnrollID()];

			if(current_for_unroll.label.has_value()){
				this->push_scope_level(
					current_for_unroll.stmtBlocks[instr.get_index()],
					*current_for_unroll.label,
					current_for_unroll_stmt.forUnrollID()
				);
			}else{
				this->push_scope_level(&current_for_unroll.stmtBlocks[instr.get_index()]);
			}
		}


		const BaseType::Function& current_func_type =
			this->context.getTypeManager().getFunction(this->get_current_func().typeID);

		const BaseType::Function::Param::Kind variadic_param_kind = current_func_type.params.back().kind;


		for(size_t i = 0; const SymbolProc::TermInfoID& iterable_id : instr.iterables){
			EVO_DEFER([&](){ i += 1; });

			const TermInfo& iterable = this->get_term_info(iterable_id);
			evo::debugAssert(iterable.isVariadicParam(), "Unknown unroll for iterable");

			// const sema::VariadicParam& variadic_param =
			// 	this->context.getSemaBuffer().getVariadicParam(iterable.getVariadicParam().variadicParamID());


			const bool for_param_is_mut = instr.for_stmt.values[i].isMut;

			if(for_param_is_mut & (variadic_param_kind == BaseType::Function::Param::Kind::READ)){
				this->emit_error(
					Diagnostic::Code::SEMA_FOR_ITERABLE_NOT_MUT_WHEN_PARAM_IS,
					instr.for_stmt.iterables[i],
					"Iterable in [for] loop is not mutable",
					Diagnostic::Info(
						"Required to be mutable by value parameter",
						this->get_location(instr.for_stmt.values[i].ident)
					)
				);
				return Result::ERROR;
			}


			const Token::ID for_param_ident_token_id = instr.for_stmt.values[i].ident; 
			const std::string_view for_param_ident_str =
				this->source.getTokenBuffer()[for_param_ident_token_id].getString();

			const sema::Param::ID sema_param_id = 
				this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().actual_variadic_params[instr.get_index()];

			const auto extracted_variadic_param =
				sema::ScopeLevel::ExtractedVariadicParam(sema_param_id, param_type_ids[i], for_param_is_mut);

			if(this->add_ident_to_scope(
				for_param_ident_str, for_param_ident_token_id, true, extracted_variadic_param
			).isError()){
				return Result::ERROR;
			}

			switch(this->get_ident_value_state(sema_param_id)){
				case TermInfo::ValueState::NOT_APPLICABLE: {
					evo::debugFatalBreak("Shouldn't be possible to be not applicable value state");
				} break;

				case TermInfo::ValueState::INIT: {
					// do nothing
				} break;

				case TermInfo::ValueState::INITIALIZING: {
					evo::debugFatalBreak("Shouldn't be possible to be initializing");
				} break;

				case TermInfo::ValueState::UNINIT: {
					this->emit_error(
						Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
						for_param_ident_token_id,
						std::format("Variadic parameter index {} was uninitialized", i)
					);
					return Result::ERROR;
				} break;

				case TermInfo::ValueState::MOVED_FROM: {
					this->emit_error(
						Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
						for_param_ident_token_id,
						std::format("Variadic parameter index {} was moved from", i)
					);
					return Result::ERROR;
				} break;
			}
		}

		// add index to scope (if exists)
		if(instr.for_stmt.index.has_value()){
			const Token::ID index_ident_token_id = instr.for_stmt.index->ident;
			const std::string_view index_ident_str = this->source.getTokenBuffer()[index_ident_token_id].getString();

			const TypeInfo::ID index_type_id = this->get_type(instr.types[0]).asTypeID();
			const BaseType::ID index_base_type_id =
				this->context.getTypeManager().getTypeInfo(index_type_id).baseTypeID();

			const unsigned index_type_num_bits = unsigned(this->context.getTypeManager().numBits(index_base_type_id));
			const bool is_signed = this->context.getTypeManager().isSignedIntegral(index_base_type_id);

			if(this->add_ident_to_scope(
				index_ident_str,
				index_ident_token_id,
				true,
				sema::ScopeLevel::ForUnrollIndexFlag{},
				index_type_id,
				sema::Expr(
					this->context.sema_buffer.createIntValue(
						core::GenericInt(index_type_num_bits, instr.get_index(), is_signed),
						index_base_type_id
					)
				),
				index_ident_token_id
			).isError()){
				return Result::ERROR;
			}
		}


		this->get_current_scope_level().setIsLoopMainScope();

		if(this->add_deduced_terms_to_scope(deduced_terms).isError()){ return Result::ERROR; }

		instr.next_index();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_for_unroll_continue(const Instruction::ForUnrollContinue& instr) -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		if(this->end_sub_scopes(this->get_location(instr.close_brace)).isError()){ return Result::ERROR; }

		this->symbol_proc.setInstructionIndex(instr.cond_index);

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_begin_switch(const Instruction::BeginSwitch& instr) -> Result {
		const TermInfo& cond = this->get_term_info(instr.cond);

		const evo::Result<SwitchAttrs> switch_attrs =
			this->analyze_switch_attrs(instr.switch_stmt, instr.attribute_params_info);
		if(switch_attrs.isError()){ return Result::ERROR; }



		if(cond.type_id.is<TypeInfo::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_SWITCH_INVALID_COND,
				instr.switch_stmt.cond,

				"Invalid condition value in [switch] statement"
			);
			return Result::ERROR;
		}

		const TypeInfo::ID cond_type_id = cond.type_id.as<TypeInfo::ID>();
		const TypeInfo::ID decayed_cond_type_id = this->context.type_manager.decayType<true, false>(cond_type_id);
		const TypeInfo& decayed_cond_type = this->context.getTypeManager().getTypeInfo(decayed_cond_type_id);


		if(instr.is_no_jump){
			// TODO(FUTURE): when structs can delete ==

		}else{
			if(decayed_cond_type.qualifiers().empty() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_SWITCH_INVALID_COND,
					instr.switch_stmt.cond,
					"Invalid condition value in [switch] statement",
					Diagnostic::Info(
						"NOTE: the type of a condition value of a [switch] statement without attribute `#noJump` "
							"cannot have qualifiers"
					)
				);
				return Result::ERROR;
			}
				

			switch(decayed_cond_type.baseTypeID().kind()){
				case BaseType::Kind::PRIMITIVE: {
					const BaseType::Primitive& primitive_type =
						this->context.getTypeManager().getPrimitive(decayed_cond_type.baseTypeID().primitiveID());
					
					switch(primitive_type.kind()){
						case Token::Kind::TYPE_INT:          case Token::Kind::TYPE_ISIZE:
						case Token::Kind::TYPE_I_N:          case Token::Kind::TYPE_UINT:
						case Token::Kind::TYPE_USIZE:        case Token::Kind::TYPE_UI_N:
						case Token::Kind::TYPE_BYTE:         case Token::Kind::TYPE_BOOL:
						case Token::Kind::TYPE_CHAR:         case Token::Kind::TYPE_TYPEID:
						case Token::Kind::TYPE_C_WCHAR:      case Token::Kind::TYPE_C_SHORT:
						case Token::Kind::TYPE_C_USHORT:     case Token::Kind::TYPE_C_INT:
						case Token::Kind::TYPE_C_UINT:       case Token::Kind::TYPE_C_LONG:
						case Token::Kind::TYPE_C_ULONG:      case Token::Kind::TYPE_C_LONG_LONG:
						case Token::Kind::TYPE_C_ULONG_LONG: {
							// valid
						} break;

						case Token::Kind::TYPE_F16:    case Token::Kind::TYPE_BF16:
						case Token::Kind::TYPE_F32:    case Token::Kind::TYPE_F64:
						case Token::Kind::TYPE_F80:    case Token::Kind::TYPE_F128:
						case Token::Kind::TYPE_C_LONG_DOUBLE: {
							this->emit_error(
								Diagnostic::Code::SEMA_SWITCH_INVALID_COND,
								instr.switch_stmt.cond,
								"Invalid condition value in [switch] statement",
								Diagnostic::Info(
									"NOTE: the type of a condition value of a [switch] statement without attribute "
										"`#noJump` cannot be floating point"
								)
							);
							return Result::ERROR;
						} break;

						case Token::Kind::TYPE_RAWPTR: {
							this->emit_error(
								Diagnostic::Code::SEMA_SWITCH_INVALID_COND,
								instr.switch_stmt.cond,
								"Invalid condition value in [switch] statement",
								Diagnostic::Info(
									"NOTE: the type of a condition value of a [switch] statement without attribute "
										"`#noJump` cannot be a pointer"
								)
							);
							return Result::ERROR;
						} break;

						default: evo::debugFatalBreak("Not a type");
					}
				} break;

				case BaseType::Kind::UNION: {
					const BaseType::Union& union_type =
						this->context.getTypeManager().getUnion(decayed_cond_type.baseTypeID().unionID());

					if(union_type.isUntagged){
						this->emit_error(
							Diagnostic::Code::SEMA_SWITCH_INVALID_COND,
							instr.switch_stmt.cond,
							"Invalid condition value in [switch] statement",
							Diagnostic::Info(
								"NOTE: a union expression can only be the condition value of a [switch] statement"
									"if it is tagged"
							)
						);
						return Result::ERROR;
					}
				} break;

				case BaseType::Kind::ENUM: {
					// valid
				} break;

				default: {
					this->emit_error(
						Diagnostic::Code::SEMA_SWITCH_INVALID_COND,
						instr.switch_stmt.cond,
						"Invalid condition value in [switch] statement"
					);
					return Result::ERROR;
				} break;
			}
		}


		const sema::Switch::Kind switch_kind = [&]() -> sema::Switch::Kind {
			if(instr.is_no_jump){
				return sema::Switch::Kind::NO_JUMP;

			}else if(switch_attrs.value().is_partial){
				return sema::Switch::Kind::PARTIAL;

			}else{
				return sema::Switch::Kind::COMPLETE;
			}
		}();

		const sema::Switch::ID created_switch_id = this->context.sema_buffer.createSwitch(
			cond_type_id,
			cond.getExpr(),
			evo::SmallVector<sema::Switch::Case>(instr.switch_stmt.cases.size()),
			switch_kind
		);

		this->get_current_scope_level().stmtBlock().emplace_back(created_switch_id);

		this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().subscopes.emplace(created_switch_id);

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_begin_case(const Instruction::BeginCase& instr) -> Result {
		const sema::Switch::ID current_switch_id =
			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().subscopes.top().switchID();

		sema::Switch& current_switch = this->context.sema_buffer.switches[current_switch_id];
		sema::Switch::Case& current_case = current_switch.cases[instr.index];

		const TypeInfo::ID decay_cond_type_id =
			this->context.type_manager.decayType<false, false>(current_switch.condTypeID);
		const TypeInfo& decay_cond_type = this->context.getTypeManager().getTypeInfo(decay_cond_type_id);
		const bool cond_type_is_union = decay_cond_type.baseTypeID().kind() == BaseType::Kind::UNION;

		for(const SymbolProc::TermInfoID value_id : instr.values){
			TermInfo& value = this->get_term_info(value_id);

			if(value.value_category == TermInfo::ValueCategory::TAGGED_UNION_FIELD_ACCESSOR){
				if(cond_type_is_union == false){
					this->emit_error(
						Diagnostic::Code::SEMA_SWITCH_INVALID_CASE_VALUE,
						instr.switch_case.values[current_case.values.size()],
						"This expression is not a valid case value in this [switch] statement"
					);
					return Result::ERROR;
				}

				const TermInfo::TaggedUnionFieldAccessor& tagged_union_field_accessor =
					value.type_id.as<TermInfo::TaggedUnionFieldAccessor>();

				if(tagged_union_field_accessor.union_id != decay_cond_type.baseTypeID().unionID()){
					this->emit_error(
						Diagnostic::Code::SEMA_SWITCH_INVALID_CASE_VALUE,
						instr.switch_case.values[current_case.values.size()],
						"This expression is not a valid case value in this [switch] statement"
					);
					return Result::ERROR;
				}

				const BaseType::Union& union_type =
					this->context.getTypeManager().getUnion(decay_cond_type.baseTypeID().unionID());

				const unsigned union_type_tag_bit_width = std::bit_ceil(unsigned(union_type.fields.size()));

				current_case.values.emplace_back(
					sema::Expr(
						this->context.sema_buffer.createIntValue(
							core::GenericInt(union_type_tag_bit_width, tagged_union_field_accessor.field_index),
							this->context.type_manager.getOrCreatePrimitiveBaseType(
								Token::Kind::TYPE_UI_N, union_type_tag_bit_width
							)
						)
					)
				);

			}else{
				if(cond_type_is_union){
					this->emit_error(
						Diagnostic::Code::SEMA_SWITCH_INVALID_CASE_VALUE,
						instr.switch_case.values[current_case.values.size()],
						"This expression is not a valid case value in this [switch] statement"
					);
					return Result::ERROR;
				}

				if(this->type_check<true, true>(
					current_switch.condTypeID,
					value,
					"Switch case value",
					instr.switch_case.values[current_case.values.size()]
				).ok == false){
					return Result::ERROR;
				}

				current_case.values.emplace_back(value.getExpr());
			}

		}

		this->push_scope_level(&current_case.stmtBlock);

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_end_case() -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_end_switch(const Instruction::EndSwitch& instr) -> Result {
		const sema::Switch::ID current_switch_id =
			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().subscopes.top().switchID();

		sema::Switch& current_switch = this->context.sema_buffer.switches[current_switch_id];

		if(current_switch.kind != sema::Switch::Kind::NO_JUMP){
			auto else_index = std::optional<size_t>();;

			auto used_values = std::unordered_set<core::GenericValue>();

			for(size_t i = 0; const sema::Switch::Case& switch_case : current_switch.cases){
				if(switch_case.values.empty()){
					else_index = i;
					continue;
				}

				for(size_t j = 0; sema::Expr value : switch_case.values){
					if(used_values.emplace(this->sema_expr_to_generic_value(value)).second == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SWITCH_VALUE_REUSE,
							instr.switch_stmt.cases[i].values[j],
							"This case value in this [switch] statement was already used"
						);
						return Result::ERROR;
					}

					j += 1;
				}

				i += 1;
			}

			const TypeInfo::ID decayed_cond_type_id =
				this->context.type_manager.decayType<false, false>(current_switch.condTypeID);
			const TypeInfo& decayed_cond_type = this->context.getTypeManager().getTypeInfo(decayed_cond_type_id);
			evo::debugAssert(
				decayed_cond_type.qualifiers().empty(), "switch cond without #noJump cannot have qualifiers"
			);

			switch(decayed_cond_type.baseTypeID().kind()){
				case BaseType::Kind::PRIMITIVE: {
					const BaseType::Primitive& primitive_type =
						this->context.getTypeManager().getPrimitive(decayed_cond_type.baseTypeID().primitiveID());
					
					switch(primitive_type.kind()){
						case Token::Kind::TYPE_INT:          case Token::Kind::TYPE_ISIZE:
						case Token::Kind::TYPE_I_N:          case Token::Kind::TYPE_UINT:
						case Token::Kind::TYPE_USIZE:        case Token::Kind::TYPE_UI_N:
						case Token::Kind::TYPE_BYTE:         case Token::Kind::TYPE_TYPEID:
						case Token::Kind::TYPE_C_WCHAR:      case Token::Kind::TYPE_C_SHORT:
						case Token::Kind::TYPE_C_USHORT:     case Token::Kind::TYPE_C_INT:
						case Token::Kind::TYPE_C_UINT:       case Token::Kind::TYPE_C_LONG:
						case Token::Kind::TYPE_C_ULONG:      case Token::Kind::TYPE_C_LONG_LONG:
						case Token::Kind::TYPE_C_ULONG_LONG: {
							const size_t bit_width =
								this->context.getTypeManager().numBits(decayed_cond_type.baseTypeID(), false);

							const size_t expected_num_cases = size_t(1) << bit_width; // 0 means > 2^64

							if(else_index.has_value()){
								if(used_values.size() == expected_num_cases && used_values.size() != 0){
									this->emit_error(
										Diagnostic::Code::SEMA_SWITCH_EXTRANEOUS_ELSE,
										instr.switch_stmt.cases[*else_index].block,
										"Extraneous [else] in [switch] statement"
									);
									return Result::ERROR;
								}
								
							}else{
								if(
									current_switch.kind == sema::Switch::Kind::COMPLETE
									&& used_values.size() != expected_num_cases
									&& used_values.size() != 0
								){
									const size_t num_missing = expected_num_cases - used_values.size();

									if(num_missing == 1){
										this->emit_error(
											Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
											instr.switch_stmt,
											std::format("Missing 1 case in [switch] statement", num_missing)
										);
										return Result::ERROR;
										
									}else{
										this->emit_error(
											Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
											instr.switch_stmt,
											std::format("Missing {} cases in [switch] statement", num_missing)
										);
										return Result::ERROR;
									}
								}
							}
						} break;

						case Token::Kind::TYPE_CHAR: {
							if(else_index.has_value()){
								if(used_values.size() == 256){
									this->emit_error(
										Diagnostic::Code::SEMA_SWITCH_EXTRANEOUS_ELSE,
										instr.switch_stmt.cases[*else_index].block,
										"Extraneous [else] in [switch] statement"
									);
									return Result::ERROR;
								}
								
							}else{
								if(
									current_switch.kind == sema::Switch::Kind::COMPLETE
									&& used_values.size() != 256
								){
									const size_t num_missing = 256 - used_values.size();

									if(num_missing == 1){
										this->emit_error(
											Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
											instr.switch_stmt,
											std::format("Missing 1 case in [switch] statement", num_missing)
										);
										return Result::ERROR;
										
									}else{
										this->emit_error(
											Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
											instr.switch_stmt,
											std::format("Missing {} cases in [switch] statement", num_missing)
										);
										return Result::ERROR;
									}
								}
							}
						} break;

						case Token::Kind::TYPE_BOOL: {
							if(else_index.has_value()){
								if(used_values.size() == 2){
									this->emit_error(
										Diagnostic::Code::SEMA_SWITCH_EXTRANEOUS_ELSE,
										instr.switch_stmt.cases[*else_index].block,
										"Extraneous [else] in [switch] statement"
									);
									return Result::ERROR;
								}
								
							}else{
								if(
									current_switch.kind == sema::Switch::Kind::COMPLETE
									&& used_values.size() != 2
								){
									const size_t num_missing = 2 - used_values.size();

									if(num_missing == 1){
										this->emit_error(
											Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
											instr.switch_stmt,
											std::format("Missing 1 case in [switch] statement", num_missing)
										);
										return Result::ERROR;
										
									}else{
										this->emit_error(
											Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
											instr.switch_stmt,
											std::format("Missing {} cases in [switch] statement", num_missing)
										);
										return Result::ERROR;
									}
								}
							}
						} break;

						case Token::Kind::TYPE_F16:    case Token::Kind::TYPE_BF16:
						case Token::Kind::TYPE_F32:    case Token::Kind::TYPE_F64:
						case Token::Kind::TYPE_F80:    case Token::Kind::TYPE_F128:
						case Token::Kind::TYPE_RAWPTR: case Token::Kind::TYPE_C_LONG_DOUBLE: {
							evo::debugFatalBreak("Invalid switch cond type (base type)");
						} break;

						default: evo::debugFatalBreak("Not a type");
					}
				} break;

				case BaseType::Kind::UNION: {
					const BaseType::Union& union_type =
						this->context.getTypeManager().getUnion(decayed_cond_type.baseTypeID().unionID());

					evo::debugAssert(union_type.isUntagged == false, "Invalid switch cond type (base type)");

					if(else_index.has_value()){
						if(used_values.size() == union_type.fields.size()){
							this->emit_error(
								Diagnostic::Code::SEMA_SWITCH_EXTRANEOUS_ELSE,
								instr.switch_stmt.cases[*else_index].block,
								"Extraneous [else] in [switch] statement"
							);
							return Result::ERROR;
						}
						
					}else{
						if(
							current_switch.kind == sema::Switch::Kind::COMPLETE
							&& used_values.size() != union_type.fields.size()
						){
							const size_t num_missing = union_type.fields.size() - used_values.size();

							if(num_missing == 1){
								this->emit_error(
									Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
									instr.switch_stmt,
									std::format("Missing 1 case in [switch] statement", num_missing)
								);
								return Result::ERROR;
								
							}else{
								this->emit_error(
									Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
									instr.switch_stmt,
									std::format("Missing {} cases in [switch] statement", num_missing)
								);
								return Result::ERROR;
							}
						}
					}
				} break;

				case BaseType::Kind::ENUM: {
					const BaseType::Enum& enum_type =
						this->context.getTypeManager().getEnum(decayed_cond_type.baseTypeID().enumID());

					if(else_index.has_value()){
						if(used_values.size() == enum_type.enumerators.size()){
							this->emit_error(
								Diagnostic::Code::SEMA_SWITCH_EXTRANEOUS_ELSE,
								instr.switch_stmt.cases[*else_index].block,
								"Extraneous [else] in [switch] statement"
							);
							return Result::ERROR;
						}
						
					}else{
						if(
							current_switch.kind == sema::Switch::Kind::COMPLETE
							&& used_values.size() != enum_type.enumerators.size()
						){
							const size_t num_missing = enum_type.enumerators.size() - used_values.size();

							if(num_missing == 1){
								this->emit_error(
									Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
									instr.switch_stmt,
									std::format("Missing 1 case in [switch] statement", num_missing)
								);
								return Result::ERROR;
								
							}else{
								this->emit_error(
									Diagnostic::Code::SEMA_SWITCH_MISSING_CASE,
									instr.switch_stmt,
									std::format("Missing {} cases in [switch] statement", num_missing)
								);
								return Result::ERROR;
							}
						}
					}
				} break;

				default: {
					evo::debugFatalBreak("Invalid switch cond type (base type)");
				} break;
			}
		}else{
			this->emit_error(
				Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
				instr.switch_stmt,
				"Switch statements with `#noJump` are currently unimplemented"
			);
			return Result::ERROR;
		}


		this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().subscopes.pop();

		if(this->end_sub_scopes(this->get_location(instr.switch_stmt.closeBrace)).isError()){ return Result::ERROR; }


		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_begin_defer(const Instruction::BeginDefer& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.defer_stmt).isError()){ return Result::ERROR; }

		const bool is_error_defer = 
			this->source.getTokenBuffer()[instr.defer_stmt.keyword].kind() == Token::Kind::KEYWORD_ERROR_DEFER;

		if(
			is_error_defer &&
			this->context.getTypeManager().getFunction(this->get_current_func().typeID).hasErrorReturn() == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_ERROR_DEFER_IN_NON_ERRORING_FUNC,
				instr.defer_stmt,
				"Functions that do not error cannot have [errorDefer] statements"
			);
			return Result::ERROR;
		}


		const sema::Defer::ID sema_defer_id = this->context.sema_buffer.createDefer(is_error_defer);
		this->get_current_scope_level().stmtBlock().emplace_back(sema_defer_id);

		sema::Defer& sema_defer = this->context.sema_buffer.defers[sema_defer_id];
		this->push_scope_level(&sema_defer.block);

		this->get_current_scope_level().setIsDeferMainScope();

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_end_defer(const Instruction::EndDefer& instr) -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		if(this->end_sub_scopes(this->get_location(instr.close_brace)).isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_begin_stmt_block(const Instruction::BeginStmtBlock& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.stmt_block).isError()){ return Result::ERROR; }

		const sema::BlockScope::ID block_scope_id = this->context.sema_buffer.createBlockScope();
		this->get_current_scope_level().stmtBlock().emplace_back(block_scope_id);

		sema::BlockScope& block_scope = this->context.sema_buffer.block_scopes[block_scope_id];

		this->push_scope_level(&block_scope.block);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_end_stmt_block(const Instruction::EndStmtBlock& instr) -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		if(this->end_sub_scopes(this->get_location(instr.close_brace)).isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_func_call(const Instruction::FuncCall& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.func_call).isError()){ return Result::ERROR; }

		const TermInfo& target_term_info = this->get_term_info(instr.target);

		const evo::Expected<FuncCallImplData, bool> func_call_impl_res = this->func_call_impl<false, false>(
			instr.func_call, target_term_info, instr.args, instr.template_args
		);
		if(func_call_impl_res.has_value() == false){
			if(func_call_impl_res.error()){
				return Result::ERROR;
			}else{
				return Result::NEED_TO_WAIT;
			}
		}

		//////////////////////////////////////////////////////////////////////
		// 

		if(func_call_impl_res.value().selected_func_type.returnsVoid() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_DISCARDING_RETURNS,
				instr.func_call.target,
				"Discarding return value of function call"
			);
			return Result::ERROR;
		}

		if(this->get_current_func().attributes.isComptime && func_call_impl_res.value().is_src_func()){
			if(func_call_impl_res.value().selected_func->attributes.isComptime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
					instr.func_call.target,
					"Cannot call a non-comptime function within a comptime function",
					Diagnostic::Info(
						"Called function was defined here:",
						this->get_location(*func_call_impl_res.value().selected_func_id)
					)
				);
				return Result::ERROR;
			}

			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(
				*func_call_impl_res.value().selected_func_id
			);
		}


		auto sema_args = evo::SmallVector<sema::Expr>();


		switch(target_term_info.value_category){
			case TermInfo::ValueCategory::METHOD_CALL: {
				const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
					target_term_info.getExpr().fakeTermInfoID()
				);

				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					sema_args.emplace_back(fake_term_info.expr);

				}else{
					if(this->get_package().warn.methodCallOnNonMethod){
						this->emit_warning(
							Diagnostic::Code::SEMA_WARN_METHOD_CALL_ON_NON_METHOD,
							instr.func_call,
							"Making a method call to a function that is not a method",
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info("Call the function by type accessor instead"),
								Diagnostic::Info(
									"Function declared here:",
									this->get_location(*func_call_impl_res.value().selected_func_id)
								),
							}
						);
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createUnusedExpr(fake_term_info.expr)
					);
				}
			} break;

			case TermInfo::ValueCategory::INTERFACE_CALL: {
				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
						target_term_info.getExpr().fakeTermInfoID()
					);

					sema_args.emplace_back(fake_term_info.expr);
				}
			} break;

			case TermInfo::ValueCategory::POLY_INTERFACE_CALL: {
				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
						target_term_info.getExpr().fakeTermInfoID()
					);

					const sema::Expr extract_this = sema::Expr(
						this->context.sema_buffer.createInterfacePtrExtractThis(fake_term_info.expr)
					);

					sema_args.emplace_back(
						sema::Expr(this->context.sema_buffer.createDeref(extract_this, TypeManager::getTypeRawPtr()))
					);
				}
			} break;

			default: break;
		}



		for(const SymbolProc::TermInfoID& arg : instr.args){
			sema_args.emplace_back(this->get_term_info(arg).getExpr());
		}



		if(func_call_impl_res.value().is_src_func() == false) [[unlikely]] {
			const IntrinsicFunc::Kind intrinsic_kind = target_term_info.getExpr().intrinsicFuncID();

			const Context::IntrinsicFuncInfo& intrinsic_func_info = this->context.getIntrinsicFuncInfo(intrinsic_kind);


			if(this->get_current_func().attributes.isComptime){
				if(intrinsic_func_info.allowedInInterptime == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
						instr.func_call.target,
						"Cannot call a non-comptime function within a comptime function"
					);
					return Result::ERROR;
				}

			}else{
				if(intrinsic_func_info.allowedInRuntime == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_RUNTIME,
						instr.func_call.target,
						"Cannot call a non-runtime function within a runtime function"
					);
					return Result::ERROR;
				}
			}

			switch(this->context.getConfig().mode){
				case Context::Config::Mode::COMPILE: {
					if(intrinsic_func_info.allowedInCompile == false){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
							instr.func_call.target,
							"Calling this intrinsic is not allowed in compile mode"
						);
						return Result::ERROR;
					}
				} break;

				case Context::Config::Mode::SCRIPTING: {
					if(intrinsic_func_info.allowedInScript == false){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
							instr.func_call.target,
							"Calling this intrinsic is not allowed in scripting mode"
						);
						return Result::ERROR;
					}
				} break;

				case Context::Config::Mode::BUILD_SYSTEM: {
					if(intrinsic_func_info.allowedInBuild == false){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
							instr.func_call.target,
							"Calling this intrinsic is not allowed in build mode"
						);
						return Result::ERROR;
					}
				} break;
			}


			switch(intrinsic_kind){
				case IntrinsicFunc::Kind::ABORT: case IntrinsicFunc::Kind::PANIC: {
					const sema::FuncCall::ID sema_func_call_id = this->context.sema_buffer.createFuncCall(
						intrinsic_kind, std::move(sema_args)
					);

					this->get_current_scope_level().stmtBlock().emplace_back(sema_func_call_id);
					this->get_current_scope_level().setTerminated();
				} break;

				default: {
					const sema::FuncCall::ID sema_func_call_id = this->context.sema_buffer.createFuncCall(
						intrinsic_kind, std::move(sema_args)
					);

					this->get_current_scope_level().stmtBlock().emplace_back(sema_func_call_id);
				} break;
			}


		}else{
			for(size_t i = sema_args.size(); i < func_call_impl_res.value().selected_func->params.size(); i+=1){
				sema_args.emplace_back(*func_call_impl_res.value().selected_func->params[i].defaultValue);
			}

			if(target_term_info.value_category == TermInfo::ValueCategory::POLY_INTERFACE_CALL){
				const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
					target_term_info.getExpr().fakeTermInfoID()
				);

				const TypeInfo& expr_type_info = this->context.getTypeManager().getTypeInfo(fake_term_info.typeID);
				const BaseType::PolyInterfaceRef& target_poly_interface_ref = 
					this->context.getTypeManager().getPolyInterfaceRef(
						expr_type_info.baseTypeID().polyInterfaceRefID()
					);
				const BaseType::Interface& target_interface =
					this->context.getTypeManager().getInterface(target_poly_interface_ref.interfaceID);


				for(size_t i = 0; const sema::Func::ID method : target_interface.methods){
					if(method == *func_call_impl_res.value().selected_func_id){
						const sema::InterfaceCall::ID interface_call_id = this->context.sema_buffer.createInterfaceCall(
							fake_term_info.expr,
							func_call_impl_res.value().selected_func->typeID,
							target_poly_interface_ref.interfaceID,
							uint32_t(i),
							std::move(sema_args)
						);

						this->get_current_scope_level().stmtBlock().emplace_back(interface_call_id);
						break;
					}

					i += 1;
				}

			}else{
				const sema::FuncCall::ID sema_func_call_id = this->context.sema_buffer.createFuncCall(
					*func_call_impl_res.value().selected_func_id, std::move(sema_args)
				);

				this->get_current_scope_level().stmtBlock().emplace_back(sema_func_call_id);

				const sema::Func& selected_func =
					this->context.getSemaBuffer().getFunc(*func_call_impl_res.value().selected_func_id);
				if(selected_func.attributes.isNoReturn){
					this->get_current_scope_level().setTerminated();
				}
			}

		}

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_assignment(const Instruction::Assignment& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.infix).isError()){ return Result::ERROR; }

		TermInfo& lhs = this->get_term_info(instr.lhs);
		TermInfo& rhs = this->get_term_info(instr.rhs);

		if(lhs.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_CONCRETE,
				instr.infix.lhs,
				"LHS of assignment must be concrete"
			);
			return Result::ERROR;
		}

		if(lhs.is_const() && lhs.value_state != TermInfo::ValueState::UNINIT){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_MUTABLE,
				instr.infix.lhs,
				"LHS of assignment must be mutable"
			);
			return Result::ERROR;
		}

		if(lhs.value_state == TermInfo::ValueState::MOVED_FROM){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"LHS of assignment cannot have a value state of moved from"
			);
			return Result::ERROR;
		}



		const Token::Kind op_kind = this->source.getTokenBuffer()[instr.infix.opTokenID].kind();

		if(op_kind == Token::lookupKind("=")){
			if(rhs.is_ephemeral() == false && rhs.value_category != TermInfo::ValueCategory::NULL_VALUE){
				this->emit_error(
					Diagnostic::Code::SEMA_ASSIGN_RHS_NOT_EPHEMERAL,
					instr.infix.rhs,
					"RHS of assignment must be ephemeral or (if applicable) value [null]"
				);
				return Result::ERROR;
			}

			TypeCheckInfo type_check_info = this->type_check<true, true>(
				lhs.type_id.as<TypeInfo::ID>(),
				rhs,
				std::format("RHS of [{}]", op_kind),
				instr.infix.rhs,
				lhs.isUninitialized()
			);

			if(type_check_info.ok == false){ return Result::ERROR; }

			if(type_check_info.non_auto_implicit_conversion_target.is<std::monostate>() == false){
				return this->handle_non_auto_implicit_conversion(
					type_check_info.non_auto_implicit_conversion_target,
					lhs,
					rhs.getExpr(),
					instr.infix
				);
			}


			switch(lhs.getExpr().kind()){
				case sema::Expr::Kind::VAR: {
					this->set_ident_value_state(
						sema::UninitPtrLocalVar(lhs.getExpr().varID()), sema::ScopeLevel::ValueState::UNINIT
					);
				} break;

				case sema::Expr::Kind::DEREF: {
					if(lhs.value_state != TermInfo::ValueState::UNINIT){ break; }

					const sema::Deref& sema_deref = this->context.getSemaBuffer().getDeref(lhs.getExpr().derefID());

					switch(sema_deref.expr.kind()){
						case sema::Expr::Kind::VAR: {
							if(
								this->get_ident_value_state(sema::UninitPtrLocalVar(sema_deref.expr.varID()))
									== TermInfo::ValueState::INIT
							){
								this->emit_error(
									Diagnostic::Code::SEMA_UNINT_PTR_ALREADY_INIT,
									instr.infix.lhs,
									"The pointee was already initialized"
								);
								return Result::ERROR;
							}

							this->set_ident_value_state(
								sema::UninitPtrLocalVar(sema_deref.expr.varID()), sema::ScopeLevel::ValueState::INIT
							);
						} break;

						case sema::Expr::Kind::FUNC_CALL: {
							// safe, do nothing...
						} break;

						default: {
							if(this->currently_in_unsafe() == false){
								this->emit_error(
									Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
									instr.infix,
									"Unsafe assignment while not in an unsafe scope"
								);
								return Result::ERROR;
							}
						} break;
					}
				} break;

				default: {
					if(
						this->currently_in_unsafe() == false
						&& this->context.getTypeManager().getTypeInfo(lhs.type_id.as<TypeInfo::ID>()).isUninitPointer()
					){
						this->emit_error(
							Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
							instr.infix,
							"Unsafe assignment while not in an unsafe scope"
						);
						return Result::ERROR;
					}
				} break;
			}


			if(lhs.isUninitialized()){
				if(this->set_ident_value_state_if_needed(
					lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
				).isError()){
					return Result::ERROR;
				}
			}

			if(rhs.value_category == TermInfo::ValueCategory::NULL_VALUE){
				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createAssign(
						lhs.getExpr(),
						sema::Expr(
							this->context.sema_buffer.createDefaultNew(
								lhs.type_id.as<TypeInfo::ID>(), lhs.isUninitialized()
							)
						)
					)
				);

			}else{
				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createAssign(lhs.getExpr(), rhs.getExpr())
				);
			}

			return Result::SUCCESS;

		}else{
			const TypeInfo::ID lhs_decayed_type_id =
				this->context.type_manager.decayType<false, false>(lhs.type_id.as<TypeInfo::ID>());
			const TypeInfo& lhs_decayed_type = this->context.getTypeManager().getTypeInfo(lhs_decayed_type_id);

			if(lhs_decayed_type.baseTypeID().kind() == BaseType::Kind::STRUCT){
				const BaseType::Struct& lhs_struct =
					this->context.getTypeManager().getStruct(lhs_decayed_type.baseTypeID().structID());

				const evo::Expected<sema::FuncCall::ID, Result> infix_overload_result = 
					this->infix_overload_impl(lhs_struct.infixOverloads, lhs, rhs, instr.infix);

				if(infix_overload_result.has_value() == false){
					return infix_overload_result.error();
				}

				this->get_current_scope_level().stmtBlock().emplace_back(infix_overload_result.value());
				return Result::SUCCESS;

			}else{
				using MathInfixKind = Instruction::MathInfixKind;

				switch(op_kind){
					case Token::lookupKind("+="): case Token::lookupKind("-="): case Token::lookupKind("*="):
					case Token::lookupKind("/="): case Token::lookupKind("%="): {
						const auto math_infix = Instruction::MathInfix<false, MathInfixKind::MATH>(
							instr.infix, instr.lhs, instr.rhs, instr.builtin_composite_expr_term_info_id
						);

						const Result result = this->instr_expr_math_infix(math_infix);
						if(result != Result::SUCCESS){ return result; }
					} break;


					case Token::lookupKind("+%="): case Token::lookupKind("+|="): case Token::lookupKind("-%="):
					case Token::lookupKind("-|="): case Token::lookupKind("*%="): case Token::lookupKind("*|="): {
						const auto math_infix = Instruction::MathInfix<false, MathInfixKind::INTEGRAL_MATH>(
							instr.infix, instr.lhs, instr.rhs, instr.builtin_composite_expr_term_info_id
						);

						const Result result = this->instr_expr_math_infix(math_infix);
						if(result != Result::SUCCESS){ return result; }
					} break;

					case Token::lookupKind("<<="): case Token::lookupKind("<<|="): case Token::lookupKind(">>="): {
						const auto math_infix = Instruction::MathInfix<false, MathInfixKind::SHIFT>(
							instr.infix, instr.lhs, instr.rhs, instr.builtin_composite_expr_term_info_id
						);

						const Result result = this->instr_expr_math_infix(math_infix);
						if(result != Result::SUCCESS){ return result; }
					} break;
					
					case Token::lookupKind("&="): case Token::lookupKind("|="): case Token::lookupKind("^="): {
						const auto math_infix = Instruction::MathInfix<false, MathInfixKind::BITWISE_LOGICAL>(
							instr.infix, instr.lhs, instr.rhs, instr.builtin_composite_expr_term_info_id
						);

						const Result result = this->instr_expr_math_infix(math_infix);
						if(result != Result::SUCCESS){ return result; }
					} break;
					
					default: {
						evo::debugFatalBreak("Unknown or unsupported composite assignment");
					} break;
				}

				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createAssign(
						lhs.getExpr(), this->get_term_info(instr.builtin_composite_expr_term_info_id).getExpr()
					)
				);

				return Result::SUCCESS;
			}
		}
	}


	auto SemanticAnalyzer::instr_assignment_new(const Instruction::AssignmentNew& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.infix).isError()){ return Result::ERROR; }

		const TermInfo& lhs = this->get_term_info(instr.lhs);

		const AST::New& ast_new = this->source.getASTBuffer().getNew(instr.infix.rhs);

		if(lhs.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_CONCRETE,
				instr.infix.lhs,
				"LHS of assignment must be concrete"
			);
			return Result::ERROR;
		}

		if(lhs.is_const() && lhs.value_state != TermInfo::ValueState::UNINIT){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_MUTABLE,
				instr.infix.lhs,
				"LHS of assignment must be mutable"
			);
			return Result::ERROR;
		}

		if(lhs.value_state == TermInfo::ValueState::MOVED_FROM){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"LHS of assignment cannot have a value state of moved from"
			);
			return Result::ERROR;
		}



		const TypeInfo::VoidableID target_type_id = this->get_type(instr.type_id);
		if(target_type_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_TYPE_VOID,
				this->source.getASTBuffer().getNew(instr.infix.rhs).type,
				"Operator [new] cannot accept type `Void`"
			);
			return Result::ERROR;
		}

		if(lhs.type_id.as<TypeInfo::ID>() != target_type_id.asTypeID()){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "Expected type:       ");
			this->diagnostic_print_type_info(target_type_id.asTypeID(), infos, "Operator `new` type: ");
			this->emit_error(
				Diagnostic::Code::SEMA_TYPE_MISMATCH,
				instr.infix,
				"Assignment operator `new` cannot accept an expression of a different type, "
					"and this expression cannot be implicitly converted to the correct type",
				std::move(infos)
			);
			return Result::ERROR;
		}

		const TypeInfo::ID decayed_target_type_id =
			this->context.type_manager.decayType<true, true>(target_type_id.asTypeID());

		if(instr.args.size() == 1){ // check distinct alias from underlying
			const TypeInfo::ID maybe_distinct_alias_target_type_id =
				this->context.type_manager.decayType<false, true>(target_type_id.asTypeID());

			const TypeInfo& maybe_distinct_alias_target_type_info =
				this->context.getTypeManager().getTypeInfo(maybe_distinct_alias_target_type_id);

			if(maybe_distinct_alias_target_type_info.baseTypeID().kind() == BaseType::Kind::DISTINCT_ALIAS){
				const TermInfo& arg = this->get_term_info(instr.args[0]);

				if(arg.type_id.is<TypeInfo::ID>()){
					const TypeInfo::ID decayed_arg_type_id =
						this->context.type_manager.decayType<true, true>(arg.type_id.as<TypeInfo::ID>());

					if(decayed_target_type_id == decayed_arg_type_id){ // matched with distinct alias from underlying
						if(arg.is_ephemeral() == false){
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_DISTINCT_ALIAS_ARG_VAL_NOT_EPHEMERAL,
								this->source.getASTBuffer().getNew(instr.infix.rhs).args[0].value,
								"Argument of operator [new] of distinct alias from underlying type must be ephemeral"
							);
							return Result::ERROR;
						}

						if(this->source.getASTBuffer().getNew(instr.infix.rhs).args[0].label.has_value()){
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_DISTINCT_ALIAS_ARG_HAS_LABEL,
								*this->source.getASTBuffer().getNew(instr.infix.rhs).args[0].label,
								"Argument of operator [new] of distinct alias from underlying type cannot have a label"
							);
							return Result::ERROR;
						}

						if(lhs.isUninitialized()){
							if(this->set_ident_value_state_if_needed(
								lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
							).isError()){
								return Result::ERROR;
							}
						}

						this->get_current_scope_level().stmtBlock().emplace_back(
							this->context.sema_buffer.createAssign(lhs.getExpr(), arg.getExpr())
						);

						return Result::SUCCESS;
					}
				}
			}
		}


		const TypeInfo& decayed_target_type_info = this->context.getTypeManager().getTypeInfo(decayed_target_type_id);

		if(decayed_target_type_info.qualifiers().empty() == false){
			if(decayed_target_type_info.isOptional()){
				if(instr.args.empty()){
					if(lhs.isUninitialized()){
						if(this->set_ident_value_state_if_needed(
							lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
						).isError()){
							return Result::ERROR;
						}
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createAssign(
							lhs.getExpr(),
							sema::Expr(
								this->context.sema_buffer.createDefaultNew(
									target_type_id.asTypeID(), lhs.isUninitialized()
								)
							)
						)
					);

					return Result::SUCCESS;

				}else if(instr.args.size() == 1){
					TermInfo& arg = this->get_term_info(instr.args[0]);


					if(ast_new.args[0].label.has_value()){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_OPTIONAL_NO_MATCHING_OVERLOAD,
							ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info("No operator [new] of optional accepts arguments with labels")
						);
						return Result::ERROR;
					}

					if(lhs.isUninitialized()){
						if(this->set_ident_value_state_if_needed(
							lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
						).isError()){
							return Result::ERROR;
						}
					}

					if(arg.value_category == TermInfo::ValueCategory::NULL_VALUE){
						this->get_current_scope_level().stmtBlock().emplace_back(
							this->context.sema_buffer.createAssign(
								lhs.getExpr(),
								sema::Expr(
									this->context.sema_buffer.createDefaultNew(
										target_type_id.asTypeID(), lhs.isUninitialized()
									)
								)
							)
						);

					}else{
						if(arg.is_ephemeral() == false){
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_OPTIONAL_ARG_NOT_EPHEMERAL,
								ast_new.args[0].value,
								"Argument in operator [new] for optional must be ephemeral or [null]"
							);
							return Result::ERROR;
						}

						const TypeInfo::ID optional_held_type_id = this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(
								decayed_target_type_info.baseTypeID(),
								evo::SmallVector<TypeInfo::Qualifier>(
									decayed_target_type_info.qualifiers().begin(),
									std::prev(decayed_target_type_info.qualifiers().end())
								)
							)
						);

						if(this->type_check<true, true>(
							optional_held_type_id, arg, "Argument in operator [new] for optional", ast_new.args[0].value
						).ok == false){
							return Result::ERROR;
						}



						this->get_current_scope_level().stmtBlock().emplace_back(
							this->context.sema_buffer.createAssign(
								lhs.getExpr(),
								sema::Expr(
									this->context.sema_buffer.createConversionToOptional(
										arg.getExpr(), target_type_id.asTypeID()
									)
								)
							)
						);
					}

					return Result::SUCCESS;

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_OPTIONAL_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info("Too may arguments")
					);
					return Result::ERROR;
				}
			}


			this->emit_error(
				Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
				ast_new.type,
				"Operator [new] of this type is unimplemented"
			);
			return Result::ERROR;
		}


		switch(decayed_target_type_info.baseTypeID().kind()){
			case BaseType::Kind::PRIMITIVE: {
				if(instr.args.empty()){
					const BaseType::Primitive& primitive =
						this->context.getTypeManager().getPrimitive(decayed_target_type_info.baseTypeID().primitiveID());

					if(primitive.kind() == Token::Kind::TYPE_RAWPTR || primitive.kind() == Token::Kind::TYPE_TYPEID){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_PRIMITIVE_NO_MATCHING_OVERLOAD,
							ast_new.type,
							"No matching operator [new] overload for this type"
						);
						return Result::ERROR;
					}


					if(lhs.isUninitialized()){
						if(this->set_ident_value_state_if_needed(
							lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
						).isError()){
							return Result::ERROR;
						}
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createAssign(
							lhs.getExpr(),
							sema::Expr(this->context.sema_buffer.createDefaultNew(decayed_target_type_id, false))
						)
					);

					return Result::SUCCESS;
					
				}else if(instr.args.size() == 1){
					TermInfo& arg = this->get_term_info(instr.args[0]);

					if(arg.is_ephemeral() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_PRIMITIVE_ARG_NOT_EPHEMERAL,
							ast_new.args[0].value,
							"Argument in operator [new] for primitive must be ephemeral"
						);
						return Result::ERROR;
					}

					if(this->type_check<true, true>(
						target_type_id.asTypeID(),
						arg,
						"Argument of operator [new] for primitive",
						ast_new.args[0].value
					).ok == false){
						return Result::ERROR;
					}

					if(lhs.isUninitialized()){
						if(this->set_ident_value_state_if_needed(
							lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
						).isError()){
							return Result::ERROR;
						}
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createAssign(lhs.getExpr(), arg.getExpr())
					);

					return Result::SUCCESS;
					
				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_PRIMITIVE_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info("Too may arguments")
					);
					return Result::ERROR;
				}
			} break;

			case BaseType::Kind::ARRAY: {
				if(instr.args.size() != 0){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_ARRAY_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info(
							std::format("Expected {} arguments, got {}", 0, instr.args.size())
						)
					);
					return Result::ERROR;
				}

				const BaseType::Array& array_type =
					this->context.getTypeManager().getArray(decayed_target_type_info.baseTypeID().arrayID());

				if(this->context.getTypeManager().isDefaultInitializable(array_type.elementTypeID) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_ARRAY_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info("Array element type is not default initializable")
					);
					return Result::ERROR;	
				}

				if(lhs.isUninitialized()){
					if(this->set_ident_value_state_if_needed(
						lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}

				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createAssign(
						lhs.getExpr(),
						sema::Expr(this->context.sema_buffer.createDefaultNew(decayed_target_type_id, false))
					)
				);

				return Result::SUCCESS;
			} break;

			case BaseType::Kind::ARRAY_REF: {
				if(instr.args.empty()){
					if(lhs.isUninitialized()){
						if(this->set_ident_value_state_if_needed(
							lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
						).isError()){
							return Result::ERROR;
						}
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createAssign(
							lhs.getExpr(),
							sema::Expr(this->context.sema_buffer.createDefaultNew(decayed_target_type_id, false))
						)
					);

					return Result::SUCCESS;
				}

				const BaseType::ArrayRef& array_ref =
					this->context.getTypeManager().getArrayRef(decayed_target_type_info.baseTypeID().arrayRefID());

				const size_t num_ref_ptrs = array_ref.getNumRefPtrs();

				if(instr.args.size() != num_ref_ptrs + 1){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_ARRAY_REF_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info(
							std::format("Expected {} arguments, got {}", num_ref_ptrs + 1, instr.args.size())
						)
					);
					return Result::ERROR;
				}


				if(this->get_term_info(instr.args[0]).is_ephemeral() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_ARRAY_REF_ARG_NOT_EPHEMERAL,
						ast_new.args[0].value,
						"Argument in operator [new] for optional must be ephemeral"
					);
					return Result::ERROR;
				}

				const TypeInfo::ID array_ptr_type = this->context.type_manager.getOrCreateTypeInfo(
					this->context.getTypeManager().getTypeInfo(array_ref.elementTypeID)
						.copyWithPushedQualifier(TypeInfo::Qualifier(true, array_ref.isMut, false, false))
				);

				if(this->type_check<true, true>(
					array_ptr_type,
					this->get_term_info(instr.args[0]),
					"Pointer argument of operator [new] for array reference",
					ast_new.args[0].value
				).ok == false){
					return Result::ERROR;
				}

				if(ast_new.args[0].label.has_value()){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_ARRAY_REF_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info("No operator [new] of array reference accepts arguments with labels")
					);
				}


				for(size_t i = 1; i < num_ref_ptrs + 1; i+=1){
					TermInfo& arg = this->get_term_info(instr.args[i]);

					if(arg.is_ephemeral() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_ARRAY_REF_ARG_NOT_EPHEMERAL,
							ast_new.args[i].value,
							"Argument in operator [new] for array reference must be ephemera"
						);
						return Result::ERROR;
					}

					if(this->type_check<true, true>(
						TypeManager::getTypeUSize(),
						arg,
						"Dimension argument of operator [new] for array reference",
						ast_new.args[i].value
					).ok == false){
						return Result::ERROR;
					}

					if(ast_new.args[i].label.has_value()){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_ARRAY_REF_NO_MATCHING_OVERLOAD,
							ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info("No operator [new] of array reference accepts arguments with labels")
						);
					}
				}


				auto dimensions = evo::SmallVector<evo::Variant<uint64_t, sema::Expr>>();
				dimensions.reserve(array_ref.dimensions.size());
				for(size_t i = 0; const BaseType::ArrayRef::Dimension& dimension : array_ref.dimensions){
					if(dimension.isPtr()){
						dimensions.emplace_back(this->get_term_info(instr.args[dimensions.size() + 1]).getExpr());
					}

					i += 1;
				}

				if(lhs.isUninitialized()){
					if(this->set_ident_value_state_if_needed(
						lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}

				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createAssign(
						lhs.getExpr(),
						sema::Expr(this->context.sema_buffer.createInitArrayRef(
							this->get_term_info(instr.args[0]).getExpr(), std::move(dimensions)
						))
					)
				);

				return Result::SUCCESS;
			} break;

			case BaseType::Kind::STRUCT: {
				const BaseType::Struct& target_struct =
					this->context.getTypeManager().getStruct(decayed_target_type_info.baseTypeID().structID());


				auto overloads = evo::SmallVector<SelectFuncOverloadFuncInfo>();
				auto args = evo::SmallVector<SelectFuncOverloadArgInfo>();

				const bool is_semantically_initialization = lhs.isUninitialized();
				const bool should_run_initialization = 
					is_semantically_initialization || target_struct.newAssignOverloads.empty();



				if(should_run_initialization){
					if(target_struct.newInitOverloads.empty()){
						if(target_struct.isTriviallyDefaultInitializable){
							if(lhs.isUninitialized()){
								if(this->set_ident_value_state_if_needed(
									lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
								).isError()){
									return Result::ERROR;
								}
							}
							return Result::SUCCESS;

						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_STRUCT_NO_MATCHING_OVERLOAD,
								ast_new.type,
								"No matching operator [new] overload for this type"
							);
							return Result::ERROR;
						}
					}


					overloads.reserve(target_struct.newInitOverloads.size());
					for(const sema::Func::ID overload_id : target_struct.newInitOverloads){
						const sema::Func& overload = this->context.getSemaBuffer().getFunc(overload_id);

						overloads.emplace_back(
							overload_id, this->context.getTypeManager().getFunction(overload.typeID)
						);
					}

					args.reserve(instr.args.size());
				}else{
					overloads.reserve(target_struct.newAssignOverloads.size());
					for(const sema::Func::ID overload_id : target_struct.newAssignOverloads){
						const sema::Func& overload = this->context.getSemaBuffer().getFunc(overload_id);

						overloads.emplace_back(
							overload_id, this->context.getTypeManager().getFunction(overload.typeID)
						);
					}

					args.reserve(instr.args.size() + 1);
					args.emplace_back(this->get_term_info(instr.lhs), instr.infix.lhs, std::nullopt);
				}



				for(size_t i = 0; const SymbolProc::TermInfoID& arg_id : instr.args){
					args.emplace_back(this->get_term_info(arg_id), ast_new.args[i].value, ast_new.args[i].label);

					i += 1;
				}


				const evo::Result<size_t> selected_overload = this->select_func_overload(
					overloads, args, ast_new, !should_run_initialization, evo::SmallVector<Diagnostic::Info>()
				);
				if(selected_overload.isError()){ return Result::ERROR; }

				const sema::Func::ID selected_func_id =
					overloads[selected_overload.value()].func_id.as<sema::Func::ID>();
				const sema::Func& selected_func = this->context.getSemaBuffer().getFunc(selected_func_id);

				const BaseType::Function& selected_func_type =
					this->context.getTypeManager().getFunction(selected_func.typeID);

				if(this->currently_in_unsafe() == false && selected_func_type.isUnsafe){
					this->emit_error(
						Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
						instr.infix.rhs,
						"Unsafe operator [new] while not in an unsafe scope"
					);
					return Result::ERROR;
				}


				auto output_args = evo::SmallVector<sema::Expr>();
				if(should_run_initialization){
					output_args.reserve(selected_func.params.size());
				}else{
					output_args.reserve(selected_func.params.size() + 1);
					output_args.emplace_back(lhs.getExpr());
				}
				for(const SymbolProc::TermInfoID& arg_id : instr.args){
					output_args.emplace_back(this->get_term_info(arg_id).getExpr());
				}

				// default values
				for(size_t i = output_args.size(); i < selected_func.params.size(); i+=1){
					output_args.emplace_back(*selected_func.params[i].defaultValue);
				}


				if(lhs.isUninitialized()){
					if(this->set_ident_value_state_if_needed(
						lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}

				const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
					selected_func_id, std::move(output_args)
				);

				this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(selected_func_id);

				if(should_run_initialization){
					if(
						is_semantically_initialization == false
						&& this->context.getTypeManager().isTriviallyDeletable(decayed_target_type_info.baseTypeID())
							== false
					){
						if(this->get_special_member_call_dependents<SpecialMemberKind::DELETE, true>(
							lhs,
							this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
							instr.infix
						).isError()){
							return Result::ERROR;
						}

						this->get_current_scope_level().stmtBlock().emplace_back(
							this->context.sema_buffer.createDelete(lhs.getExpr(), lhs.type_id.as<TypeInfo::ID>())
						);
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createAssign(lhs.getExpr(), sema::Expr(created_func_call_id))
					);

				}else{
					this->get_current_scope_level().stmtBlock().emplace_back(sema::Stmt(created_func_call_id));
				}

				return Result::SUCCESS;
			} break;

			case BaseType::Kind::UNION: {
				if(instr.args.size() != 0){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_UNION_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info(
							std::format("Expected {} arguments, got {}", 0, instr.args.size())
						)
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isDefaultInitializable(decayed_target_type_info.baseTypeID())==false){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_UNION_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type"
					);
					return Result::ERROR;	
				}

				if(lhs.isUninitialized()){
					if(this->set_ident_value_state_if_needed(
						lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}

				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createAssign(
						lhs.getExpr(),
						sema::Expr(this->context.sema_buffer.createDefaultNew(decayed_target_type_id, false))
					)
				);

				return Result::SUCCESS;
			} break;

			case BaseType::Kind::INTERFACE_MAP: {
				if(instr.args.size() != 0){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_UNION_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info(
							std::format("Expected {} arguments, got {}", 0, instr.args.size())
						)
					);
					return Result::ERROR;
				}


				if(this->context.getTypeManager().isDefaultInitializable(decayed_target_type_info.baseTypeID())==false){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_UNION_NO_MATCHING_OVERLOAD,
						ast_new.type,
						"No matching operator [new] overload for this type"
					);
					return Result::ERROR;	
				}

				if(lhs.isUninitialized()){
					if(this->set_ident_value_state_if_needed(
						lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}

				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createAssign(
						lhs.getExpr(),
						sema::Expr(this->context.sema_buffer.createDefaultNew(decayed_target_type_id, false))
					)
				);

				return Result::SUCCESS;
			} break;

			default: {
				this->emit_error(
					Diagnostic::Code::SEMA_NEW_INVALID_TYPE,
					ast_new.type,
					"Invalid type for operator [new]"
				);
				return Result::ERROR;
			} break;
		}
	}



	auto SemanticAnalyzer::instr_assignment_copy(const Instruction::AssignmentCopy& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.infix).isError()){ return Result::ERROR; }

		const TermInfo& lhs = this->get_term_info(instr.lhs);
		const TermInfo& target = this->get_term_info(instr.target);

		if(lhs.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_CONCRETE,
				instr.infix.lhs,
				"LHS of assignment must be concrete"
			);
			return Result::ERROR;
		}

		if(lhs.is_const() && lhs.value_state != TermInfo::ValueState::UNINIT){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_MUTABLE,
				instr.infix.lhs,
				"LHS of assignment must be mutable"
			);
			return Result::ERROR;
		}

		if(lhs.value_state == TermInfo::ValueState::MOVED_FROM){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"LHS of assignment cannot have a value state of moved from"
			);
			return Result::ERROR;
		}




		if(target.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_COPY_ARG_NOT_CONCRETE,
				this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
				"Argument of operator [copy] must be concrete"
			);
			return Result::ERROR;
		}

		if(this->context.getTypeManager().isCopyable(target.type_id.as<TypeInfo::ID>()) == false){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_special_member_fail<SpecialMemberFailKind::COPY>(
				target.type_id.as<TypeInfo::ID>(), infos
			);
			this->emit_error(
				Diagnostic::Code::SEMA_COPY_ARG_TYPE_NOT_COPYABLE,
				this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
				"Type of argument of operator [copy] is not copyable",
				std::move(infos)
			);
			return Result::ERROR;
		}

		if(
			this->get_current_func().attributes.isComptime
			&& this->context.getTypeManager().isComptimeCopyable(
				target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
			) == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_COMPTIME_COPY_ARG_TYPE_NOT_COMPTIME_COPYABLE,
				this->source.getASTBuffer().getPrefix(instr.infix.rhs),
				"Type of argument of operator [copy] is not comptime copyable"
			);
			return Result::ERROR;
		}

		if(
			this->currently_in_unsafe() == false
			&& this->context.getTypeManager().isSafeCopyable(
				target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
			) == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
				this->source.getASTBuffer().getPrefix(instr.infix.rhs),
				"Unsafe copy while not in an unsafe scope"
			);
			return Result::ERROR;
		}



		if(
			target.value_state != TermInfo::ValueState::INIT
			&& target.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
				"Argument of operator [copy] must be initialized"
			);
			return Result::ERROR;
		}


		const bool is_initialization = lhs.isUninitialized();

		auto target_copy = TermInfo(
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			target.type_id,
			sema::Expr(
				this->context.sema_buffer.createCopy(
					target.getExpr(), target.type_id.as<TypeInfo::ID>(), is_initialization
				)
			)
		);


		TypeCheckInfo type_check_info = this->type_check<true, true>(
			lhs.type_id.as<TypeInfo::ID>(), target_copy, "RHS of assignment", instr.infix.rhs, is_initialization
		);

		if(type_check_info.ok == false){ return Result::ERROR; }

		if(type_check_info.non_auto_implicit_conversion_target.is<std::monostate>() == false){
			return this->handle_non_auto_implicit_conversion(
				type_check_info.non_auto_implicit_conversion_target,
				lhs,
				target_copy.getExpr(),
				instr.infix
			);
		}


		if(
			this->currently_in_unsafe() == false
			&& this->context.getTypeManager().getTypeInfo(lhs.type_id.as<TypeInfo::ID>()).isUninitPointer()
			&& lhs.getExpr().kind() != sema::Expr::Kind::VAR
		){
			this->emit_error(
				Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
				instr.infix,
				"Unsafe assignment while not in an unsafe scope"
			);
			return Result::ERROR;
		}


		if(is_initialization){
			if(this->get_special_member_call_dependents<SpecialMemberKind::COPY_INIT, true>(
				target,
				this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
				instr.infix
			).isError()){
				return Result::ERROR;
			}

			if(this->set_ident_value_state_if_needed(
				lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.rhs
			).isError()){
				return Result::ERROR;
			}

		}else{
			if(this->get_special_member_call_dependents<SpecialMemberKind::COPY_ASSIGN, true>(
				target,
				this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
				instr.infix
			).isError()){
				return Result::ERROR;
			}
		}

		this->get_current_scope_level().stmtBlock().emplace_back(
			this->context.sema_buffer.createAssign(lhs.getExpr(), target_copy.getExpr())
		);

		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_assignment_move(const Instruction::AssignmentMove& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.infix).isError()){ return Result::ERROR; }

		const TermInfo& lhs = this->get_term_info(instr.lhs);
		TermInfo& target = this->get_term_info(instr.target);

		if(lhs.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_CONCRETE,
				instr.infix.lhs,
				"LHS of assignment must be concrete"
			);
			return Result::ERROR;
		}

		if(lhs.is_const() && lhs.value_state != TermInfo::ValueState::UNINIT){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_MUTABLE,
				instr.infix.lhs,
				"LHS of assignment must be mutable"
			);
			return Result::ERROR;
		}

		if(lhs.value_state == TermInfo::ValueState::MOVED_FROM){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"LHS of assignment cannot have a value state of moved from"
			);
			return Result::ERROR;
		}


		if(target.value_category != TermInfo::ValueCategory::CONCRETE_MUT){
			if(target.value_category == TermInfo::ValueCategory::FORWARDABLE){
				this->emit_error(
					Diagnostic::Code::SEMA_MOVE_ARG_IS_IN_PARAM,
					this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
					"Argument of operator [move] cannot be an in-parameter",
					Diagnostic::Info("Use operator [forward] instead")
				);
			}else if(target.is_concrete() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_MOVE_ARG_NOT_CONCRETE,
					this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
					"Argument of operator [move] must be concrete"
				);
			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_MOVE_ARG_NOT_MUTABLE,
					this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
					"Argument of operator [move] must be mutable"
				);
			}

			return Result::ERROR;
		}


		if(this->context.getTypeManager().isMovable(target.type_id.as<TypeInfo::ID>()) == false){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_special_member_fail<SpecialMemberFailKind::MOVE>(
				target.type_id.as<TypeInfo::ID>(), infos
			);
			this->emit_error(
				Diagnostic::Code::SEMA_MOVE_ARG_TYPE_NOT_MOVABLE,
				this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
				"Type of argument of operator [move] is not movable",
				std::move(infos)
			);
			return Result::ERROR;
		}

		if(
			this->get_current_func().attributes.isComptime
			&& this->context.getTypeManager().isComptimeMovable(
				target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
			) == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_COMPTIME_MOVE_ARG_TYPE_NOT_COMPTIME_MOVABLE,
				this->source.getASTBuffer().getPrefix(instr.infix.rhs),
				"Type of argument of operator [move] is not comptime movable"
			);
			return Result::ERROR;
		}

		if(
			this->currently_in_unsafe() == false
			&& this->context.getTypeManager().isSafeMovable(
				target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
			) == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
				this->source.getASTBuffer().getPrefix(instr.infix.rhs),
				"Unsafe move while not in an unsafe scope"
			);
			return Result::ERROR;
		}


		switch(target.value_state){
			case TermInfo::ValueState::NOT_APPLICABLE: case TermInfo::ValueState::INIT: {
				// do nothing...
			} break;

			case TermInfo::ValueState::INITIALIZING: case TermInfo::ValueState::UNINIT: {
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
					"Argument of operator [move] must be initialized"
				);
				return Result::ERROR;
			} break;

			case TermInfo::ValueState::MOVED_FROM: {
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					this->source.getASTBuffer().getPrefix(instr.infix.rhs).rhs,
					"Argument of operator [move] must be initialized",
					Diagnostic::Info("This argument was already moved from")
				);
				return Result::ERROR;
			} break;
		}


		const bool is_initialization = lhs.isUninitialized();

		auto target_move = TermInfo(
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			target.type_id,
			sema::Expr(
				this->context.sema_buffer.createMove(
					target.getExpr(), target.type_id.as<TypeInfo::ID>(), is_initialization
				)
			)
		);


		TypeCheckInfo type_check_info = this->type_check<true, true>(
			lhs.type_id.as<TypeInfo::ID>(), target_move, "RHS of assignment", instr.infix.rhs, is_initialization
		);

		if(type_check_info.ok == false){ return Result::ERROR; }

		if(type_check_info.non_auto_implicit_conversion_target.is<std::monostate>() == false){
			return this->handle_non_auto_implicit_conversion(
				type_check_info.non_auto_implicit_conversion_target,
				lhs,
				target_move.getExpr(),
				instr.infix
			);
		}


		switch(target.getExpr().kind()){
			case sema::Expr::Kind::VAR: {
				// safe, nothing to do...
			} break;

			default: {
				if(this->currently_in_unsafe() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
						this->source.getASTBuffer().getPrefix(instr.infix.rhs),
						"Unsafe move while not in an unsafe scope"
					);
					return Result::ERROR;
				}
			} break;
		}


		if(is_initialization){
			if(this->get_special_member_call_dependents<SpecialMemberKind::MOVE_INIT, true>(
				target,
				this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
				instr.infix
			).isError()){
				return Result::ERROR;
			}

			if(this->set_ident_value_state_if_needed(
				lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix.lhs
			).isError()){
				return Result::ERROR;
			}

		}else{
			if(this->get_special_member_call_dependents<SpecialMemberKind::MOVE_ASSIGN, true>(
				target,
				this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
				instr.infix
			).isError()){
				return Result::ERROR;
			}
		}

		this->get_current_scope_level().stmtBlock().emplace_back(
			this->context.sema_buffer.createAssign(lhs.getExpr(), target_move.getExpr())
		);

		if(target.value_state == TermInfo::ValueState::INIT){
			if(this->set_ident_value_state_if_needed(
				target.getExpr(), sema::ScopeLevel::ValueState::MOVED_FROM, instr.infix.rhs
			).isError()){
				return Result::ERROR;
			}
		}

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_assignment_forward(const Instruction::AssignmentForward& instr) -> Result {
		const TermInfo& lhs = this->get_term_info(instr.lhs);
		const TermInfo& target = this->get_term_info(instr.target);

		if(lhs.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_CONCRETE,
				instr.infix.lhs,
				"LHS of assignment must be concrete"
			);
			return Result::ERROR;
		}

		if(lhs.is_const() && lhs.value_state != TermInfo::ValueState::UNINIT){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_MUTABLE,
				instr.infix.lhs,
				"LHS of assignment must be mutable"
			);
			return Result::ERROR;
		}

		if(lhs.value_state == TermInfo::ValueState::MOVED_FROM){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"LHS of assignment cannot have a value state of moved from"
			);
			return Result::ERROR;
		}

		if(target.value_category != TermInfo::ValueCategory::FORWARDABLE){
			this->emit_error(
				Diagnostic::Code::SEMA_MOVE_ARG_NOT_MUTABLE,
				instr.infix,
				"Argument of operator [forward] must be forwardable"
			);

			return Result::ERROR;
		}


		bool is_initialization = false;

		if(lhs.isUninitialized()){
			if(this->set_ident_value_state_if_needed(
				lhs.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.infix
			).isError()){
				return Result::ERROR;
			}
			is_initialization = true;
		}

		const bool target_is_copyable = this->context.getTypeManager().isCopyable(target.type_id.as<TypeInfo::ID>());
		const bool target_is_movable = this->context.getTypeManager().isMovable(target.type_id.as<TypeInfo::ID>());

		if(this->get_current_func().attributes.isComptime){
			if(is_initialization){
				if(target_is_copyable){
					if(this->get_special_member_call_dependents<SpecialMemberKind::COPY_INIT, true>(
						target,
						this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
						instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}

				if(target_is_movable){
					if(this->get_special_member_call_dependents<SpecialMemberKind::MOVE_INIT, true>(
						target,
						this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
						instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}
			}else{
				if(target_is_copyable){
					if(this->get_special_member_call_dependents<SpecialMemberKind::COPY_ASSIGN, true>(
						target,
						this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
						instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}

				if(target_is_movable){
					if(this->get_special_member_call_dependents<SpecialMemberKind::MOVE_ASSIGN, true>(
						target,
						this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
						instr.infix.rhs
					).isError()){
						return Result::ERROR;
					}
				}
			}
		}

		if(this->currently_in_unsafe() == false){
			if(
				target_is_copyable
				&& this->context.getTypeManager().isSafeCopyable(
						target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
					) == false
			){
				this->emit_error(
					Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
					this->source.getASTBuffer().getPrefix(instr.infix.rhs),
					"Unsafe forward while not in an unsafe scope"
				);
				return Result::ERROR;
			}

			if(
				target_is_movable
				&& this->context.getTypeManager().isSafeMovable(
						target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
					) == false
			){
				this->emit_error(
					Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
					this->source.getASTBuffer().getPrefix(instr.infix.rhs),
					"Unsafe forward while not in an unsafe scope"
				);
				return Result::ERROR;
			}
		}


		switch(target.value_state){
			case TermInfo::ValueState::NOT_APPLICABLE: {
				// do nothing...
			} break;

			case TermInfo::ValueState::INIT: {
				if(this->set_ident_value_state_if_needed(
					target.getExpr(), sema::ScopeLevel::ValueState::MOVED_FROM, instr.infix.rhs
				).isError()){
					return Result::ERROR;
				}
			} break;

			case TermInfo::ValueState::INITIALIZING: case TermInfo::ValueState::UNINIT: {
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					this->source.getASTBuffer().getInfix(instr.infix.rhs).rhs,
					"Argument of operator [forward] must be initialized"
				);
				return Result::ERROR;
			} break;

			case TermInfo::ValueState::MOVED_FROM: {
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					this->source.getASTBuffer().getInfix(instr.infix.rhs).rhs,
					"Argument of operator [forward] must be initialized",
					Diagnostic::Info("This argument was already forwarded")
				);
				return Result::ERROR;
			} break;
		}



		auto target_forward = TermInfo(
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			target.type_id,
			sema::Expr(
				this->context.sema_buffer.createForward(
					target.getExpr(), target.type_id.as<TypeInfo::ID>(), is_initialization
				)
			)
		);


		TypeCheckInfo type_check_info = this->type_check<true, true>(
			lhs.type_id.as<TypeInfo::ID>(), target_forward, "RHS of assignment", instr.infix.rhs, is_initialization
		);

		if(type_check_info.ok == false){ return Result::ERROR; }

		if(type_check_info.non_auto_implicit_conversion_target.is<std::monostate>() == false){
			return this->handle_non_auto_implicit_conversion(
				type_check_info.non_auto_implicit_conversion_target,
				lhs,
				target_forward.getExpr(),
				instr.infix
			);
		}


		this->get_current_scope_level().stmtBlock().emplace_back(
			this->context.sema_buffer.createAssign(lhs.getExpr(), target_forward.getExpr())
		);

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_multi_assign(const Instruction::MultiAssign& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.multi_assign).isError()){ return Result::ERROR; }

		TermInfo& value = this->get_term_info(instr.value);

		if(value.is_ephemeral() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_ASSIGN_RHS_NOT_EPHEMERAL,
				instr.multi_assign.value,
				"RHS of assignment must be ephemeral"
			);
			return Result::ERROR;
		}

		if(value.isMultiValue() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_MULTI_ASSIGN_RHS_NOT_MULTI,
				instr.multi_assign.value,
				"RHS of multi-assignment must multi-value"
			);
			return Result::ERROR;
		}


		if(value.type_id.as<evo::SmallVector<TypeInfo::ID>>().size() != instr.targets.size()){
			this->emit_error(
				Diagnostic::Code::SEMA_MULTI_ASSIGN_RHS_WRONG_NUM,
				instr.multi_assign.value,
				"RHS of multi-assignment has wrong number of assignment targets",
				Diagnostic::Info(
					std::format(
						"Expression requires {}, got {}",
						value.type_id.as<evo::SmallVector<TypeInfo::ID>>().size(),
						instr.targets.size()
					)
				)
			);
			return Result::ERROR;
		}


		auto targets = evo::SmallVector<evo::Variant<sema::Expr, TypeInfo::ID>>();
		targets.reserve(instr.targets.size());
		for(size_t i = 0; const std::optional<SymbolProc::TermInfoID> target_id : instr.targets){
			EVO_DEFER([&](){ i += 1; });

			if(target_id.has_value() == false){
				targets.emplace_back(value.type_id.as<evo::SmallVector<TypeInfo::ID>>()[i]);
				continue;
			}

			const TermInfo& target = this->get_term_info(*target_id);

			if(target.is_concrete() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_CONCRETE,
					instr.multi_assign.assigns[i],
					"LHS of assignment must be concrete"
				);
				return Result::ERROR;
			}

			if(target.is_const() && target.value_state != TermInfo::ValueState::UNINIT){
				this->emit_error(
					Diagnostic::Code::SEMA_ASSIGN_LHS_NOT_MUTABLE,
					instr.multi_assign.assigns[i],
					"LHS of assignment must be mutable"
				);
				return Result::ERROR;
			}

			if(this->type_check<true, true>(
				target.type_id.as<TypeInfo::ID>(), value, "RHS of assignment", instr.multi_assign, true, unsigned(i)
			).ok == false){
				return Result::ERROR;
			}

			targets.emplace_back(target.getExpr());

			if(target.isUninitialized()){
				if(this->set_ident_value_state_if_needed(
					target.getExpr(), sema::ScopeLevel::ValueState::INIT, instr.multi_assign.assigns[i]
				).isError()){
					return Result::ERROR;
				}

			}else{
				if(this->context.getTypeManager().isTriviallyDeletable(target.type_id.as<TypeInfo::ID>()) == false){
					if(this->get_special_member_call_dependents<SpecialMemberKind::DELETE, true>(
						target,
						this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
						instr.multi_assign
					).isError()){
						return Result::ERROR;
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createDelete(target.getExpr(), target.type_id.as<TypeInfo::ID>())
					);
				}
			}
		}

		this->get_current_scope_level().stmtBlock().emplace_back(
			this->context.sema_buffer.createMultiAssign(std::move(targets), value.getExpr())
		);

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_discarding_assignment(const Instruction::DiscardingAssignment& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.infix).isError()){ return Result::ERROR; }

		const TermInfo& rhs = this->get_term_info(instr.rhs);

		if(rhs.isMultiValue()){
			auto targets = evo::SmallVector<evo::Variant<sema::Expr, TypeInfo::ID>>();
			targets.reserve(rhs.type_id.as<evo::SmallVector<TypeInfo::ID>>().size());

			for(TypeInfo::ID discard_type_id : rhs.type_id.as<evo::SmallVector<TypeInfo::ID>>()){
				targets.emplace_back(discard_type_id);
			}

			this->get_current_scope_level().stmtBlock().emplace_back(
				this->context.sema_buffer.createMultiAssign(std::move(targets), rhs.getExpr())
			);

		}else{
			this->get_current_scope_level().stmtBlock().emplace_back(
				this->context.sema_buffer.createAssign(std::nullopt, rhs.getExpr())
			);
		}

		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_try_else_begin(const Instruction::TryElseBegin& instr) -> Result {
		const AST::FuncCall& ast_func_call = this->source.getASTBuffer().getFuncCall(instr.try_else.attemptExpr);

		const TermInfo& target_term_info = this->get_term_info(instr.func_call_target);

		const evo::Expected<FuncCallImplData, bool> func_call_impl_res = this->func_call_impl<false, true>(
			ast_func_call, target_term_info, instr.func_call_args, instr.func_call_template_args
		);
		if(func_call_impl_res.has_value() == false){
			if(func_call_impl_res.error()){
				return Result::ERROR;
			}else{
				return Result::NEED_TO_WAIT;
			}
		}


		auto sema_args = evo::SmallVector<sema::Expr>();
		switch(target_term_info.value_category){
			case TermInfo::ValueCategory::METHOD_CALL: {
				const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
					target_term_info.getExpr().fakeTermInfoID()
				);

				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					sema_args.emplace_back(fake_term_info.expr);

				}else{
					if(this->get_package().warn.methodCallOnNonMethod){
						this->emit_warning(
							Diagnostic::Code::SEMA_WARN_METHOD_CALL_ON_NON_METHOD,
							ast_func_call,
							"Making a method call to a function that is not a method",
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info("Call the function by type accessor instead"),
								Diagnostic::Info(
									"Function declared here:",
									this->get_location(*func_call_impl_res.value().selected_func_id)
								),
							}
						);
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createUnusedExpr(fake_term_info.expr)
					);
				}
			} break;

			case TermInfo::ValueCategory::INTERFACE_CALL: {
				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
						target_term_info.getExpr().fakeTermInfoID()
					);

					sema_args.emplace_back(fake_term_info.expr);
				}
			} break;

			case TermInfo::ValueCategory::POLY_INTERFACE_CALL: {
				const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
					target_term_info.getExpr().fakeTermInfoID()
				);

				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					const sema::Expr extract_this = sema::Expr(
						this->context.sema_buffer.createInterfacePtrExtractThis(fake_term_info.expr)
					);

					sema_args.emplace_back(
						sema::Expr(this->context.sema_buffer.createDeref(extract_this, TypeManager::getTypeRawPtr()))
					);
				}
			} break;

			default: break;
		}



		for(const SymbolProc::TermInfoID& arg : instr.func_call_args){
			const TermInfo& arg_info = this->get_term_info(arg);
			sema_args.emplace_back(arg_info.getExpr());
		}


		// default values
		for(size_t i = sema_args.size(); i < func_call_impl_res.value().selected_func->params.size(); i+=1){
			sema_args.emplace_back(*func_call_impl_res.value().selected_func->params[i].defaultValue);
		}


		const BaseType::Function& selected_func_type = func_call_impl_res.value().selected_func_type;

		if(
			instr.try_else.exceptParams.size() != selected_func_type.errorTypes.size()
			&& selected_func_type.errorTypes[0].isVoid() == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_TRY_EXCEPT_PARAMS_WRONG_NUM,
				instr.try_else.elseTokenID,
				"Number of except parameters does not match attempt function call",
				Diagnostic::Info(
					std::format(
						"Expected {}, got {}", selected_func_type.errorTypes.size(), instr.try_else.exceptParams.size()
					)
				)
			);
			return Result::ERROR;
		}


		auto except_params = evo::SmallVector<sema::ExceptParam::ID>();
		except_params.reserve(instr.try_else.exceptParams.size());
		for(size_t i = 0; const Token::ID except_param_token_id : instr.try_else.exceptParams){
			EVO_DEFER([&](){ i += 1; });

			const Token& except_param_token = this->source.getTokenBuffer()[except_param_token_id];
			
			if(except_param_token.kind() == Token::lookupKind("_")){ continue; }

			const std::string_view except_param_ident_str = except_param_token.getString();

			const sema::ExceptParam::ID except_param_id = this->context.sema_buffer.createExceptParam(
				instr.try_else.exceptParams[i], uint32_t(i), selected_func_type.errorTypes[i].asTypeID()
			);
			except_params.emplace_back(except_param_id);

			if(this->add_ident_to_scope(
				except_param_ident_str, instr.try_else.exceptParams[i], true, except_param_id
			).isError()){
				return Result::ERROR;
			}

			this->add_ident_value_state(except_param_id, sema::ScopeLevel::ValueState::INIT);
		}



		if(target_term_info.value_category == TermInfo::ValueCategory::POLY_INTERFACE_CALL){
			const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
				target_term_info.getExpr().fakeTermInfoID()
			);

			const TypeInfo& expr_type_info = this->context.getTypeManager().getTypeInfo(fake_term_info.typeID);
			const BaseType::Interface& target_interface =
				this->context.getTypeManager().getInterface(expr_type_info.baseTypeID().interfaceID());

			const sema::Func& selected_func =
				this->context.getSemaBuffer().getFunc(*func_call_impl_res.value().selected_func_id);

			for(size_t i = 0; const sema::Func::ID method : target_interface.methods){
				if(method == *func_call_impl_res.value().selected_func_id){
					const sema::TryElseInterface::ID sema_try_else_interface_id = 
						this->context.sema_buffer.createTryElseInterface(
							fake_term_info.expr,
							selected_func.typeID,
							expr_type_info.baseTypeID().interfaceID(),
							uint32_t(i),
							std::move(sema_args),
							std::move(except_params)
						);

					this->get_current_scope_level().stmtBlock().emplace_back(sema_try_else_interface_id);

					sema::TryElseInterface& sema_try_else_interface =
						this->context.sema_buffer.try_else_interfaces[sema_try_else_interface_id];
					this->push_scope_level(&sema_try_else_interface.elseBlock);
				}

				i += 1;
			}

		}else{
			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(
				*func_call_impl_res.value().selected_func_id
			);

			const sema::TryElse::ID sema_try_else_id = this->context.sema_buffer.createTryElse(
				*func_call_impl_res.value().selected_func_id, std::move(sema_args), std::move(except_params)
			);

			this->get_current_scope_level().stmtBlock().emplace_back(sema_try_else_id);

			sema::TryElse& sema_try_else = this->context.sema_buffer.try_elses[sema_try_else_id];
			this->push_scope_level(&sema_try_else.elseBlock);
		}


		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_try_else_end() -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_begin_unsafe(const Instruction::BeginUnsafe& instr) -> Result {
		if(this->check_scope_isnt_terminated(instr.unsafe_stmt).isError()){ return Result::ERROR; }

		if(this->get_package().warn.alreadyUnsafe && this->currently_in_unsafe()){
			this->emit_warning(
				Diagnostic::Code::SEMA_WARN_ALREADY_UNSAFE,
				instr.unsafe_stmt,
				"Unsafe block in a scope that is already unsafe"
			);
		}


		const sema::BlockScope::ID block_scope_id = this->context.sema_buffer.createBlockScope();
		this->get_current_scope_level().stmtBlock().emplace_back(block_scope_id);

		sema::BlockScope& block_scope = this->context.sema_buffer.block_scopes[block_scope_id];

		this->push_scope_level(&block_scope.block);
		this->get_current_scope_level().setIsUnsafe();

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_end_unsafe() -> Result {
		if(this->pop_scope_level().isError()){ return Result::ERROR; }
		if(this->end_sub_scopes(Diagnostic::Location::NONE).isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_type_to_term(const Instruction::TypeToTerm& instr) -> Result {
		this->return_term_info(instr.to,
			TermInfo::ValueCategory::TYPE, this->get_type(instr.from)
		);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_require_this_def() -> Result {
		const std::optional<EncapsulatingSymbolID> current_type_scope = 
			this->scope.getCurrentTypeScopeIfExists();

		if(current_type_scope->is<BaseType::Struct::ID>()){
			const BaseType::Struct::ID current_struct_type_id = current_type_scope->as<BaseType::Struct::ID>();
			const TypeInfo::ID current_type_id = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(BaseType::ID(current_struct_type_id))
			);

			const std::optional<SymbolProc::ID> current_struct_symbol_proc =
				this->context.symbol_proc_manager.getTypeSymbolProc(current_type_id);

			const SymbolProc::WaitOnResult wait_on_result = this->context.symbol_proc_manager
				.getSymbolProc(*current_struct_symbol_proc)
				.waitOnDefIfNeeded(this->symbol_proc_id, this->context, *current_struct_symbol_proc);

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                return Result::SUCCESS;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*current_struct_symbol_proc);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                   return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
				case SymbolProc::WaitOnResult::WAS_ERRORED:               return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:evo::debugFatalBreak("Not possible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:     return Result::ERROR;
			}

			evo::unreachable();

		}else if(current_type_scope->is<BaseType::Union::ID>()){
			const BaseType::Union::ID current_union_type_id = current_type_scope->as<BaseType::Union::ID>();
			const TypeInfo::ID current_type_id = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(BaseType::ID(current_union_type_id))
			);

			const std::optional<SymbolProc::ID> current_union_symbol_proc =
				this->context.symbol_proc_manager.getTypeSymbolProc(current_type_id);

			const SymbolProc::WaitOnResult wait_on_result = this->context.symbol_proc_manager
				.getSymbolProc(*current_union_symbol_proc)
				.waitOnDefIfNeeded(this->symbol_proc_id, this->context, *current_union_symbol_proc);

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                return Result::SUCCESS;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*current_union_symbol_proc);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                   return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
				case SymbolProc::WaitOnResult::WAS_ERRORED:               return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:evo::debugFatalBreak("Not possible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:     return Result::ERROR;
			}

			evo::unreachable();

		}else if(current_type_scope->is<BaseType::Enum::ID>()){
			const BaseType::Enum::ID current_enum_type_id = current_type_scope->as<BaseType::Enum::ID>();
			const TypeInfo::ID current_type_id = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(BaseType::ID(current_enum_type_id))
			);

			const std::optional<SymbolProc::ID> current_enum_symbol_proc =
				this->context.symbol_proc_manager.getTypeSymbolProc(current_type_id);

			const SymbolProc::WaitOnResult wait_on_result = this->context.symbol_proc_manager
				.getSymbolProc(*current_enum_symbol_proc)
				.waitOnDefIfNeeded(this->symbol_proc_id, this->context, *current_enum_symbol_proc);

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                return Result::SUCCESS;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*current_enum_symbol_proc);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                   return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
				case SymbolProc::WaitOnResult::WAS_ERRORED:               return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:evo::debugFatalBreak("Not possible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:     return Result::ERROR;
			}

			evo::unreachable();

		}else{
			return Result::SUCCESS;
		}
	}


	auto SemanticAnalyzer::instr_wait_on_sub_symbol_proc_decl(const Instruction::WaitOnSubSymbolProcDecl& instr)
	-> Result {
		SymbolProc& sub_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(instr.symbol_proc_id);

		evo::debugAssert(sub_symbol_proc.isLocalSymbol(), "Should not call this instruction on a non-local symbol");

		sub_symbol_proc.sema_scope_id = 
			this->context.sema_buffer.scope_manager.copyScope(*this->symbol_proc.sema_scope_id);

		this->context.symbol_proc_manager.num_procs_not_done += 1;

		{
			const auto lock = std::scoped_lock(sub_symbol_proc.waiting_for_lock);
			sub_symbol_proc.setStatusInQueue();
			this->context.add_task_to_work_manager(instr.symbol_proc_id);
		}


		const SymbolProc::WaitOnResult wait_on_result = 
			sub_symbol_proc.waitOnDeclIfNeeded(this->symbol_proc_id, this->context, instr.symbol_proc_id);

		switch(wait_on_result){
			case SymbolProc::WaitOnResult::NOT_NEEDED:                 return Result::SUCCESS;
			case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
				this->context.symbol_proc_manager.symbol_proc_unsuspended();
				this->context.add_task_to_work_manager(instr.symbol_proc_id);
				[[fallthrough]];
			}
			case SymbolProc::WaitOnResult::WAITING:                    return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
			case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
			case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: evo::debugFatalBreak("Not possible");
			case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
		}

		evo::unreachable();
	}


	auto SemanticAnalyzer::instr_wait_on_sub_symbol_proc_def(const Instruction::WaitOnSubSymbolProcDef& instr)
	-> Result {
		SymbolProc& sub_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(instr.symbol_proc_id);

		evo::debugAssert(sub_symbol_proc.isLocalSymbol(), "Should not call this instruction on a non-local symbol");


		sub_symbol_proc.sema_scope_id = 
			this->context.sema_buffer.scope_manager.copyScope(*this->symbol_proc.sema_scope_id);

		this->context.symbol_proc_manager.num_procs_not_done += 1;

		{
			const auto lock = std::scoped_lock(sub_symbol_proc.waiting_for_lock);
			sub_symbol_proc.setStatusInQueue();
			this->context.add_task_to_work_manager(instr.symbol_proc_id);
		}


		const SymbolProc::WaitOnResult wait_on_result = 
			sub_symbol_proc.waitOnDefIfNeeded(this->symbol_proc_id, this->context, instr.symbol_proc_id);

		switch(wait_on_result){
			case SymbolProc::WaitOnResult::NOT_NEEDED:                 return Result::SUCCESS;
			case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
				this->context.symbol_proc_manager.symbol_proc_unsuspended();
				this->context.add_task_to_work_manager(instr.symbol_proc_id);
				[[fallthrough]];
			}
			case SymbolProc::WaitOnResult::WAITING:                    return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
			case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
			case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: evo::debugFatalBreak("Not possible");
			case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
		}

		evo::unreachable();
	}


	template<bool IS_COMPTIME, bool ERRORS>
	auto SemanticAnalyzer::instr_func_call_expr(const Instruction::FuncCallExpr<IS_COMPTIME, ERRORS>& instr)
	-> Result {
		const TermInfo& target_term_info = this->get_term_info(instr.target);

		const evo::Expected<FuncCallImplData, bool> func_call_impl_res = this->func_call_impl<IS_COMPTIME, ERRORS>(
			instr.func_call, target_term_info, instr.args, instr.template_args
		);
		if(func_call_impl_res.has_value() == false){
			if(func_call_impl_res.error()){
				return Result::ERROR;
			}else{
				return Result::NEED_TO_WAIT;
			}
		}

		auto sema_args = evo::SmallVector<sema::Expr>();
		bool all_args_are_comptime = true;
		switch(target_term_info.value_category){
			case TermInfo::ValueCategory::METHOD_CALL: {
				const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
					target_term_info.getExpr().fakeTermInfoID()
				);

				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					sema_args.emplace_back(fake_term_info.expr);

				}else{
					if(this->get_package().warn.methodCallOnNonMethod){
						this->emit_warning(
							Diagnostic::Code::SEMA_WARN_METHOD_CALL_ON_NON_METHOD,
							instr.func_call,
							"Making a method call to a function that is not a method",
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info("Call the function through the type instead"),
								Diagnostic::Info(
									"Function declared here:",
									this->get_location(*func_call_impl_res.value().selected_func_id)
								),
							}
						);
					}

					this->get_current_scope_level().stmtBlock().emplace_back(
						this->context.sema_buffer.createUnusedExpr(fake_term_info.expr)
					);
				}

				if(fake_term_info.valueStage != sema::FakeTermInfo::ValueStage::COMPTIME){
					all_args_are_comptime = false;
				}
			} break;

			case TermInfo::ValueCategory::INTERFACE_CALL: {
				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
						target_term_info.getExpr().fakeTermInfoID()
					);

					if(fake_term_info.valueStage != sema::FakeTermInfo::ValueStage::COMPTIME){
						all_args_are_comptime = false;
					}

					sema_args.emplace_back(fake_term_info.expr);
				}
			} break;

			case TermInfo::ValueCategory::POLY_INTERFACE_CALL: {
				const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
					target_term_info.getExpr().fakeTermInfoID()
				);

				if(func_call_impl_res.value().selected_func->isMethod(this->context)){
					const sema::Expr extract_this = sema::Expr(
						this->context.sema_buffer.createInterfacePtrExtractThis(fake_term_info.expr)
					);

					sema_args.emplace_back(
						sema::Expr(this->context.sema_buffer.createDeref(extract_this, TypeManager::getTypeRawPtr()))
					);
				}

				all_args_are_comptime = false;
			} break;

			default: break;
		}


		for(const SymbolProc::TermInfoID& arg : instr.args){
			const TermInfo& arg_info = this->get_term_info(arg);
			sema_args.emplace_back(arg_info.getExpr());
			if(arg_info.value_stage != TermInfo::ValueStage::COMPTIME){ all_args_are_comptime = false; }
		}


		if(target_term_info.value_category == TermInfo::ValueCategory::BUILTIN_TYPE_METHOD){
			return this->builtin_type_method_call<IS_COMPTIME>(
				target_term_info, std::move(sema_args), instr.output, instr.func_call
			);
		}

		if(func_call_impl_res.value().is_src_func() == false) [[unlikely]] {
			const IntrinsicFunc::Kind intrinsic_kind = target_term_info.getExpr().intrinsicFuncID();

			const Context::IntrinsicFuncInfo& intrinsic_func_info = this->context.getIntrinsicFuncInfo(intrinsic_kind);

			if(this->get_current_func().attributes.isComptime){
				if(intrinsic_func_info.allowedInInterptime == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
						instr.func_call.target,
						"Cannot call a non-comptime function within a comptime function"
					);
					return Result::ERROR;
				}

			}else{
				if(intrinsic_func_info.allowedInRuntime == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_RUNTIME,
						instr.func_call.target,
						"Cannot call a non-runtime function within a runtime function"
					);
					return Result::ERROR;
				}
			}

			switch(this->context.getConfig().mode){
				case Context::Config::Mode::COMPILE: {
					if(intrinsic_func_info.allowedInCompile == false){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
							instr.func_call.target,
							"Calling this intrinsic is not allowed in compile mode"
						);
						return Result::ERROR;
					}
				} break;

				case Context::Config::Mode::SCRIPTING: {
					if(intrinsic_func_info.allowedInScript == false){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
							instr.func_call.target,
							"Calling this intrinsic is not allowed in scripting mode"
						);
						return Result::ERROR;
					}
				} break;

				case Context::Config::Mode::BUILD_SYSTEM: {
					if(intrinsic_func_info.allowedInBuild == false){
						this->emit_error(
							Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
							instr.func_call.target,
							"Calling this intrinsic is not allowed in build mode"
						);
						return Result::ERROR;
					}
				} break;
			}

			const sema::FuncCall::ID sema_func_call_id = this->context.sema_buffer.createFuncCall(
				intrinsic_kind, std::move(sema_args)
			);


			const TermInfo::ValueStage value_stage = [&](){
				if constexpr(IS_COMPTIME){
					return TermInfo::ValueStage::COMPTIME;
				}else{
					if(this->get_current_func().attributes.isComptime){
						return TermInfo::ValueStage::INTERPTIME;
					}else{
						return TermInfo::ValueStage::RUNTIME;
					}
				}
			}();

			const evo::SmallVector<TypeInfo::VoidableID>& selected_func_type_return_params = 
				func_call_impl_res.value().selected_func_type.returnTypes;

			if(selected_func_type_return_params.size() == 1){ // single return
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					selected_func_type_return_params[0].asTypeID(),
					sema::Expr(sema_func_call_id)
				);
				
			}else{ // multi-return
				auto return_types = evo::SmallVector<TypeInfo::ID>();
				return_types.reserve(selected_func_type_return_params.size());
				for(TypeInfo::VoidableID return_type : selected_func_type_return_params){
					return_types.emplace_back(return_type.asTypeID());
				}

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					std::move(return_types),
					sema::Expr(sema_func_call_id)
				);
			}


			if constexpr(IS_COMPTIME){
				evo::debugFatalBreak("No comptime non-templated intrinsics exist");

			}else{
				if(this->get_current_func().attributes.isComptime){
					if(func_call_impl_res.value().selected_func->attributes.isComptime == false){
						this->emit_error(
							Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
							instr.func_call.target,
							"Cannot call a non-comptime function within a comptime function",
							Diagnostic::Info(
								"Called function was defined here:",
								this->get_location(*func_call_impl_res.value().selected_func_id)
							)
						);
						return Result::ERROR;
					}
				}

				return Result::SUCCESS;
			}
		}


		// default values
		for(size_t i = sema_args.size(); i < func_call_impl_res.value().selected_func->params.size(); i+=1){
			sema_args.emplace_back(*func_call_impl_res.value().selected_func->params[i].defaultValue);
		}


		if(target_term_info.value_category == TermInfo::ValueCategory::POLY_INTERFACE_CALL){
			return this->interface_func_call<IS_COMPTIME>(
				target_term_info, std::move(sema_args), *func_call_impl_res.value().selected_func_id, instr.output
			);
		}


		if(func_call_impl_res.value().selected_func_type.returnsVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_FUNC_RETURNS_VOID,
				instr.func_call.target,
				"Function returns `Void` which is not a value"
			);
			return Result::ERROR;
		}


		const sema::FuncCall::ID sema_func_call_id = this->context.sema_buffer.createFuncCall(
			*func_call_impl_res.value().selected_func_id, std::move(sema_args)
		);

		const TermInfo::ValueStage value_stage = [&](){
			if constexpr(IS_COMPTIME){
				return TermInfo::ValueStage::COMPTIME;
			}else{
				if(all_args_are_comptime && func_call_impl_res.value().selected_func->attributes.isComptime){
					return TermInfo::ValueStage::COMPTIME;
				}

				if(this->get_current_func().attributes.isComptime){
					return TermInfo::ValueStage::INTERPTIME;
				}else{
					return TermInfo::ValueStage::RUNTIME;
				}
			}
		}();


		const evo::SmallVector<TypeInfo::VoidableID>& selected_func_type_return_params = 
			func_call_impl_res.value().selected_func_type.returnTypes;

		if(selected_func_type_return_params.size() == 1){ // single return
			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				selected_func_type_return_params[0].asTypeID(),
				sema::Expr(sema_func_call_id)
			);
			
		}else{ // multi-return
			auto return_types = evo::SmallVector<TypeInfo::ID>();
			return_types.reserve(selected_func_type_return_params.size());
			for(TypeInfo::VoidableID return_param : selected_func_type_return_params){
				return_types.emplace_back(return_param.asTypeID());
			}

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				std::move(return_types),
				sema::Expr(sema_func_call_id)
			);
		}

		if constexpr(IS_COMPTIME){
			if(func_call_impl_res.value().selected_func->attributes.isComptime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
					instr.func_call.target,
					"Comptime value cannot be a call to a function that is not comptime",
					Diagnostic::Info(
						"Called function was defined here:",
						this->get_location(*func_call_impl_res.value().selected_func_id)
					)
				);
				return Result::ERROR;
			}


			SymbolProc& selected_func_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(
				*func_call_impl_res.value().selected_func->symbolProcID
			);

			const SymbolProc::WaitOnResult wait_on_result = selected_func_symbol_proc.waitOnPIRDefIfNeeded(
				this->symbol_proc_id, this->context, *func_call_impl_res.value().selected_func->symbolProcID
			);

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                break;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*func_call_impl_res.value().selected_func->symbolProcID);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                   return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
				case SymbolProc::WaitOnResult::WAS_ERRORED:               return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:evo::debugFatalBreak("Shouldn't be possible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:     evo::debugFatalBreak("Shouldn't be possible");
			}

			return Result::SUCCESS;

		}else{
			if(this->get_current_func().attributes.isComptime){
				if(func_call_impl_res.value().selected_func->attributes.isComptime == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
						instr.func_call.target,
						"Cannot call a non-comptime function within a comptime function",
						Diagnostic::Info(
							"Called function was defined here:",
							this->get_location(*func_call_impl_res.value().selected_func_id)
						)
					);
					return Result::ERROR;
				}

				this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(
					*func_call_impl_res.value().selected_func_id
				);
			}

			return Result::SUCCESS;
		}
	}


	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::builtin_type_method_call(
		const TermInfo& target_term_info,
		evo::SmallVector<sema::Expr>&& args,
		SymbolProc::TermInfoID output,
		const AST::FuncCall& ast_func_call
	) -> Result {
		evo::debugAssert(args.empty(), "Currently, none of these methods take any args (if changes, remove next line)");
		std::ignore = args;


		const TermInfo::BuiltinTypeMethod& builtin_type_method =
			target_term_info.type_id.as<TermInfo::BuiltinTypeMethod>();

		const sema::FakeTermInfo& fake_term_info = 
			this->context.getSemaBuffer().getFakeTermInfo(target_term_info.getExpr().fakeTermInfoID());

		switch(builtin_type_method.kind){
			case TermInfo::BuiltinTypeMethod::Kind::OPT_EXTRACT: {
				if constexpr(IS_COMPTIME){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
						ast_func_call.target,
						"Comptime value cannot be a call to a function that is not comptime"
					);
					return Result::ERROR;
				}else{
					const TypeInfo::ID held_type_id = this->context.type_manager.getOrCreateTypeInfo(
						this->context.getTypeManager().getTypeInfo(fake_term_info.typeID).copyWithPoppedQualifier()
					);

					this->return_term_info(output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::convertValueStage(fake_term_info.valueStage),
						TermInfo::ValueState::NOT_APPLICABLE,
						held_type_id,
						sema::Expr(
							this->context.sema_buffer.createOptionalExtract(fake_term_info.expr, fake_term_info.typeID)
						)
					);
					return Result::SUCCESS;
				}

			} break;

			case TermInfo::BuiltinTypeMethod::Kind::ARRAY_SIZE: {
				const BaseType::Array& array_type = this->context.getTypeManager().getArray(
					this->context.getTypeManager().getTypeInfo(fake_term_info.typeID).baseTypeID().arrayID()
				);

				uint64_t size = 1;
				for(uint64_t dimension : array_type.dimensions){
					size *= dimension;
				}

				const sema::IntValue::ID created_int_value = this->context.sema_buffer.createIntValue(
					core::GenericInt::create<uint64_t>(size),
					this->context.getTypeManager().getTypeInfo(TypeManager::getTypeUSize()).baseTypeID()
				);

				this->return_term_info(output,
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::convertValueStage(fake_term_info.valueStage),
					TermInfo::ValueState::NOT_APPLICABLE,
					TypeManager::getTypeUSize(),
					sema::Expr(created_int_value)
				);
				return Result::SUCCESS;
			} break;

			case TermInfo::BuiltinTypeMethod::Kind::ARRAY_DIMENSIONS: {
				const BaseType::Array& array_type = this->context.getTypeManager().getArray(
					this->context.getTypeManager().getTypeInfo(fake_term_info.typeID).baseTypeID().arrayID()
				);

				const BaseType::Function& call_type = this->context.getTypeManager().getFunction(
					this->context.getTypeManager().getTypeInfo(builtin_type_method.typeID).baseTypeID().funcID()
				);

				auto values = evo::SmallVector<sema::Expr>();
				values.reserve(array_type.dimensions.size());
				for(uint64_t dimension : array_type.dimensions){
					values.emplace_back(
						this->context.sema_buffer.createIntValue(
							core::GenericInt::create<uint64_t>(dimension),
							this->context.getTypeManager().getTypeInfo(TypeManager::getTypeUSize()).baseTypeID()
						)
					);
				}

				const TypeInfo::ID return_type_id = call_type.returnTypes[0].asTypeID();


				const sema::AggregateValue::ID created_aggregate_value = this->context.sema_buffer.createAggregateValue(
					std::move(values), this->context.getTypeManager().getTypeInfo(return_type_id).baseTypeID()
				);
				
				this->return_term_info(output,
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::convertValueStage(fake_term_info.valueStage),
					TermInfo::ValueState::NOT_APPLICABLE,
					return_type_id,
					sema::Expr(created_aggregate_value)
				);
				return Result::SUCCESS;
			} break;

			case TermInfo::BuiltinTypeMethod::Kind::ARRAY_DATA: {
				if constexpr(IS_COMPTIME){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
						ast_func_call.target,
						"Comptime value cannot be a call to a function that is not comptime"
					);
					return Result::ERROR;
				}else{
					const BaseType::Function& call_type = this->context.getTypeManager().getFunction(
						this->context.getTypeManager().getTypeInfo(builtin_type_method.typeID).baseTypeID().funcID()
					);

					const TypeInfo::ID return_type_id = call_type.returnTypes[0].asTypeID();

					this->return_term_info(output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::convertValueStage(fake_term_info.valueStage),
						TermInfo::ValueState::NOT_APPLICABLE,
						return_type_id,
						sema::Expr(this->context.sema_buffer.createAddrOf(fake_term_info.expr))
					);
					return Result::SUCCESS;
				}
			} break;

			case TermInfo::BuiltinTypeMethod::Kind::ARRAY_REF_SIZE: {
				if constexpr(IS_COMPTIME){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
						ast_func_call.target,
						"Comptime value cannot be a call to a function that is not comptime"
					);
					return Result::ERROR;
				}else{
					const BaseType::ArrayRef::ID array_ref_type_id = 
						this->context.getTypeManager().getTypeInfo(fake_term_info.typeID).baseTypeID().arrayRefID();

					const sema::ArrayRefSize::ID created_array_ref_size =
						this->context.sema_buffer.createArrayRefSize(fake_term_info.expr, array_ref_type_id);

					this->return_term_info(output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::convertValueStage(fake_term_info.valueStage),
						TermInfo::ValueState::NOT_APPLICABLE,
						TypeManager::getTypeUSize(),
						sema::Expr(created_array_ref_size)
					);
					return Result::SUCCESS;
				}
			} break;
			
			case TermInfo::BuiltinTypeMethod::Kind::ARRAY_REF_DIMENSIONS: {
				if constexpr(IS_COMPTIME){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
						ast_func_call.target,
						"Comptime value cannot be a call to a function that is not comptime"
					);
					return Result::ERROR;
				}else{
					const BaseType::ArrayRef::ID array_ref_type_id = 
						this->context.getTypeManager().getTypeInfo(fake_term_info.typeID).baseTypeID().arrayRefID();

					const sema::ArrayRefDimensions::ID created_array_ref_dimensions =
						this->context.sema_buffer.createArrayRefDimensions(fake_term_info.expr, array_ref_type_id);

					const BaseType::Function& call_type = this->context.getTypeManager().getFunction(
						this->context.getTypeManager().getTypeInfo(builtin_type_method.typeID).baseTypeID().funcID()
					);

					const TypeInfo::ID return_type = call_type.returnTypes[0].asTypeID();

					this->return_term_info(output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::convertValueStage(fake_term_info.valueStage),
						TermInfo::ValueState::NOT_APPLICABLE,
						return_type,
						sema::Expr(created_array_ref_dimensions)
					);
					return Result::SUCCESS;
				}
			} break;

			case TermInfo::BuiltinTypeMethod::Kind::ARRAY_REF_DATA: {
				if constexpr(IS_COMPTIME){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
						ast_func_call.target,
						"Comptime value cannot be a call to a function that is not comptime"
					);
					return Result::ERROR;
				}else{
					const BaseType::ArrayRef::ID array_ref_type_id = 
						this->context.getTypeManager().getTypeInfo(fake_term_info.typeID).baseTypeID().arrayRefID();

					const sema::ArrayRefData::ID created_array_ref_data =
						this->context.sema_buffer.createArrayRefData(fake_term_info.expr, array_ref_type_id);

					const BaseType::Function& call_type = this->context.getTypeManager().getFunction(
						this->context.getTypeManager().getTypeInfo(builtin_type_method.typeID).baseTypeID().funcID()
					);

					const TypeInfo::ID return_type = call_type.returnTypes[0].asTypeID();

					this->return_term_info(output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::convertValueStage(fake_term_info.valueStage),
						TermInfo::ValueState::NOT_APPLICABLE,
						return_type,
						sema::Expr(created_array_ref_data)
					);
					return Result::SUCCESS;
				}
			} break;
		}
		evo::debugFatalBreak("Unknown builtin-type method");
	}


	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::interface_func_call(
		const TermInfo& target_term_info,
		evo::SmallVector<sema::Expr>&& args,
		sema::Func::ID selected_func_call_id,
		SymbolProc::TermInfoID output
	) -> Result {
		const sema::FakeTermInfo& fake_term_info = this->context.getSemaBuffer().getFakeTermInfo(
			target_term_info.getExpr().fakeTermInfoID()
		);

		const TypeInfo& expr_type_info = this->context.getTypeManager().getTypeInfo(fake_term_info.typeID);

		const BaseType::PolyInterfaceRef& target_poly_interface_ref = 
			this->context.getTypeManager().getPolyInterfaceRef(expr_type_info.baseTypeID().polyInterfaceRefID());

		const BaseType::Interface& target_interface =
			this->context.getTypeManager().getInterface(target_poly_interface_ref.interfaceID);

		const sema::Func& selected_func = this->context.getSemaBuffer().getFunc(selected_func_call_id);
		const BaseType::Function& selected_func_type = this->context.getTypeManager().getFunction(selected_func.typeID);

		for(size_t i = 0; const sema::Func::ID method : target_interface.methods){
			if(method == selected_func_call_id){
				const sema::InterfaceCall::ID interface_call_id = this->context.sema_buffer.createInterfaceCall(
					fake_term_info.expr,
					selected_func.typeID,
					target_poly_interface_ref.interfaceID,
					uint32_t(i),
					std::move(args)
				);

				if(selected_func_type.returnTypes.size() == 1){ // single return
					this->return_term_info(output,
						TermInfo::ValueCategory::EPHEMERAL,
						target_term_info.value_stage,
						TermInfo::ValueState::NOT_APPLICABLE,
						selected_func_type.returnTypes[0].asTypeID(),
						sema::Expr(interface_call_id)
					);
					
				}else{ // multi-return
					auto return_types = evo::SmallVector<TypeInfo::ID>();
					return_types.reserve(selected_func_type.returnTypes.size());
					for(TypeInfo::VoidableID return_param : selected_func_type.returnTypes){
						return_types.emplace_back(return_param.asTypeID());
					}

					this->return_term_info(output,
						TermInfo::ValueCategory::EPHEMERAL,
						target_term_info.value_stage,
						TermInfo::ValueState::NOT_APPLICABLE,
						std::move(return_types),
						sema::Expr(interface_call_id)
					);
				}

				return Result::SUCCESS;
			}

			i += 1;
		}

		evo::debugFatalBreak("Didn't find selected func id");
	}




	auto SemanticAnalyzer::instr_comptime_func_call_run(const Instruction::ComptimeFuncCallRun& instr) -> Result {
		const TermInfo& func_call_term = this->get_term_info(instr.target);

		if(func_call_term.getExpr().kind() != sema::Expr::Kind::FUNC_CALL){
			evo::debugAssert(
				func_call_term.getExpr().kind() == sema::Expr::Kind::INT_VALUE
				|| func_call_term.getExpr().kind() == sema::Expr::Kind::FLOAT_VALUE
				|| func_call_term.getExpr().kind() == sema::Expr::Kind::BOOL_VALUE
				|| func_call_term.getExpr().kind() == sema::Expr::Kind::STRING_VALUE
				|| func_call_term.getExpr().kind() == sema::Expr::Kind::AGGREGATE_VALUE
				|| func_call_term.getExpr().kind() == sema::Expr::Kind::CHAR_VALUE,
				"Invalid builtin comptime func call (expected func call or output of comptime builtin method call)"
			);

			this->return_term_info(instr.output, func_call_term);
			return Result::SUCCESS;
		}

		const sema::FuncCall& sema_func_call =
			this->context.getSemaBuffer().getFuncCall(func_call_term.getExpr().funcCallID());

		const sema::Func& target_func = 
			this->context.getSemaBuffer().getFunc(sema_func_call.target.as<sema::Func::ID>()); 

		const BaseType::Function& target_func_type = this->context.getTypeManager().getFunction(target_func.typeID);

		evo::debugAssert(target_func_type.returnsVoid() == false, "Comptime function call expr cannot return void");
		evo::debugAssert(target_func.status == sema::Func::Status::DEF_DONE, "def of func not completed");

		auto args = evo::SmallVector<core::GenericValue>();
		args.reserve(target_func.params.size() && size_t(target_func_type.hasNamedReturns));
		for(size_t i = 0; const SymbolProc::TermInfoID& arg_id : instr.args){
			const TermInfo& arg = this->get_term_info(arg_id);

			args.emplace_back(this->sema_expr_to_generic_value(arg.getExpr()));

			i += 1;
		}

		for(size_t i = args.size(); i < target_func.params.size(); i+=1){
			args.emplace_back(this->sema_expr_to_generic_value(*target_func.params[i].defaultValue));
		}

		const bool uses_rvo = target_func_type.hasNamedReturns 
			|| target_func_type.isImplicitRVO(this->context.getTypeManager());


		auto output = core::GenericValue();

		if(uses_rvo){
			output = core::GenericValue::createUninit(
				this->context.getTypeManager().numBytes(target_func_type.returnTypes[0].asTypeID())
			);

			args.emplace_back(core::GenericValue::createPtr(output.writableDataRange().data()));
		}

		// Uncomment this to print out the state of the comptime pir module (for debugging purposes)
		// {
		// 	auto printer = core::Printer::createConsole();
		// 	pir::printModule(this->context.pir_module, printer);
		// }

		// core::GenericValue run_result = this->context.comptime_jit_engine.runFunc(
		// 	this->context.pir_module,
		// 	*target_func.comptimeJITInterfaceFunc,
		// 	args,
		// 	this->context.pir_module.getFunction(*target_func.comptimeJITFunc).getReturnType()
		// );


		evo::Expected<core::GenericValue, pir::ExecutionEngine::FuncRunError> run_result = 
			this->context.comptime_execution_engine.runFunction(*target_func.comptimeJITFunc, args);

		if(run_result.has_value() == false){
			auto infos = evo::SmallVector<Diagnostic::Info>();

			switch(run_result.error().code){
				case pir::ExecutionEngine::FuncRunError::Code::ABORT: {
					infos.emplace_back("Cause of error: abort");
				} break;

				case pir::ExecutionEngine::FuncRunError::Code::EXCEEDED_MAX_CALL_DEPTH: {
					infos.emplace_back(
						std::format(
							"Cause of error: exceeded max call depth ({})",
							this->context.comptime_execution_engine.maxCallDepth()
						)
					);
				} break;

				case pir::ExecutionEngine::FuncRunError::Code::BREAKPOINT: {
					infos.emplace_back("Cause of error: breakpoint");
				} break;

				case pir::ExecutionEngine::FuncRunError::Code::OUT_OF_BOUNDS_ACCESS: {
					infos.emplace_back("Cause of error: out-of-bounds access");
				} break;

				case pir::ExecutionEngine::FuncRunError::Code::NULLPTR_ACCESS: {
					infos.emplace_back("Cause of error: null-pointer access");
				} break;

				case pir::ExecutionEngine::FuncRunError::Code::SEG_FAULT: {
					infos.emplace_back("Cause of error: segmentation fault");
				} break;

				case pir::ExecutionEngine::FuncRunError::Code::ARITHMETIC_WRAP: {
					infos.emplace_back("Cause of error: arithmetic wrap");
				} break;

				case pir::ExecutionEngine::FuncRunError::Code::FLOATING_POINT_EXCEPTION: {
					infos.emplace_back("Cause of error: floating-point exception");
				} break;

				case pir::ExecutionEngine::FuncRunError::Code::UNKNOWN_EXCEPTION: {
					infos.emplace_back("Cause of error: unknown exception");
				} break;
			}

			Diagnostic::Info& stack_trace_info = infos.emplace_back("Stack Trace:");
			for(
				size_t i = run_result.error().stackTrace.size() - 1;
				const pir::Function::ID pir_func_id : run_result.error().stackTrace | std::views::reverse
			){
				const pir::Function& pir_func = this->context.getPIRModule().getFunction(pir_func_id);
				stack_trace_info.subInfos.emplace_back(std::format("({}) {}", i, pir_func.getName()));

				i -= 1;
			}

			this->emit_error(
				Diagnostic::Code::SEMA_ERROR_IN_COMPTIME_CALL,
				instr.func_call,
				"Error occured while running comptime function call",
				std::move(infos)
			);
			return Result::ERROR;
		}


		if(target_func_type.hasErrorReturn()){
			// 	// TODO(FUTURE): better messaging
			// 	this->emit_error(
			// 		Diagnostic::Code::SEMA_ERROR_RETURNED_FROM_COMPTIME_FUNC_RUN,
			// 		instr.func_call,
			// 		"Comptime function returned error"
			// 	);
			// 	return Result::ERROR;

			this->emit_error(
				Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
				instr.func_call,
				"Running a comptime function that has error returns is unimplemented"
			);
			return Result::ERROR;

		}else{
			const TypeInfo& target_func_return_type = this->context.getTypeManager().getTypeInfo(
				target_func_type.returnTypes[0].asTypeID()
			);


			if(uses_rvo == false){
				output = std::move(run_result.value());
			}

			if(target_func_return_type.qualifiers().empty() == false){
				this->emit_error(
					Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
					instr.func_call,
					"Running a comptime function as a comptime expression that returns "
						"a qualified type is unimplemented"
				);
				return Result::ERROR;
			}


			const sema::Expr return_sema_expr =
				this->generic_value_to_sema_expr(output, target_func_return_type);

			this->return_term_info(instr.output,
				TermInfo(
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					func_call_term.type_id,
					return_sema_expr
				)
			);
			return Result::SUCCESS;
		}

	}


	template<Instruction::Language LANGUAGE>
	auto SemanticAnalyzer::instr_import(const Instruction::Import<LANGUAGE>& instr) -> Result {
		TermInfo& location_str_term_info = this->get_term_info(instr.location);

		const std::string_view diagnostic_location_str = [&]() -> std::string_view {
			if constexpr(LANGUAGE == Instruction::Language::PANTHER){
				return "Path argument in `@import`";

			}else if constexpr(LANGUAGE == Instruction::Language::C){
				return "Path argument in `@importC`";
				
			}else if constexpr(LANGUAGE == Instruction::Language::CPP){
				return "Path argument in `@importCpp`";
				
			}else{
				static_assert(false, "Unknown language");
			}
		}();

		if(this->type_check<true, true>(
			TypeManager::getTypeStringRef(),
			location_str_term_info,
			diagnostic_location_str,
			instr.func_call.args[0].value
		).ok == false){
			return Result::ERROR;;
		}


		const std::string_view lookup_path = this->extract_string_from_sema_expr(location_str_term_info.getExpr());

		auto lookup_error = std::optional<Context::LookupSourceIDError>();

		if constexpr(LANGUAGE == Instruction::Language::PANTHER){
			const evo::Expected<Source::ID, Context::LookupSourceIDError> import_lookup = 
				this->context.lookupSourceID(lookup_path, this->source);

			if(import_lookup.has_value()){
				this->return_term_info(instr.output, TermInfo(TermInfo::ValueCategory::MODULE, import_lookup.value()));
				return Result::SUCCESS;
			}
			
			lookup_error = import_lookup.error();

		}else if constexpr(LANGUAGE == Instruction::Language::C || LANGUAGE == Instruction::Language::CPP){
			const evo::Expected<ClangSource::ID, Context::LookupSourceIDError> import_lookup = 
				this->context.lookupClangSourceID(lookup_path, this->source, LANGUAGE == Instruction::Language::CPP);

			if(import_lookup.has_value()){
				this->return_term_info(instr.output, 
					TermInfo(TermInfo::ValueCategory::CLANG_MODULE, import_lookup.value())
				);
				return Result::SUCCESS;
			}
			
			lookup_error = import_lookup.error();

		}else{
			static_assert(false, "Unknown language");
		}


		switch(*lookup_error){
			case Context::LookupSourceIDError::EMPTY_PATH: {
				this->emit_error(
					Diagnostic::Code::SEMA_FAILED_TO_IMPORT_MODULE,
					instr.func_call.args[0].value,
					"Empty path is an invalid import location"
				);
				return Result::ERROR;
			} break;

			case Context::LookupSourceIDError::SAME_AS_CALLER: {
				// TODO(FUTURE): better messaging
				this->emit_error(
					Diagnostic::Code::SEMA_FAILED_TO_IMPORT_MODULE,
					instr.func_call.args[0].value,
					"Cannot import self"
				);
				return Result::ERROR;
			} break;

			case Context::LookupSourceIDError::NOT_ONE_OF_SOURCES: {
				this->emit_error(
					Diagnostic::Code::SEMA_FAILED_TO_IMPORT_MODULE,
					instr.func_call.args[0].value,
					std::format("File \"{}\" is not one of the files being compiled", lookup_path)
				);
				return Result::ERROR;
			} break;

			case Context::LookupSourceIDError::DOESNT_EXIST: {
				this->emit_error(
					Diagnostic::Code::SEMA_FAILED_TO_IMPORT_MODULE,
					instr.func_call.args[0].value,
					std::format("Couldn't find file \"{}\"", lookup_path)
				);
				return Result::ERROR;
			} break;

			case Context::LookupSourceIDError::FAILED_DURING_ANALYSIS_OF_NEWLY_LOADED: {
				return Result::ERROR;
			} break;

			case Context::LookupSourceIDError::WRONG_LANGUAGE: {
				this->emit_error(
					Diagnostic::Code::SEMA_FAILED_TO_IMPORT_MODULE,
					instr.func_call.args[0].value,
					std::format(
						"Couldn't import file \"{}\" as this language as it was included as a different one",
						lookup_path
					)
				);
				return Result::ERROR;
			} break;
		}

		evo::unreachable();
	}



	auto SemanticAnalyzer::instr_is_macro_defined(const Instruction::IsMacroDefined& instr) -> Result {
		const TermInfo& clang_module_term_info = this->get_term_info(instr.clang_module);
		const TermInfo& macro_name_term_info = this->get_term_info(instr.macro_name);


		if(clang_module_term_info.value_category != TermInfo::ValueCategory::CLANG_MODULE){
			this->emit_error(
				Diagnostic::Code::SEMA_IS_MACRO_DEFINED_ARG_NOT_MODULE,
				instr.func_call.args[0].value,
				"First arugment in `@isMacroDefined` must be a C or C++ module"
			);
			return Result::ERROR;
		}

		if(
			macro_name_term_info.type_id.is<TypeInfo::ID>() == false
			|| macro_name_term_info.getExpr().kind() != sema::Expr::Kind::STRING_VALUE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_IS_MACRO_DEFINED_ARG_NOT_STRING,
				instr.func_call.args[1].value,
				"Second arugment in `@isMacroDefined` must be a string"
			);
			return Result::ERROR;
		}


		const ClangSource& clang_module = 
			this->context.source_manager[clang_module_term_info.type_id.as<ClangSourceID>()];

		const sema::StringValue macro_name = 
			this->context.getSemaBuffer().getStringValue(macro_name_term_info.getExpr().stringValueID());

		const bool is_macro_defined = clang_module.getDefine(macro_name.value).has_value();
			
		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			TermInfo::ValueStage::COMPTIME,
			TermInfo::ValueState::NOT_APPLICABLE,
			TypeManager::getTypeBool(),
			sema::Expr(this->context.sema_buffer.createBoolValue(is_macro_defined))
		);
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_make_init_ptr(const Instruction::MakeInitPtr& instr) -> Result {
		const TermInfo& uninit_ptr_value = this->get_term_info(instr.uninit_ptr);

		if(uninit_ptr_value.type_id.is<TypeInfo::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_MAKE_INIT_PTR_ARG_INVALID,
				instr.func_call.args[0].value,
				"Arugment in `@makeInitPtr` must be an uninitialized-qualified pointer value"
			);
			return Result::ERROR;
		}

		if(uninit_ptr_value.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_MAKE_INIT_PTR_ARG_INVALID,
				instr.func_call.args[0].value,
				"Arugment in `@makeInitPtr` must be concrete"
			);
			return Result::ERROR;
		}

		if(uninit_ptr_value.getExpr().kind() != sema::Expr::Kind::VAR){
			this->emit_error(
				Diagnostic::Code::SEMA_MAKE_INIT_PTR_ARG_INVALID,
				instr.func_call.args[0].value,
				"Arugment in `@makeInitPtr` must be a value"
			);
			return Result::ERROR;
		}

		const TypeInfo& uninit_ptr_type =
			this->context.getTypeManager().getTypeInfo(uninit_ptr_value.type_id.as<TypeInfo::ID>());

		if(uninit_ptr_type.isUninitPointer() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_MAKE_INIT_PTR_ARG_INVALID,
				instr.func_call.args[0].value,
				"Arugment in `@makeInitPtr` must be an uninitialized-qualified pointer value"
			);
			return Result::ERROR;;
		}


		if(
			this->get_ident_value_state(sema::UninitPtrLocalVar(uninit_ptr_value.getExpr().varID()))
				!= TermInfo::ValueState::INIT
		){
			this->emit_error(
				Diagnostic::Code::SEMA_MAKE_INIT_PTR_ARG_INVALID,
				instr.func_call.args[0].value,
				"Pointee of argument in `@makeInitPtr` must be initialized"
			);
			return Result::ERROR;;
		}


		auto output_qualifiers = evo::SmallVector<TypeInfo::Qualifier>(
			uninit_ptr_type.qualifiers().begin(), uninit_ptr_type.qualifiers().end()
		);
		output_qualifiers.back().isUninit = false;

		const TypeInfo::ID output_type_id = this->context.type_manager.getOrCreateTypeInfo(
			TypeInfo(uninit_ptr_type.baseTypeID(), std::move(output_qualifiers))
		);

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			TermInfo::ValueStage::COMPTIME,
			TermInfo::ValueState::NOT_APPLICABLE,
			output_type_id,
			sema::Expr(this->context.sema_buffer.createCopy(uninit_ptr_value.getExpr(), output_type_id, true))
		);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_comptime_error(const Instruction::ComptimeError& instr) -> Result {
		TermInfo& message_term_info = this->get_term_info(instr.message);


		if(this->check_term_isnt_type(message_term_info, instr.func_call.args[0].value).isError()){
			return Result::ERROR;
		}


		if(this->type_check<true, true>(
			TypeManager::getTypeStringRef(),
			message_term_info,
			"Message in @comptimeError",
			instr.func_call.args[0].value
		).ok == false){
			return Result::ERROR;
		}

		const std::string_view message = this->extract_string_from_sema_expr(message_term_info.getExpr());


		this->emit_error(
			Diagnostic::Code::SEMA_COMPTIME_ERROR,
			instr.func_call,
			std::format("Comptime error with message: \"{}\"", message)
		);

		return Result::ERROR;
	}


	auto SemanticAnalyzer::instr_comptime_assert(const Instruction::ComptimeAssert& instr) -> Result {
		TermInfo& cond_term_info = this->get_term_info(instr.cond);
		if(this->check_term_isnt_type(cond_term_info, instr.func_call.args[0].value).isError()){
			return Result::ERROR;
		}

		if(this->type_check<true, true>(
			this->context.getTypeManager().getTypeBool(),
			cond_term_info,
			"Condition in @comptimeAssert",
			instr.func_call.args[0].value
		).ok == false){
			return Result::ERROR;
		}

		const bool cond = this->context.sema_buffer.getBoolValue(cond_term_info.getExpr().boolValueID()).value;
		if(cond){ return Result::SUCCESS; }

		if(instr.message.has_value()){
			TermInfo& message_term_info = this->get_term_info(*instr.message);
			if(this->check_term_isnt_type(message_term_info, instr.func_call.args[1].value).isError()){
				return Result::ERROR;
			}

			if(this->type_check<true, true>(
				TypeManager::getTypeStringRef(),
				message_term_info,
				"Message in @comptimeAssert",
				instr.func_call.args[1].value
			).ok == false){
				return Result::ERROR;
			}

			const std::string_view message = this->extract_string_from_sema_expr(message_term_info.getExpr());


			this->emit_error(
				Diagnostic::Code::SEMA_COMPTIME_ERROR,
				instr.func_call,
				std::format("Failed comptime assert with message: \"{}\"", message)
			);
		}else{
			this->emit_error(
				Diagnostic::Code::SEMA_COMPTIME_ERROR,
				instr.func_call,
				"Failed comptime assert"
			);
		}

		return Result::ERROR;
	}





	auto SemanticAnalyzer::instr_template_intrinsic_func_call(const Instruction::TemplateIntrinsicFuncCall& instr)
	-> Result {
		const TermInfo& target_term_info = this->get_term_info(instr.target);


		const Context::TemplateIntrinsicFuncInfo& template_intrinsic_func_info = 
			this->context.getTemplateIntrinsicFuncInfo(target_term_info.type_id.as<TemplateIntrinsicFunc::Kind>());

		if(this->get_current_func().attributes.isComptime){
			if(template_intrinsic_func_info.allowedInInterptime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ISNT_INTERPTIME,
					instr.func_call.target,
					"Cannot call a non-interptime intrinsic function within a comptime function"
				);
				return Result::ERROR;
			}

		}else{
			if(template_intrinsic_func_info.allowedInRuntime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ISNT_RUNTIME,
					instr.func_call.target,
					"Cannot call a non-runtime function within a runtime function"
				);
				return Result::ERROR;
			}
		}


		switch(this->context.getConfig().mode){
			case Context::Config::Mode::COMPILE: {
				if(template_intrinsic_func_info.allowedInCompile == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
						instr.func_call.target,
						"Calling this intrinsic is not allowed in compile mode"
					);
					return Result::ERROR;
				}
			} break;

			case Context::Config::Mode::SCRIPTING: {
				if(template_intrinsic_func_info.allowedInScript == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
						instr.func_call.target,
						"Calling this intrinsic is not allowed in scripting mode"
					);
					return Result::ERROR;
				}
			} break;

			case Context::Config::Mode::BUILD_SYSTEM: {
				if(template_intrinsic_func_info.allowedInBuild == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
						instr.func_call.target,
						"Calling this intrinsic is not allowed in build mode"
					);
					return Result::ERROR;
				}
			} break;
		}



		auto template_args = evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>();
		for(const SymbolProcTermInfoID& template_arg_id : instr.template_args){
			const TermInfo& template_arg = this->get_term_info(template_arg_id);

			if(template_arg.value_category == TermInfo::ValueCategory::TYPE){
				template_args.emplace_back(template_arg.type_id.as<TypeInfo::VoidableID>());
			}else{
				template_args.emplace_back(this->sema_expr_to_generic_value(template_arg.getExpr()));
			}
		}

		auto args = evo::SmallVector<sema::Expr>();
		for(const SymbolProc::TermInfoID& arg_term_info_id : instr.args){
			args.emplace_back(this->get_term_info(arg_term_info_id).getExpr());
		}


		///////////////////////////////////
		// helper functions

		const auto check_correct_num_template_args = [&](size_t correct_num) -> evo::Result<> {
			if(template_args.size() != correct_num){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_WRONG_NUM_TEMPLATE_ARGS,
					instr.func_call.target,
					"Incorrect number of template arguments",
					Diagnostic::Info(std::format("Expected {}, got {}", correct_num, template_args.size()))
				);
				return evo::resultError;
			}

			return evo::Result<>();
		};

		const auto check_template_arg_is_type = [&](size_t arg_index) -> evo::Result<> {
			if(template_args[arg_index].is<TypeInfo::VoidableID>() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					"This template argument must be a type"
				);
				return evo::resultError;
			}

			return evo::Result<>();
		};

		const auto check_template_arg_type_not_void = [&](size_t arg_index) -> evo::Result<> {
			if(template_args[arg_index].is<TypeInfo::VoidableID>() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					"This template argument must be a type"
				);
				return evo::resultError;
			}
			
			if(template_args[arg_index].as<TypeInfo::VoidableID>().isVoid()){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					"This template argument cannot be type `Void`"
				);
				return evo::resultError;
			}

			return evo::Result<>();
		};


		const auto check_template_arg_is_expr = [&](size_t arg_index, TypeInfo::ID type_id) -> evo::Result<> {
			if(template_args[arg_index].is<core::GenericValue>() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					"This template argument must be an expression"
				);
				return evo::resultError;
			}

			const TermInfo& arg_term_info = this->get_term_info(instr.template_args[arg_index]);
			if(this->context.type_manager.decayType<false, false>(arg_term_info.type_id.as<TypeInfo::ID>()) != type_id){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					std::format(
						"This template argument must be type `{}`",
						this->context.getTypeManager().printType(type_id, this->context)
					)
				);
				return evo::resultError;
			}

			return evo::Result<>();
		};

		
		///////////////////////////////////
		// select intrinsic

		switch(target_term_info.type_id.as<TemplateIntrinsicFunc::Kind>()){
			case TemplateIntrinsicFunc::Kind::ATOMIC_STORE: {
				const BuiltinModule& builtin_module_pthr = this->context.getSourceManager()[BuiltinModule::ID::PTHR];
				const TypeInfo::ID atomic_ordering_type_id = this->context.type_manager.getOrCreateTypeInfo(
					TypeInfo(builtin_module_pthr.getSymbol("AtomicOrdering")->as<BaseType::ID>())
				);

				if(check_correct_num_template_args(3).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(2, atomic_ordering_type_id).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& target_type = this->context.getTypeManager().getTypeInfo(target_type_id);

				const TypeInfo::ID value_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& value_type = this->context.getTypeManager().getTypeInfo(value_type_id);

				if(target_type.isMutPointerNotOptional() == false){
					auto infos = evo::SmallVector<Diagnostic::Info>();
					if(target_type.qualifiers().back().isOptional){
						infos.emplace_back("NOTE: cannot be optional");
					}

					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Destination type of `@atomicStore` must be a mut pointer",
						std::move(infos)
					);
					return Result::ERROR;
				}

				if(target_type.copyWithPoppedQualifier() != value_type){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@atomicStore` must be the pointee type of the target type"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isTriviallyCopyable(value_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@atomicStore` must be trivially copyable"
					);
					return Result::ERROR;
				}

				if(value_type_id == TypeManager::getTypeF80()){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@atomicStore` cannot be F80"
					);
					return Result::ERROR;
				}


				const uint32_t atomic_ordering_number = static_cast<uint32_t>(
					template_args[2].as<core::GenericValue>().getInt(32)
				);

				const TemplateIntrinsicFunc::AtomicOrdering atomic_ordering =
					static_cast<TemplateIntrinsicFunc::AtomicOrdering>(atomic_ordering_number);


				switch(atomic_ordering){
					case TemplateIntrinsicFunc::AtomicOrdering::MONOTONIC: break;
					case TemplateIntrinsicFunc::AtomicOrdering::RELEASE:   break;
					case TemplateIntrinsicFunc::AtomicOrdering::SEQ_CST:   break;

					case TemplateIntrinsicFunc::AtomicOrdering::ACQUIRE:
					case TemplateIntrinsicFunc::AtomicOrdering::ACQ_REL: {
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
							this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[2],
							"Invalid atomic order for `@atomicStore`"
						);
						return Result::ERROR;
					} break;

					default: {
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
							this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[2],
							"Unknown atomic order"
						);
						return Result::ERROR;
					} break;
				}
			} break;

			case TemplateIntrinsicFunc::Kind::GET_TYPE_ID:
			case TemplateIntrinsicFunc::Kind::ARRAY_ELEMENT_TYPE_ID:
			case TemplateIntrinsicFunc::Kind::ARRAY_REF_ELEMENT_TYPE_ID:
			case TemplateIntrinsicFunc::Kind::NUM_BYTES:
			case TemplateIntrinsicFunc::Kind::NUM_BITS:
			case TemplateIntrinsicFunc::Kind::IS_DEFAULT_INITIALIZABLE:
			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_DEFAULT_INITIALIZABLE:
			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_DEFAULT_INITIALIZABLE:
			case TemplateIntrinsicFunc::Kind::IS_NO_ERROR_DEFAULT_INITIALIZABLE:
			case TemplateIntrinsicFunc::Kind::IS_SAFE_DEFAULT_INITIALIZABLE:
			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_DELETABLE:
			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_DELETABLE:
			case TemplateIntrinsicFunc::Kind::IS_COPYABLE:
			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_COPYABLE:
			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_COPYABLE:
			case TemplateIntrinsicFunc::Kind::IS_NO_ERROR_COPYABLE:
			case TemplateIntrinsicFunc::Kind::IS_SAFE_COPYABLE:
			case TemplateIntrinsicFunc::Kind::IS_MOVABLE:
			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_MOVABLE:
			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_MOVABLE:
			case TemplateIntrinsicFunc::Kind::IS_NO_ERROR_MOVABLE:
			case TemplateIntrinsicFunc::Kind::IS_SAFE_MOVABLE:
			case TemplateIntrinsicFunc::Kind::IS_COMPARABLE:
			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_COMPARABLE:
			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_COMPARABLE:
			case TemplateIntrinsicFunc::Kind::IS_NO_ERROR_COMPARABLE:
			case TemplateIntrinsicFunc::Kind::IS_SAFE_COMPARABLE:
			case TemplateIntrinsicFunc::Kind::BIT_CAST:
			case TemplateIntrinsicFunc::Kind::TRUNC:
			case TemplateIntrinsicFunc::Kind::FTRUNC:
			case TemplateIntrinsicFunc::Kind::SEXT:
			case TemplateIntrinsicFunc::Kind::ZEXT:
			case TemplateIntrinsicFunc::Kind::FEXT:
			case TemplateIntrinsicFunc::Kind::I_TO_F:
			case TemplateIntrinsicFunc::Kind::F_TO_I:
			case TemplateIntrinsicFunc::Kind::ADD:
			case TemplateIntrinsicFunc::Kind::ADD_WRAP:
			case TemplateIntrinsicFunc::Kind::ADD_SAT:
			case TemplateIntrinsicFunc::Kind::FADD:
			case TemplateIntrinsicFunc::Kind::SUB:
			case TemplateIntrinsicFunc::Kind::SUB_WRAP:
			case TemplateIntrinsicFunc::Kind::SUB_SAT:
			case TemplateIntrinsicFunc::Kind::FSUB:
			case TemplateIntrinsicFunc::Kind::MUL:
			case TemplateIntrinsicFunc::Kind::MUL_WRAP:
			case TemplateIntrinsicFunc::Kind::MUL_SAT:
			case TemplateIntrinsicFunc::Kind::FMUL:
			case TemplateIntrinsicFunc::Kind::DIV:
			case TemplateIntrinsicFunc::Kind::FDIV:
			case TemplateIntrinsicFunc::Kind::REM:
			case TemplateIntrinsicFunc::Kind::FNEG:
			case TemplateIntrinsicFunc::Kind::EQ:
			case TemplateIntrinsicFunc::Kind::NEQ:
			case TemplateIntrinsicFunc::Kind::LT:
			case TemplateIntrinsicFunc::Kind::LTE:
			case TemplateIntrinsicFunc::Kind::GT:
			case TemplateIntrinsicFunc::Kind::GTE:
			case TemplateIntrinsicFunc::Kind::AND:
			case TemplateIntrinsicFunc::Kind::OR:
			case TemplateIntrinsicFunc::Kind::XOR:
			case TemplateIntrinsicFunc::Kind::SHL:
			case TemplateIntrinsicFunc::Kind::SHL_SAT:
			case TemplateIntrinsicFunc::Kind::SHR:
			case TemplateIntrinsicFunc::Kind::BIT_REVERSE:
			case TemplateIntrinsicFunc::Kind::BYTE_SWAP:
			case TemplateIntrinsicFunc::Kind::CTPOP:
			case TemplateIntrinsicFunc::Kind::CTLZ:
			case TemplateIntrinsicFunc::Kind::CTTZ:
			case TemplateIntrinsicFunc::Kind::ATOMIC_LOAD: {
				this->emit_error(
					Diagnostic::Code::SEMA_DISCARDING_RETURNS,
					instr.func_call.target,
					"Discarding return value of function call"
				);
				return Result::ERROR;
			} break;

			default: {
				evo::debugFatalBreak("Unknown template intrinsic func");
			} break;
		}


		const evo::Expected<FuncCallImplData, bool> selected_func = this->func_call_impl<false, false>(
			instr.func_call, target_term_info, instr.args, instr.template_args
		);
		if(selected_func.has_value() == false){
			if(selected_func.error()){
				return Result::ERROR;
			}else{
				evo::debugFatalBreak("Should never have to wait");
			}
		}


		const sema::TemplateIntrinsicFuncInstantiation::ID intrinsic_target = 
			this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
				target_term_info.type_id.as<TemplateIntrinsicFunc::Kind>(), std::move(template_args)
			);

		this->get_current_scope_level().stmtBlock().emplace_back(
			this->context.sema_buffer.createFuncCall(intrinsic_target, std::move(args))
		);

		return Result::SUCCESS;
	}


	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::instr_template_intrinsic_func_call_expr(
		const Instruction::TemplateIntrinsicFuncCallExpr<IS_COMPTIME>& instr
	) -> Result {
		const TermInfo& target_term_info = this->get_term_info(instr.target);


		const Context::TemplateIntrinsicFuncInfo& template_intrinsic_func_info = 
			this->context.getTemplateIntrinsicFuncInfo(target_term_info.type_id.as<TemplateIntrinsicFunc::Kind>());

		if constexpr(IS_COMPTIME){
			if(template_intrinsic_func_info.allowedInComptime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
					instr.func_call.target,
					"Cannot call a non-comptime function as a comptime value"
				);
				return Result::ERROR;
			}

		}else{
			if(this->get_current_func().attributes.isComptime){
				if(template_intrinsic_func_info.allowedInInterptime == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_INTERPTIME,
						instr.func_call.target,
						"Cannot call a non-interptime intrinsic function within a comptime function"
					);
					return Result::ERROR;
				}

			}else{
				if(template_intrinsic_func_info.allowedInRuntime == false){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_ISNT_RUNTIME,
						instr.func_call.target,
						"Cannot call a non-runtime function within a runtime function"
					);
					return Result::ERROR;
				}
			}
		}


		switch(this->context.getConfig().mode){
			case Context::Config::Mode::COMPILE: {
				if(template_intrinsic_func_info.allowedInCompile == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
						instr.func_call.target,
						"Calling this intrinsic is not allowed in compile mode"
					);
					return Result::ERROR;
				}
			} break;

			case Context::Config::Mode::SCRIPTING: {
				if(template_intrinsic_func_info.allowedInScript == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
						instr.func_call.target,
						"Calling this intrinsic is not allowed in scripting mode"
					);
					return Result::ERROR;
				}
			} break;

			case Context::Config::Mode::BUILD_SYSTEM: {
				if(template_intrinsic_func_info.allowedInBuild == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_MODE_FOR_INTRINSIC,
						instr.func_call.target,
						"Calling this intrinsic is not allowed in build mode"
					);
					return Result::ERROR;
				}
			} break;
		}



		auto template_args = evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>();
		for(const SymbolProcTermInfoID& template_arg_id : instr.template_args){
			const TermInfo& template_arg = this->get_term_info(template_arg_id);

			if(template_arg.value_category == TermInfo::ValueCategory::TYPE){
				template_args.emplace_back(template_arg.type_id.as<TypeInfo::VoidableID>());
			}else{
				template_args.emplace_back(this->sema_expr_to_generic_value(template_arg.getExpr()));
			}
		}

		auto args = evo::SmallVector<sema::Expr>();
		for(const SymbolProc::TermInfoID& arg_term_info_id : instr.args){
			args.emplace_back(this->get_term_info(arg_term_info_id).getExpr());
		}


		///////////////////////////////////
		// helper funcs

		const auto create_runtime_call = [&]() -> evo::Result<> {
			const evo::Expected<FuncCallImplData, bool> selected_func = this->func_call_impl<IS_COMPTIME, false>(
				instr.func_call, target_term_info, instr.args, instr.template_args
			);
			if(selected_func.has_value() == false){
				if(selected_func.error()){
					return evo::resultError;
				}else{
					evo::debugFatalBreak("Should never have to wait");
				}
			}

			auto return_types = evo::SmallVector<TypeInfo::ID>();
			for(TypeInfo::VoidableID return_voidable_type : selected_func.value().selected_func_type.returnTypes){
				return_types.emplace_back(return_voidable_type.asTypeID());
			}

			const sema::TemplateIntrinsicFuncInstantiation::ID intrinsic_target = 
				this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
					target_term_info.type_id.as<TemplateIntrinsicFunc::Kind>(), std::move(template_args)
				);

			if(return_types.size() == 1){
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					return_types[0],
					sema::Expr(this->context.sema_buffer.createFuncCall(intrinsic_target, std::move(args)))
				);

			}else{
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					std::move(return_types),
					sema::Expr(this->context.sema_buffer.createFuncCall(intrinsic_target, std::move(args)))
				);
			}

			return evo::Result<>();
		};

		const auto check_correct_num_template_args = [&](size_t correct_num) -> evo::Result<> {
			if(template_args.size() != correct_num){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_WRONG_NUM_TEMPLATE_ARGS,
					instr.func_call.target,
					"Incorrect number of template arguments",
					Diagnostic::Info(std::format("Expected {}, got {}", correct_num, template_args.size()))
				);
				return evo::resultError;
			}

			return evo::Result<>();
		};

		const auto check_template_arg_is_type = [&](size_t arg_index) -> evo::Result<> {
			if(template_args[arg_index].is<TypeInfo::VoidableID>() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					"This template argument must be a type"
				);
				return evo::resultError;
			}

			return evo::Result<>();
		};

		const auto check_template_arg_type_not_void = [&](size_t arg_index) -> evo::Result<> {
			if(template_args[arg_index].is<TypeInfo::VoidableID>() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					"This template argument must be a type"
				);
				return evo::resultError;
			}
			
			if(template_args[arg_index].as<TypeInfo::VoidableID>().isVoid()){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					"This template argument cannot be type `Void`"
				);
				return evo::resultError;
			}

			return evo::Result<>();
		};


		const auto check_template_arg_is_expr = [&](size_t arg_index, TypeInfo::ID type_id) -> evo::Result<> {
			if(template_args[arg_index].is<core::GenericValue>() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					"This template argument must be an expression"
				);
				return evo::resultError;
			}

			const TermInfo& arg_term_info = this->get_term_info(instr.template_args[arg_index]);
			if(this->context.type_manager.decayType<false, false>(arg_term_info.type_id.as<TypeInfo::ID>()) != type_id){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
					this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[arg_index],
					std::format(
						"This template argument must be type `{}`",
						this->context.getTypeManager().printType(type_id, this->context)
					)
				);
				return evo::resultError;
			}

			return evo::Result<>();
		};



		///////////////////////////////////
		// select intrinsic

		auto comptime_intrinsic_evaluator = ComptimeIntrinsicEvaluator(
			this->context.type_manager, this->context.sema_buffer
		);

		switch(target_term_info.type_id.as<TemplateIntrinsicFunc::Kind>()){
			case TemplateIntrinsicFunc::Kind::GET_TYPE_ID: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.getTypeID(template_args[0].as<TypeInfo::VoidableID>().asTypeID())
				);
			} break;

			case TemplateIntrinsicFunc::Kind::ARRAY_ELEMENT_TYPE_ID: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID arg_t_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& arg_t_type = this->context.getTypeManager().getTypeInfo(arg_t_type_id);

				if(arg_t_type.baseTypeID().kind() != BaseType::Kind::ARRAY){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"This template argument must be an array type"
					);
					return Result::ERROR;
				}

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.arrayElementTypeID(
						this->context.type_manager.decayType<true, true>(arg_t_type_id)
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::ARRAY_REF_ELEMENT_TYPE_ID: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID arg_t_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& arg_t_type = this->context.getTypeManager().getTypeInfo(arg_t_type_id);

				if(arg_t_type.baseTypeID().kind() != BaseType::Kind::ARRAY_REF){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"This template argument must be an array reference type"
					);
					return Result::ERROR;
				}

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.arrayRefElementTypeID(
						this->context.type_manager.decayType<true, true>(arg_t_type_id)
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::NUM_BYTES: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(1, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.numBytes(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						template_args[1].as<core::GenericValue>().getBool()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::NUM_BITS: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(1, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.numBits(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						template_args[1].as<core::GenericValue>().getBool()
					)
				);
			} break;


			case TemplateIntrinsicFunc::Kind::IS_DEFAULT_INITIALIZABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isDefaultInitializable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_DEFAULT_INITIALIZABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isTriviallyDefaultInitializable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_DEFAULT_INITIALIZABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isComptimeDefaultInitializable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_NO_ERROR_DEFAULT_INITIALIZABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isNoErrorDefaultInitializable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_SAFE_DEFAULT_INITIALIZABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isSafeDefaultInitializable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_DELETABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isTriviallyDeletable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_DELETABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isComptimeDeletable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_COPYABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isCopyable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_COPYABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isTriviallyCopyable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_COPYABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isComptimeCopyable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_NO_ERROR_COPYABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isNoErrorCopyable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_SAFE_COPYABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isSafeCopyable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_MOVABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isMovable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_MOVABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isTriviallyMovable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_MOVABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isComptimeMovable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_NO_ERROR_MOVABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isNoErrorMovable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_SAFE_MOVABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isSafeMovable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_COMPARABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isComparable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_TRIVIALLY_COMPARABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isTriviallyComparable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_COMPTIME_COMPARABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isComptimeComparable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_NO_ERROR_COMPARABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isNoErrorComparable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;

			case TemplateIntrinsicFunc::Kind::IS_SAFE_COMPARABLE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				this->return_term_info(
					instr.output,
					comptime_intrinsic_evaluator.isSafeComparable(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID()
					)
				);
			} break;



			case TemplateIntrinsicFunc::Kind::BIT_CAST: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID from_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID to_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();
				
				if(
					this->context.getTypeManager().numBytes(from_type_id)
						!= this->context.getTypeManager().numBytes(to_type_id)
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						instr.func_call.target,
						"Template arguments of `@bitCast` must be the same size",
						Diagnostic::Info("NOTE: requires `@numBytes<{FROM, true}>() == @numBytes<{TO, true}>()`")
					);
					return Result::ERROR;
				}

				if(this->currently_in_unsafe() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
						instr.func_call.target,
						"Call to `@bitCast` while not in an unsafe scope"
					);
					return Result::ERROR;
				}

				if(create_runtime_call().isError()){ return Result::ERROR; }
			} break;

			case TemplateIntrinsicFunc::Kind::TRUNC: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID from_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID to_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(from_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Template arguments of `@trunc` must be integral"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isIntegral(to_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Template arguments of `@trunc` must be integral"
					);
					return Result::ERROR;
				}

				if(
					this->context.getTypeManager().numBits(from_type_id, false)
						<= this->context.getTypeManager().numBits(to_type_id, false)
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						instr.func_call.target,
						"Template arguments of `@trunc` must target a smaller size",
						Diagnostic::Info("NOTE: requires `@numBits<{FROM, false}>() > @numBits<{TO, false}>()`")
					);
					return Result::ERROR;
				}

				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.trunc(
						template_args[1].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::FTRUNC: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID from_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID to_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isFloatingPoint(from_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Template arguments of `@ftrunc` must be floating-point"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isFloatingPoint(to_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Template arguments of `@ftrunc` must be floating-point"
					);
					return Result::ERROR;
				}

				if(
					this->context.getTypeManager().numBits(from_type_id, false)
						<= this->context.getTypeManager().numBits(to_type_id, false)
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						instr.func_call.target,
						"Template arguments of `@ftrunc` must target a smaller size",
						Diagnostic::Info("NOTE: requires `@numBits<{FROM, false}>() > @numBits<{TO, false}>()`")
					);
					return Result::ERROR;
				}

				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.ftrunc(
						template_args[1].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::SEXT: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID from_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID to_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(from_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Template arguments of `@sext` must be integral"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isIntegral(to_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Template arguments of `@sext` must be integral"
					);
					return Result::ERROR;
				}

				if(
					this->context.getTypeManager().numBits(from_type_id, false)
						<= this->context.getTypeManager().numBits(to_type_id, false)
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						instr.func_call.target,
						"Template arguments of `@sext` must target a larger size",
						Diagnostic::Info("NOTE: requires `@numBits<{FROM, false}>() < @numBits<{TO, false}>()`")
					);
					return Result::ERROR;
				}

				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.sext(
						template_args[1].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::ZEXT: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID from_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID to_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(from_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Template arguments of `@zext` must be integral"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isIntegral(to_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Template arguments of `@zext` must be integral"
					);
					return Result::ERROR;
				}

				if(
					this->context.getTypeManager().numBits(from_type_id, false)
						<= this->context.getTypeManager().numBits(to_type_id, false)
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						instr.func_call.target,
						"Template arguments of `@zext` must target a larger size",
						Diagnostic::Info("NOTE: requires `@numBits<{FROM, false}>() < @numBits<{TO, false}>()`")
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.zext(
						template_args[1].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::FEXT: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID from_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID to_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isFloatingPoint(from_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Template arguments of `@fext` must be floating-point"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isFloatingPoint(to_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Template arguments of `@fext` must be floating-point"
					);
					return Result::ERROR;
				}

				if(
					this->context.getTypeManager().numBits(from_type_id, false)
						<= this->context.getTypeManager().numBits(to_type_id, false)
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						instr.func_call.target,
						"Template arguments of `@fext` must target a larger size",
						Diagnostic::Info("NOTE: requires `@numBits<{FROM, false}>() < @numBits<{TO, false}>()`")
					);
					return Result::ERROR;
				}

				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.fext(
						template_args[1].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::I_TO_F: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID from_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID to_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(from_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Template arguments `FROM` of `@iToF` must be integral"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isFloatingPoint(to_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Template arguments `TO` of `@iToF` must be floating-point"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.iToF(
						template_args[1].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::F_TO_I: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID from_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID to_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isFloatingPoint(from_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Template arguments `FROM` of `@fToI` must be floating-point"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isIntegral(to_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Template arguments `TO` of `@fToI` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.fToI(
						template_args[1].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::ADD: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(1, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@add` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					evo::Result<TermInfo> result = comptime_intrinsic_evaluator.add(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						template_args[1].as<core::GenericValue>().getBool(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					);

					if(result.isError()){
						// TODO(FUTURE): better messaging
						this->emit_error(
							Diagnostic::Code::SEMA_COMPTIME_INTRIN_MATH_ERROR,
							instr.func_call,
							"Comptime intrinsic @add wrapped"
						);
						return Result::ERROR;
					}

					this->return_term_info(instr.output, std::move(result.value()));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::ADD_WRAP: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@addWrap` must be integral"
					);
					return Result::ERROR;
				}


				if(create_runtime_call().isError()){ return Result::ERROR; }
			} break;

			case TemplateIntrinsicFunc::Kind::ADD_SAT: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@addSat` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.addSat(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::FADD: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isFloatingPoint(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@fadd` must be floating-point"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.fadd(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
						this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::SUB: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(1, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@sub` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					evo::Result<TermInfo> result = comptime_intrinsic_evaluator.sub(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						template_args[1].as<core::GenericValue>().getBool(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					);

					if(result.isError()){
						// TODO(FUTURE): better messaging
						this->emit_error(
							Diagnostic::Code::SEMA_COMPTIME_INTRIN_MATH_ERROR,
							instr.func_call,
							"Comptime intrinsic @sub wrapped"
						);
						return Result::ERROR;
					}

					this->return_term_info(instr.output, std::move(result.value()));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::SUB_WRAP: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@subWrap` must be integral"
					);
					return Result::ERROR;
				}

				if(create_runtime_call().isError()){ return Result::ERROR; }
			} break;

			case TemplateIntrinsicFunc::Kind::SUB_SAT: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@subSat` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.subSat(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::FSUB: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isFloatingPoint(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@fsub` must be floating-point"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.fsub(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
						this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::MUL: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(1, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@mul` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					evo::Result<TermInfo> result = comptime_intrinsic_evaluator.mul(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						template_args[1].as<core::GenericValue>().getBool(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					);

					if(result.isError()){
						// TODO(FUTURE): better messaging
						this->emit_error(
							Diagnostic::Code::SEMA_COMPTIME_INTRIN_MATH_ERROR,
							instr.func_call,
							"Comptime intrinsic @mul wrapped"
						);
						return Result::ERROR;
					}

					this->return_term_info(instr.output, std::move(result.value()));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::MUL_WRAP: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@mulWrap` must be integral"
					);
					return Result::ERROR;
				}


				if(create_runtime_call().isError()){ return Result::ERROR; }
			} break;

			case TemplateIntrinsicFunc::Kind::MUL_SAT: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@mulSat` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.mulSat(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::FMUL: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isFloatingPoint(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@fmul` must be floating-point"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.fmul(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
						this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::DIV: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(1, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@div` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					evo::Result<TermInfo> result = comptime_intrinsic_evaluator.div(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						template_args[1].as<core::GenericValue>().getBool(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					);

					if(result.isError()){
						// TODO(FUTURE): better messaging
						this->emit_error(
							Diagnostic::Code::SEMA_COMPTIME_INTRIN_MATH_ERROR,
							instr.func_call,
							"Comptime intrinsic @div was not exact"
						);
						return Result::ERROR;
					}

					this->return_term_info(instr.output, std::move(result.value()));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::FDIV: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isFloatingPoint(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@fdiv` must be floating-point"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.fdiv(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
						this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::REM: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(
					this->context.getTypeManager().isIntegral(target_type_id) == false
					&& this->context.getTypeManager().isFloatingPoint(target_type_id) == false
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@rem` must be integral or floating-point"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					const TypeInfo::ID arg_type = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

					if(this->context.getTypeManager().isFloatingPoint(arg_type)){
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.rem(
							arg_type,
							this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
							this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
						));
					}else{
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.rem(
							arg_type,
							this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
							this->context.sema_buffer.getIntValue(args[1].intValueID()).value
						));
					}

				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::FNEG: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isFloatingPoint(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@fneg` must be floating-point"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.fneg(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::EQ: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isPrimitive(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@eq` must be primitive (excluding `Void`)"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					const TypeInfo::ID arg_type = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

					if(this->context.getTypeManager().isFloatingPoint(arg_type)){
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.eq(
							arg_type,
							this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
							this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
						));
					}else{
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.eq(
							arg_type,
							this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
							this->context.sema_buffer.getIntValue(args[1].intValueID()).value
						));
					}
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::NEQ: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isPrimitive(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@neq` must be primitive (excluding `Void`)"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					const TypeInfo::ID arg_type = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

					if(this->context.getTypeManager().isFloatingPoint(arg_type)){
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.neq(
							arg_type,
							this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
							this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
						));
					}else{
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.neq(
							arg_type,
							this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
							this->context.sema_buffer.getIntValue(args[1].intValueID()).value
						));
					}

				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::LT: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isPrimitive(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@lt` must be primitive (excluding `Void`, `RawPtr`, and `TypeID`)"
					);
					return Result::ERROR;
				}

				const BaseType::Primitive& target_primitive = this->context.getTypeManager().getPrimitive(
					this->context.getTypeManager().getTypeInfo(target_type_id).baseTypeID().primitiveID()
				);

				if(
					target_primitive.kind() == Token::Kind::TYPE_RAWPTR
					|| target_primitive.kind() == Token::Kind::TYPE_TYPEID
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@lt` must be primitive (excluding `Void`, `RawPtr`, and `TypeID`)"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					const TypeInfo::ID arg_type = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

					if(this->context.getTypeManager().isFloatingPoint(arg_type)){
						this->return_term_info(instr.output,  comptime_intrinsic_evaluator.lt(
							arg_type,
							this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
							this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
						));
					}else{
						this->return_term_info(instr.output,  comptime_intrinsic_evaluator.lt(
							arg_type,
							this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
							this->context.sema_buffer.getIntValue(args[1].intValueID()).value
						));
					}
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::LTE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isPrimitive(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@lte` must be primitive (excluding `Void`, `RawPtr`, and `TypeID`)"
					);
					return Result::ERROR;
				}

				const BaseType::Primitive& target_primitive = this->context.getTypeManager().getPrimitive(
					this->context.getTypeManager().getTypeInfo(target_type_id).baseTypeID().primitiveID()
				);

				if(
					target_primitive.kind() == Token::Kind::TYPE_RAWPTR
					|| target_primitive.kind() == Token::Kind::TYPE_TYPEID
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@lte` must be primitive (excluding `Void`, `RawPtr`, and `TypeID`)"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					const TypeInfo::ID arg_type = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

					if(this->context.getTypeManager().isFloatingPoint(arg_type)){
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.lte(
							arg_type,
							this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
							this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
						));
					}else{
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.lte(
							arg_type,
							this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
							this->context.sema_buffer.getIntValue(args[1].intValueID()).value
						));
					}
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::GT: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isPrimitive(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@gt` must be primitive (excluding `Void`, `RawPtr`, and `TypeID`)"
					);
					return Result::ERROR;
				}

				const BaseType::Primitive& target_primitive = this->context.getTypeManager().getPrimitive(
					this->context.getTypeManager().getTypeInfo(target_type_id).baseTypeID().primitiveID()
				);

				if(
					target_primitive.kind() == Token::Kind::TYPE_RAWPTR
					|| target_primitive.kind() == Token::Kind::TYPE_TYPEID
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@gt` must be primitive (excluding `Void`, `RawPtr`, and `TypeID`)"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					const TypeInfo::ID arg_type = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

					if(this->context.getTypeManager().isFloatingPoint(arg_type)){
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.gt(
							arg_type,
							this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
							this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
						));
					}else{
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.gt(
							arg_type,
							this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
							this->context.sema_buffer.getIntValue(args[1].intValueID()).value
						));
					}
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::GTE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isPrimitive(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@gte` must be primitive (excluding `Void`, `RawPtr`, and `TypeID`)"
					);
					return Result::ERROR;
				}

				const BaseType::Primitive& target_primitive = this->context.getTypeManager().getPrimitive(
					this->context.getTypeManager().getTypeInfo(target_type_id).baseTypeID().primitiveID()
				);

				if(
					target_primitive.kind() == Token::Kind::TYPE_RAWPTR
					|| target_primitive.kind() == Token::Kind::TYPE_TYPEID
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@gte` must be primitive (excluding `Void`, `RawPtr`, and `TypeID`)"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					const TypeInfo::ID arg_type = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

					if(this->context.getTypeManager().isFloatingPoint(arg_type)){
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.gte(
							arg_type,
							this->context.sema_buffer.getFloatValue(args[0].floatValueID()).value,
							this->context.sema_buffer.getFloatValue(args[1].floatValueID()).value
						));
					}else{
						this->return_term_info(instr.output, comptime_intrinsic_evaluator.gte(
							arg_type,
							this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
							this->context.sema_buffer.getIntValue(args[1].intValueID()).value
						));
					}
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::AND: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@and` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.bitwiseAnd(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::OR: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@or` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.bitwiseOr(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::XOR: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@xor` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.bitwiseXor(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::SHL: {
				if(check_correct_num_template_args(3).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(2, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID shift_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@shl` must be integral"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isUnsignedIntegral(shift_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Shift type of `@shl` must be unsigned integral"
					);
					return Result::ERROR;
				}


				const size_t expected_shift_width = 
					size_t(std::ceil(std::log2(float(this->context.getTypeManager().numBits(target_type_id, false)))));

				if(this->context.getTypeManager().numBits(shift_type_id, false) != expected_shift_width){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Shift type of `@shl` must have a width of ceil(log2(@numBits<{T, false}>()))",
						Diagnostic::Info(
							std::format("Shift type for this target type should be: UI{}", expected_shift_width)
						)
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					evo::Result<TermInfo> result = comptime_intrinsic_evaluator.shl(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						template_args[2].as<core::GenericValue>().getBool(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					);

					if(result.isError()){
						// TODO(FUTURE): better messaging
						this->emit_error(
							Diagnostic::Code::SEMA_COMPTIME_INTRIN_MATH_ERROR,
							instr.func_call,
							"Comptime intrinsic @shl wrapped"
						);
						return Result::ERROR;
					}

					this->return_term_info(instr.output, std::move(result.value()));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::SHL_SAT: {
				if(check_correct_num_template_args(2).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID shift_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@shlSat` must be integral"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isUnsignedIntegral(shift_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Shift type of `@shlSat` must be unsigned integral"
					);
					return Result::ERROR;
				}


				const size_t expected_shift_width = 
					size_t(std::ceil(std::log2(float(this->context.getTypeManager().numBits(target_type_id, false)))));

				if(this->context.getTypeManager().numBits(shift_type_id, false) != expected_shift_width){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Shift type of `@shlSat` must have a width of ceil(log2(@numBits<{T, false}>()))",
						Diagnostic::Info(
							std::format("Shift type for this target type should be: UI{}", expected_shift_width)
						)
					);
					return Result::ERROR;
				}

				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.shlSat(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::SHR: {
				if(check_correct_num_template_args(3).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(2, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo::ID shift_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@shl` must be integral"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isUnsignedIntegral(shift_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Shift type of `@shl` must be unsigned integral"
					);
					return Result::ERROR;
				}


				const size_t expected_shift_width = 
					size_t(std::ceil(std::log2(float(this->context.getTypeManager().numBits(target_type_id, false)))));

				if(this->context.getTypeManager().numBits(shift_type_id, false) != expected_shift_width){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Shift type of `@shr` must have a width of ceil(log2(@numBits<{T, false}>()))",
						Diagnostic::Info(
							std::format("Shift type for this target type should be: UI{}", expected_shift_width)
						)
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					evo::Result<TermInfo> result = comptime_intrinsic_evaluator.shr(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						template_args[2].as<core::GenericValue>().getBool(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value,
						this->context.sema_buffer.getIntValue(args[1].intValueID()).value
					);

					if(result.isError()){
						// TODO(FUTURE): better messaging
						this->emit_error(
							Diagnostic::Code::SEMA_COMPTIME_INTRIN_MATH_ERROR,
							instr.func_call,
							"Comptime intrinsic @shr wrapped"
						);
						return Result::ERROR;
					}

					this->return_term_info(instr.output, std::move(result.value()));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::BIT_REVERSE: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@bitReverse` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.bitReverse(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::BYTE_SWAP: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@byteSwap` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.byteSwap(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::CTPOP: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@ctPop` must be integral"
					);
					return Result::ERROR;
				}

				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.ctPop(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::CTLZ: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@ctlz` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.ctlz(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::CTTZ: {
				if(check_correct_num_template_args(1).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();

				if(this->context.getTypeManager().isIntegral(target_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@cttz` must be integral"
					);
					return Result::ERROR;
				}


				if constexpr(IS_COMPTIME){
					this->return_term_info(instr.output, comptime_intrinsic_evaluator.cttz(
						template_args[0].as<TypeInfo::VoidableID>().asTypeID(),
						this->context.sema_buffer.getIntValue(args[0].intValueID()).value
					));
				}else{
					if(create_runtime_call().isError()){ return Result::ERROR; }
				}
			} break;

			case TemplateIntrinsicFunc::Kind::ATOMIC_LOAD: {
				const BuiltinModule& builtin_module_pthr = this->context.getSourceManager()[BuiltinModule::ID::PTHR];
				const TypeInfo::ID atomic_ordering_type_id = this->context.type_manager.getOrCreateTypeInfo(
					TypeInfo(builtin_module_pthr.getSymbol("AtomicOrdering")->as<BaseType::ID>())
				);

				if(check_correct_num_template_args(3).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(2, atomic_ordering_type_id).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& target_type = this->context.getTypeManager().getTypeInfo(target_type_id);

				const TypeInfo::ID value_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& value_type = this->context.getTypeManager().getTypeInfo(value_type_id);

				if(target_type.isPointerNotOptional() == false){
					auto infos = evo::SmallVector<Diagnostic::Info>();
					if(target_type.qualifiers().back().isOptional){
						infos.emplace_back("NOTE: cannot be optional");
					}

					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@atomicLoad` must be a pointer",
						std::move(infos)
					);
					return Result::ERROR;
				}

				if(target_type.copyWithPoppedQualifier() != value_type){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@atomicLoad` must be the pointee type of the target type"
					);
					return Result::ERROR;
				}

				if(this->context.getTypeManager().isTriviallyCopyable(value_type_id) == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@atomicLoad` must be trivially copyable"
					);
					return Result::ERROR;
				}

				if(value_type_id == TypeManager::getTypeF80()){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@atomicLoad` cannot be F80"
					);
					return Result::ERROR;
				}


				const uint32_t atomic_ordering_number = static_cast<uint32_t>(
					template_args[2].as<core::GenericValue>().getInt(32)
				);

				const TemplateIntrinsicFunc::AtomicOrdering atomic_ordering =
					static_cast<TemplateIntrinsicFunc::AtomicOrdering>(atomic_ordering_number);

				switch(atomic_ordering){
					case TemplateIntrinsicFunc::AtomicOrdering::MONOTONIC: break;
					case TemplateIntrinsicFunc::AtomicOrdering::ACQUIRE:   break;
					case TemplateIntrinsicFunc::AtomicOrdering::SEQ_CST:   break;

					case TemplateIntrinsicFunc::AtomicOrdering::RELEASE:
					case TemplateIntrinsicFunc::AtomicOrdering::ACQ_REL: {
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
							this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[2],
							"Invalid atomic order for `@atomicLoad`"
						);
						return Result::ERROR;
					} break;

					default: {
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
							this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[2],
							"Unknown atomic order"
						);
						return Result::ERROR;
					} break;
				}

				if(create_runtime_call().isError()){ return Result::ERROR; }
			} break;

			case TemplateIntrinsicFunc::Kind::CMPXCHG: {
				const BuiltinModule& builtin_module_pthr = this->context.getSourceManager()[BuiltinModule::ID::PTHR];
				const TypeInfo::ID atomic_ordering_type_id = this->context.type_manager.getOrCreateTypeInfo(
					TypeInfo(builtin_module_pthr.getSymbol("AtomicOrdering")->as<BaseType::ID>())
				);

				if(check_correct_num_template_args(5).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(2, TypeManager::getTypeBool()).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(3, atomic_ordering_type_id).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(4, atomic_ordering_type_id).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& target_type = this->context.getTypeManager().getTypeInfo(target_type_id);

				const TypeInfo::ID value_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& value_type = this->context.getTypeManager().getTypeInfo(value_type_id);

				if(target_type.isPointerNotOptional() == false){
					auto infos = evo::SmallVector<Diagnostic::Info>();
					if(target_type.qualifiers().back().isOptional){
						infos.emplace_back("NOTE: cannot be optional");
					}

					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@cmpxchg` must be a typed pointer",
						std::move(infos)
					);
					return Result::ERROR;
				}

				if(target_type.copyWithPoppedQualifier() != value_type){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@cmpxchg` must be the pointee type of the target type"
					);
					return Result::ERROR;
				}

				if(
					this->context.getTypeManager().isIntegral(value_type_id) == false
					&& this->context.getTypeManager().isPointer(value_type_id) == false
					&& value_type_id != TypeManager::getTypeBool()
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@cmpxchg` must be integral, pointer, or Bool"
					);
					return Result::ERROR;
				}


				const uint32_t success_atomic_ordering_number = static_cast<uint32_t>(
					template_args[3].as<core::GenericValue>().getInt(32)
				);

				const TemplateIntrinsicFunc::AtomicOrdering success_atomic_ordering =
					static_cast<TemplateIntrinsicFunc::AtomicOrdering>(success_atomic_ordering_number);

				switch(success_atomic_ordering){
					case TemplateIntrinsicFunc::AtomicOrdering::MONOTONIC: break;
					case TemplateIntrinsicFunc::AtomicOrdering::ACQUIRE:   break;
					case TemplateIntrinsicFunc::AtomicOrdering::RELEASE:   break;
					case TemplateIntrinsicFunc::AtomicOrdering::ACQ_REL:   break;
					case TemplateIntrinsicFunc::AtomicOrdering::SEQ_CST:   break;

					default: {
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
							this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[3],
							"Unknown atomic order"
						);
						return Result::ERROR;
					} break;
				}




				const uint32_t failure_atomic_ordering_number = static_cast<uint32_t>(
					template_args[4].as<core::GenericValue>().getInt(32)
				);

				const TemplateIntrinsicFunc::AtomicOrdering failure_atomic_ordering =
					static_cast<TemplateIntrinsicFunc::AtomicOrdering>(failure_atomic_ordering_number);

				switch(failure_atomic_ordering){
					case TemplateIntrinsicFunc::AtomicOrdering::MONOTONIC: break;
					case TemplateIntrinsicFunc::AtomicOrdering::ACQUIRE:   break;
					case TemplateIntrinsicFunc::AtomicOrdering::SEQ_CST:   break;

					case TemplateIntrinsicFunc::AtomicOrdering::RELEASE:
					case TemplateIntrinsicFunc::AtomicOrdering::ACQ_REL: {
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
							this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[4],
							"Invalid atomic order for `@cmpxchg`"
						);
						return Result::ERROR;
					} break;

					default: {
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
							this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[4],
							"Unknown atomic order"
						);
						return Result::ERROR;
					} break;
				}

				if(create_runtime_call().isError()){ return Result::ERROR; }
			} break;


			case TemplateIntrinsicFunc::Kind::ATOMIC_STORE: {
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_RETURNS_VOID,
					instr.func_call.target,
					"Function returns `Void` which is not a value"
				);
				return Result::ERROR;
			} break;

			case TemplateIntrinsicFunc::Kind::ATOMIC_RMW: {
				const BuiltinModule& builtin_module_pthr = this->context.getSourceManager()[BuiltinModule::ID::PTHR];

				const TypeInfo::ID atomic_ordering_type_id = this->context.type_manager.getOrCreateTypeInfo(
					TypeInfo(builtin_module_pthr.getSymbol("AtomicOrdering")->as<BaseType::ID>())
				);

				const TypeInfo::ID atomic_rmw_op_type_id = this->context.type_manager.getOrCreateTypeInfo(
					TypeInfo(builtin_module_pthr.getSymbol("AtomicRMWOp")->as<BaseType::ID>())
				);

				if(check_correct_num_template_args(4).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(0).isError()){ return Result::ERROR; }
				if(check_template_arg_type_not_void(1).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(2, atomic_rmw_op_type_id).isError()){ return Result::ERROR; }
				if(check_template_arg_is_expr(3, atomic_ordering_type_id).isError()){ return Result::ERROR; }

				const TypeInfo::ID target_type_id = template_args[0].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& target_type = this->context.getTypeManager().getTypeInfo(target_type_id);

				const TypeInfo::ID value_type_id = template_args[1].as<TypeInfo::VoidableID>().asTypeID();
				const TypeInfo& value_type = this->context.getTypeManager().getTypeInfo(value_type_id);

				if(target_type.isPointerNotOptional() == false){
					auto infos = evo::SmallVector<Diagnostic::Info>();
					if(target_type.qualifiers().back().isOptional){
						infos.emplace_back("NOTE: cannot be optional");
					}

					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[0],
						"Target type of `@atomicRMW` must be a pointer",
						std::move(infos)
					);
					return Result::ERROR;
				}

				if(target_type.copyWithPoppedQualifier() != value_type){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@atomicRMW` must be the pointee type of the target type"
					);
					return Result::ERROR;
				}

				if(
					this->context.getTypeManager().isIntegral(value_type_id) == false
					&& this->context.getTypeManager().isPointer(value_type_id) == false
					&& value_type_id != TypeManager::getTypeBool()
				){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_FUNC_INVALID_TEMPLATE_ARG,
						this->source.getASTBuffer().getTemplatedExpr(instr.func_call.target).args[1],
						"Value type of `@atomicRMW` must be integral, pointer, or Bool"
					);
					return Result::ERROR;
				}

				if(create_runtime_call().isError()){ return Result::ERROR; }
			} break;
		}


		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_copy(const Instruction::Copy& instr) -> Result {
		const TermInfo& target = this->get_term_info(instr.target);

		if(target.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_COPY_ARG_NOT_CONCRETE,
				instr.prefix,
				"Argument of operator [copy] must be concrete"
			);
			return Result::ERROR;
		}

		if(this->context.getTypeManager().isCopyable(target.type_id.as<TypeInfo::ID>()) == false){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_special_member_fail<SpecialMemberFailKind::COPY>(
				target.type_id.as<TypeInfo::ID>(), infos
			);
			this->emit_error(
				Diagnostic::Code::SEMA_COPY_ARG_TYPE_NOT_COPYABLE,
				instr.prefix,
				"Type of argument of operator [copy] is not copyable",
				std::move(infos)
			);
			return Result::ERROR;
		}

		if(
			this->get_current_func().attributes.isComptime
			&& this->context.getTypeManager().isComptimeCopyable(
				target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
			) == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_COMPTIME_COPY_ARG_TYPE_NOT_COMPTIME_COPYABLE,
				instr.prefix,
				"Type of argument of operator [copy] is not comptime copyable"
			);
			return Result::ERROR;
		}

		if(
			this->currently_in_unsafe() == false
			&& this->context.getTypeManager().isSafeCopyable(
				target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
			) == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
				instr.prefix,
				"Unsafe copy while not in an unsafe scope"
			);
			return Result::ERROR;
		}




		if(this->currently_in_func() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_INVALID_OBJECT_SCOPE,
				instr.prefix,
				"Operator [copy] must be in function scope"
			);
			return Result::ERROR;
		}

		if(
			target.value_state != TermInfo::ValueState::INIT
			&& target.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.prefix,
				"Argument of operator [copy] must be initialized"
			);
			return Result::ERROR;
		}


		if(this->get_special_member_call_dependents<SpecialMemberKind::COPY_INIT, true>(
			target,
			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
			instr.prefix
		).isError()){
			return Result::ERROR;
		}

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			target.type_id,
			sema::Expr(this->context.sema_buffer.createCopy(target.getExpr(), target.type_id.as<TypeInfo::ID>(), true))
		);

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_move(const Instruction::Move& instr) -> Result {
		const TermInfo& target = this->get_term_info(instr.target);

		if(target.value_category != TermInfo::ValueCategory::CONCRETE_MUT){
			if(target.value_category == TermInfo::ValueCategory::FORWARDABLE){
				this->emit_error(
					Diagnostic::Code::SEMA_MOVE_ARG_IS_IN_PARAM,
					instr.prefix.rhs,
					"Argument of operator [move] cannot be an in-parameter",
					Diagnostic::Info("Use operator [forward] instead")
				);
			}else if(target.is_concrete() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_MOVE_ARG_NOT_CONCRETE,
					instr.prefix.rhs,
					"Argument of operator [move] must be concrete"
				);
			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_MOVE_ARG_NOT_MUTABLE,
					instr.prefix.rhs,
					"Argument of operator [move] must be mutable"
				);
			}

			return Result::ERROR;
		}


		if(this->context.getTypeManager().isMovable(target.type_id.as<TypeInfo::ID>()) == false){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_special_member_fail<SpecialMemberFailKind::MOVE>(
				target.type_id.as<TypeInfo::ID>(), infos
			);
			this->emit_error(
				Diagnostic::Code::SEMA_MOVE_ARG_TYPE_NOT_MOVABLE,
				instr.prefix.rhs,
				"Type of argument of operator [move] is not movable",
				std::move(infos)
			);
			return Result::ERROR;
		}

		if(
			this->get_current_func().attributes.isComptime
			&& this->context.getTypeManager().isComptimeMovable(
				target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
			) == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_COMPTIME_MOVE_ARG_TYPE_NOT_COMPTIME_MOVABLE,
				instr.prefix,
				"Type of argument of operator [move] is not comptime movable"
			);
			return Result::ERROR;
		}

		if(
			this->currently_in_unsafe() == false
			&& this->context.getTypeManager().isSafeMovable(
				target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
			) == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
				instr.prefix,
				"Unsafe move while not in an unsafe scope"
			);
			return Result::ERROR;
		}


		if(this->currently_in_func() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_INVALID_OBJECT_SCOPE,
				instr.prefix,
				"Operator [move] must be in function scope"
			);
			return Result::ERROR;
		}


		switch(target.value_state){
			case TermInfo::ValueState::NOT_APPLICABLE: case TermInfo::ValueState::INIT: {
				// do nothing...
			} break;

			case TermInfo::ValueState::INITIALIZING: case TermInfo::ValueState::UNINIT: {
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					instr.prefix.rhs,
					"Argument of operator [move] must be initialized"
				);
				return Result::ERROR;
			} break;

			case TermInfo::ValueState::MOVED_FROM: {
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					instr.prefix.rhs,
					"Argument of operator [move] must be initialized",
					Diagnostic::Info("This argument was already moved from")
				);
				return Result::ERROR;
			} break;
		}

		switch(target.getExpr().kind()){
			case sema::Expr::Kind::VAR: {
				// safe, nothing to do...
			} break;

			default: {
				if(this->currently_in_unsafe() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
						instr.prefix,
						"Unsafe move while not in an unsafe scope"
					);
					return Result::ERROR;
				}
			} break;
		}

		if(this->get_special_member_call_dependents<SpecialMemberKind::MOVE_INIT, true>(
			target,
			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
			instr.prefix
		).isError()){
			return Result::ERROR;
		}

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			target.type_id,
			sema::Expr(this->context.sema_buffer.createMove(target.getExpr(), target.type_id.as<TypeInfo::ID>(), true))
		);

		if(target.value_state == TermInfo::ValueState::INIT){
			if(this->set_ident_value_state_if_needed(
				target.getExpr(), sema::ScopeLevel::ValueState::MOVED_FROM, instr.prefix
			).isError()){
				return Result::ERROR;
			}
		}

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_forward(const Instruction::Forward& instr) -> Result {
		const TermInfo& target = this->get_term_info(instr.target);

		if(target.value_category != TermInfo::ValueCategory::FORWARDABLE){
			this->emit_error(
				Diagnostic::Code::SEMA_MOVE_ARG_NOT_MUTABLE,
				instr.prefix,
				"Argument of operator [forward] must be forwardable"
			);

			return Result::ERROR;
		}

		if(this->currently_in_func() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_INVALID_OBJECT_SCOPE,
				instr.prefix,
				"Operator [forward] must be in function scope"
			);
			return Result::ERROR;
		}


		const bool target_is_copyable = this->context.getTypeManager().isCopyable(target.type_id.as<TypeInfo::ID>());
		const bool target_is_movable = this->context.getTypeManager().isMovable(target.type_id.as<TypeInfo::ID>());

		if(this->get_current_func().attributes.isComptime){
			if(target_is_copyable){
				if(this->get_special_member_call_dependents<SpecialMemberKind::COPY_INIT, true>(
					target,
					this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
					instr.prefix
				).isError()){
					return Result::ERROR;
				}
			}

			if(target_is_movable){
				if(this->get_special_member_call_dependents<SpecialMemberKind::MOVE_INIT, true>(
					target,
					this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs,
					instr.prefix
				).isError()){
					return Result::ERROR;
				}
			}
		}


		if(this->currently_in_unsafe() == false){
			if(
				target_is_copyable
				&& this->context.getTypeManager().isSafeCopyable(
						target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
					) == false
			){
				this->emit_error(
					Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
					instr.prefix,
					"Unsafe forward while not in an unsafe scope"
				);
				return Result::ERROR;
			}

			if(
				target_is_movable
				&& this->context.getTypeManager().isSafeMovable(
						target.type_id.as<TypeInfo::ID>(), this->context.getSemaBuffer()
					) == false
			){
				this->emit_error(
					Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
					instr.prefix,
					"Unsafe forward while not in an unsafe scope"
				);
				return Result::ERROR;
			}
		}


		switch(target.value_state){
			case TermInfo::ValueState::NOT_APPLICABLE: case TermInfo::ValueState::INIT: {
				// do nothing...
			} break;

			case TermInfo::ValueState::INITIALIZING: case TermInfo::ValueState::UNINIT: {
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					instr.prefix.rhs,
					"Argument of operator [forward] must be initialized"
				);
				return Result::ERROR;
			} break;

			case TermInfo::ValueState::MOVED_FROM: {
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					instr.prefix.rhs,
					"Argument of operator [forward] must be initialized",
					Diagnostic::Info("This argument was already forwarded")
				);
				return Result::ERROR;
			} break;
		}


		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			target.type_id,
			sema::Expr(
				this->context.sema_buffer.createForward(target.getExpr(), target.type_id.as<TypeInfo::ID>(), true)
			)
		);

		if(target.value_state == TermInfo::ValueState::INIT){
			if(this->set_ident_value_state_if_needed(
				target.getExpr(), sema::ScopeLevel::ValueState::MOVED_FROM, instr.prefix
			).isError()){
				return Result::ERROR;
			}
		}

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_addr_of(const Instruction::AddrOf& instr) -> Result {
		const TermInfo& target = this->get_term_info(instr.target);

		if(target.is_concrete() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_ADDR_OF_ARG_NOT_CONCRETE,
				instr.prefix,
				"Argument of operator prefix [&] must be concrete"
			);
			return Result::ERROR;
		}

		if(target.value_state == TermInfo::ValueState::MOVED_FROM){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.prefix,
				"Argument of operator prefix [&] cannot be moved-from"
			);
			return Result::ERROR;
		}

		if(this->currently_in_unsafe() == false && target.isUninitialized()){
			this->emit_error(
				Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
				instr.prefix,
				"Unsafe prefix operator [&] while not in an unsafe scope",
				Diagnostic::Info("NOTE: the target is uninitialized")
			);
			return Result::ERROR;
		}



		const TypeInfo& target_type = this->context.type_manager.getTypeInfo(target.type_id.as<TypeInfo::ID>());

		const TypeInfo::ID resultant_type_id = this->context.type_manager.getOrCreateTypeInfo(
			target_type.copyWithPushedQualifier(
				TypeInfo::Qualifier(true, target.is_mutable(), target.isUninitialized(), false)
			)
		);


		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			resultant_type_id,
			sema::Expr(this->context.sema_buffer.createAddrOf(target.getExpr()))
		);

		return Result::SUCCESS;
	}


	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::instr_prefix_negate(const Instruction::PrefixNegate<IS_COMPTIME>& instr) -> Result {
		TermInfo& expr = this->get_term_info(instr.expr);

		if(expr.isSingleValue() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_MULTI_RETURN_INTO_SINGLE_VALUE,
				instr.prefix.rhs,
				"Operator prefix [-] cannot accept multiple values"
			);
			return Result::ERROR;
		}

		if constexpr(IS_COMPTIME){
			if(expr.getExpr().kind() == sema::Expr::Kind::INT_VALUE){
				sema::IntValue& int_value = this->context.sema_buffer.int_values[expr.getExpr().intValueID()];
				int_value.value = core::GenericInt(int_value.value.getBitWidth(), 0).ssub(int_value.value).result;

				this->return_term_info(instr.output, expr);
				return Result::SUCCESS;
				
			}else{
				sema::FloatValue& float_value =
					this->context.sema_buffer.float_values[expr.getExpr().floatValueID()];
				float_value.value = float_value.value.neg();

				this->return_term_info(instr.output, expr);
				return Result::SUCCESS;
			}

		}else{
			if(
				expr.value_state != TermInfo::ValueState::INIT
				&& expr.value_state != TermInfo::ValueState::NOT_APPLICABLE
			){
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
					instr.prefix.rhs,
					"Argument of operator prefix [-] must be initialized"
				);
				return Result::ERROR;
			}

			if(expr.value_category == TermInfo::ValueCategory::EPHEMERAL_FLUID){
				if(expr.getExpr().kind() == sema::Expr::Kind::INT_VALUE){
					sema::IntValue& int_value = this->context.sema_buffer.int_values[expr.getExpr().intValueID()];
					int_value.value = core::GenericInt(int_value.value.getBitWidth(), 0).ssub(int_value.value).result;

					this->return_term_info(instr.output, expr);
					return Result::SUCCESS;
					
				}else{
					sema::FloatValue& float_value =
						this->context.sema_buffer.float_values[expr.getExpr().floatValueID()];
					float_value.value = float_value.value.neg();

					this->return_term_info(instr.output, expr);
					return Result::SUCCESS;
				}

			}else{
				if(expr.type_id.is<TypeInfo::ID>()){
					const TypeInfo& expr_type_info =
						this->context.getTypeManager().getTypeInfo(expr.type_id.as<TypeInfo::ID>());

					if(
						expr_type_info.qualifiers().empty()
						&& expr_type_info.baseTypeID().kind() == BaseType::Kind::STRUCT
					){
						const BaseType::Struct& target_struct_type =
							this->context.getTypeManager().getStruct(expr_type_info.baseTypeID().structID());

						return this->prefix_overload_impl(
							target_struct_type.prefixOverloads, expr, instr.prefix, instr.output
						);
					}
				}

				if(this->context.getTypeManager().isSignedIntegral(expr.type_id.as<TypeInfo::ID>())){
					using InstantiationID = sema::TemplateIntrinsicFuncInstantiation::ID;
					const InstantiationID instantiation_id =
						this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::SUB,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								expr.type_id.as<TypeInfo::ID>(), core::GenericValue(false)
							}
						);

					const sema::IntValue::ID zero = this->context.sema_buffer.createIntValue(
						core::GenericInt::create<int64_t>(0), // TODO(FUTURE): set to same width as expr?
						this->context.getTypeManager().getTypeInfo(expr.type_id.as<TypeInfo::ID>()).baseTypeID()
					);

					const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
						instantiation_id, evo::SmallVector<sema::Expr>{sema::Expr(zero), expr.getExpr()}
					);

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						expr.value_stage,
						TermInfo::ValueState::NOT_APPLICABLE,
						expr.type_id.as<TypeInfo::ID>(),
						sema::Expr(created_func_call_id)
					);
					return Result::SUCCESS;

					
				}else if(this->context.getTypeManager().isFloatingPoint(expr.type_id.as<TypeInfo::ID>())){
					using InstantiationID = sema::TemplateIntrinsicFuncInstantiation::ID;
					const InstantiationID instantiation_id =
						this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::FNEG,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								expr.type_id.as<TypeInfo::ID>()
							}
						);

					const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
						instantiation_id, evo::SmallVector<sema::Expr>{expr.getExpr()}
					);

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						expr.value_stage,
						TermInfo::ValueState::NOT_APPLICABLE,
						expr.type_id.as<TypeInfo::ID>(),
						sema::Expr(created_func_call_id)
					);
					return Result::SUCCESS;
					
				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_NEGATE_ARG_INVALID_TYPE,
						instr.prefix.rhs,
						"Operator prefix [-] can only accept signed integrals and floats"
					);
					return Result::ERROR;
				}
			}
		}
	}


	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::instr_prefix_not(const Instruction::PrefixNot<IS_COMPTIME>& instr) -> Result {
		TermInfo& expr = this->get_term_info(instr.expr);

		if(expr.type_id.is<TypeInfo::ID>()){
			const TypeInfo& expr_type_info =
				this->context.getTypeManager().getTypeInfo(expr.type_id.as<TypeInfo::ID>());

			if(
				expr_type_info.qualifiers().empty()
				&& expr_type_info.baseTypeID().kind() == BaseType::Kind::STRUCT
			){
				const BaseType::Struct& target_struct_type =
					this->context.getTypeManager().getStruct(expr_type_info.baseTypeID().structID());

				return this->prefix_overload_impl(target_struct_type.prefixOverloads, expr, instr.prefix, instr.output);
			}
		}


		if(this->type_check<true, true>(
			TypeManager::getTypeBool(), expr, "RHS of operator [!]", instr.prefix.rhs
		).ok == false){
			return Result::ERROR;
		}

		if(
			expr.value_state != TermInfo::ValueState::INIT
			&& expr.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.prefix.rhs,
				"Argument of operator [!] must be initialized"
			);
			return Result::ERROR;
		}


		if constexpr(IS_COMPTIME){
			sema::BoolValue& bool_value = this->context.sema_buffer.bool_values[expr.getExpr().boolValueID()];
			bool_value.value = !bool_value.value;

			this->return_term_info(instr.output, expr);
			return Result::SUCCESS;

		}else{
			using InstantiationID = sema::TemplateIntrinsicFuncInstantiation::ID;
			const InstantiationID instantiation_id =
				this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
					TemplateIntrinsicFunc::Kind::XOR,
					evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
						expr.type_id.as<TypeInfo::ID>()
					}
				);

			const sema::BoolValue::ID true_value = this->context.sema_buffer.createBoolValue(true);

			const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
				instantiation_id, evo::SmallVector<sema::Expr>{expr.getExpr(), sema::Expr(true_value)}
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				expr.value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				TypeManager::getTypeBool(),
				sema::Expr(created_func_call_id)
			);
			return Result::SUCCESS;
		}
	}



	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::instr_prefix_bitwise_not(const Instruction::PrefixBitwiseNot<IS_COMPTIME>& instr)
	-> Result {
		TermInfo& expr = this->get_term_info(instr.expr);

		if(expr.isSingleValue() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_MULTI_RETURN_INTO_SINGLE_VALUE,
				instr.prefix.rhs,
				"Operator [~] cannot accept multiple values"
			);
			return Result::ERROR;
		}

		if(expr.value_category == TermInfo::ValueCategory::EPHEMERAL_FLUID){
			this->emit_error(
				Diagnostic::Code::SEMA_BITWISE_NOT_ARG_FLUID,
				instr.prefix.rhs,
				"Operator [~] cannot accept fluid values"
			);
			return Result::ERROR;
		}


		if(
			expr.value_state != TermInfo::ValueState::INIT
			&& expr.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.prefix.rhs,
				"Argument of operator [~] must be initialized"
			);
			return Result::ERROR;
		}

		if(expr.type_id.is<TypeInfo::ID>()){
			const TypeInfo& expr_type_info =
				this->context.getTypeManager().getTypeInfo(expr.type_id.as<TypeInfo::ID>());

			if(
				expr_type_info.qualifiers().empty()
				&& expr_type_info.baseTypeID().kind() == BaseType::Kind::STRUCT
			){
				const BaseType::Struct& target_struct_type =
					this->context.getTypeManager().getStruct(expr_type_info.baseTypeID().structID());

				return this->prefix_overload_impl(target_struct_type.prefixOverloads, expr, instr.prefix, instr.output);
			}
		}
			
		if(this->context.getTypeManager().isIntegral(expr.type_id.as<TypeInfo::ID>()) == false){
			this->emit_error(
				Diagnostic::Code::SEMA_BITWISE_NOT_ARG_NOT_INTEGRAL,
				instr.prefix.rhs,
				"Operator [~] can only accept integrals"
			);
			return Result::ERROR;
		}


		if constexpr(IS_COMPTIME){
			sema::IntValue& int_value = this->context.sema_buffer.int_values[expr.getExpr().intValueID()];
			int_value.value =
				int_value.value.bitwiseXor(core::GenericInt(int_value.value.getBitWidth(), 0).bitwiseNot());

			this->return_term_info(instr.output, expr);
			return Result::SUCCESS;

		}else{
			if(expr.value_category == TermInfo::ValueCategory::EPHEMERAL_FLUID){
				sema::IntValue& int_value = this->context.sema_buffer.int_values[expr.getExpr().intValueID()];
				int_value.value =
					int_value.value.bitwiseXor(core::GenericInt(int_value.value.getBitWidth(), 0).bitwiseNot());

				this->return_term_info(instr.output, expr);
				return Result::SUCCESS;
				
			}else{
				using InstantiationID = sema::TemplateIntrinsicFuncInstantiation::ID;
				const InstantiationID instantiation_id =
					this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
						TemplateIntrinsicFunc::Kind::XOR,
						evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
							expr.type_id.as<TypeInfo::ID>()
						}
					);

				const sema::IntValue::ID all_ones = this->context.sema_buffer.createIntValue(
					core::GenericInt::create<int64_t>(0).bitwiseNot(), // TODO(FUTURE): set to same width as expr?
					this->context.getTypeManager().getTypeInfo(expr.type_id.as<TypeInfo::ID>()).baseTypeID()
				);

				const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
					instantiation_id, evo::SmallVector<sema::Expr>{expr.getExpr(), sema::Expr(all_ones)}
				);

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					expr.value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					expr.type_id.as<TypeInfo::ID>(),
					sema::Expr(created_func_call_id)
				);
				return Result::SUCCESS;
			}
		}
	}




	auto SemanticAnalyzer::instr_deref(const Instruction::Deref& instr) -> Result {
		const TermInfo& target = this->get_term_info(instr.target);

		if(
			target.value_state != TermInfo::ValueState::INIT
			&& target.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.postfix,
				"Argument of operator [.*] must be initialized"
			);
			return Result::ERROR;
		}


		if(target.type_id.is<TypeInfo::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_DEREF_ARG_NOT_PTR,
				instr.postfix,
				"Argument of operator [.*] must be a pointer"
			);
			return Result::ERROR;
		}

		const TypeInfo& target_type = this->context.getTypeManager().getTypeInfo(target.type_id.as<TypeInfo::ID>());

		if(target_type.isPointer() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_DEREF_ARG_NOT_PTR,
				instr.postfix,
				"Argument of operator [.*] must be a pointer"
			);
			return Result::ERROR;
		}

		if(target_type.isOptional()){
			this->emit_error(
				Diagnostic::Code::SEMA_DEREF_ARG_NOT_PTR,
				instr.postfix,
				"Argument of operator [.*] must be a non-optional pointer",
				Diagnostic::Info("Did you mean \".?.*\" instead?")
			);
			return Result::ERROR;
		}



		const TypeInfo::ID resultant_type_id = this->context.type_manager.getOrCreateTypeInfo(
			target_type.copyWithPoppedQualifier()
		);


		const std::optional<SymbolProc::ID> resultant_type_symbol_proc_id =
			this->context.symbol_proc_manager.getTypeSymbolProc(resultant_type_id);

		if(resultant_type_symbol_proc_id.has_value()){
			const SymbolProc::WaitOnResult wait_on_result = this->context.symbol_proc_manager
				.getSymbolProc(*resultant_type_symbol_proc_id)
				.waitOnDefIfNeeded(this->symbol_proc_id, this->context, *resultant_type_symbol_proc_id);

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                 break;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*resultant_type_symbol_proc_id);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                    return Result::NEED_TO_WAIT;
				case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: evo::debugFatalBreak("Not possible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
			}
		}


		using ValueCategory = TermInfo::ValueCategory;

		this->return_term_info(instr.output,
			target_type.qualifiers().back().isMut ? ValueCategory::CONCRETE_MUT : ValueCategory::CONCRETE_CONST,
			target.value_stage,
			target_type.qualifiers().back().isUninit
				? TermInfo::ValueState::UNINIT
				: TermInfo::ValueState::NOT_APPLICABLE,
			resultant_type_id,
			sema::Expr(this->context.sema_buffer.createDeref(target.getExpr(), resultant_type_id))
		);

		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_unwrap(const Instruction::Unwrap& instr) -> Result {
		const TermInfo& target = this->get_term_info(instr.target);

		if(
			target.value_state != TermInfo::ValueState::INIT
			&& target.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.postfix.lhs,
				"Argument of operator [.?] must be initialized"
			);
			return Result::ERROR;
		}

		if(target.type_id.is<TypeInfo::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_UNWRAP_ARG_NOT_OPTIONAL,
				instr.postfix.lhs,
				"Argument of operator [.?] must be an optional"
			);
			return Result::ERROR;
		}

		const TypeInfo& target_type = this->context.getTypeManager().getTypeInfo(target.type_id.as<TypeInfo::ID>());

		if(target_type.isOptional() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_UNWRAP_ARG_NOT_OPTIONAL,
				instr.postfix.lhs,
				"Argument of operator [.?] must be an opional"
			);
			return Result::ERROR;
		}


		auto resultant_qualifiers = evo::SmallVector<TypeInfo::Qualifier>(
			target_type.qualifiers().begin(), target_type.qualifiers().end()
		);
		resultant_qualifiers.back().isOptional = false;
		if(target_type.isPointer() == false){
			resultant_qualifiers.back().isPtr = true;
			resultant_qualifiers.back().isMut = target.is_mutable();
		}
		const TypeInfo::ID resultant_type_id = this->context.type_manager.getOrCreateTypeInfo(
			TypeInfo(target_type.baseTypeID(), std::move(resultant_qualifiers))
		);

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			resultant_type_id,
			sema::Expr(this->context.sema_buffer.createUnwrap(target.getExpr(), target.type_id.as<TypeInfo::ID>()))
		);
		return Result::SUCCESS;
	}



	template<bool IS_COMPTIME, bool ERRORS>
	auto SemanticAnalyzer::instr_new(const Instruction::New<IS_COMPTIME, ERRORS>& instr) -> Result {
		const TypeInfo::VoidableID target_type_id = this->get_type(instr.type_id);
		if(target_type_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_TYPE_VOID,
				instr.ast_new.type,
				"Operator [new] cannot accept type `Void`"
			);
			return Result::ERROR;
		}

		const TypeInfo& decayed_target_type_info = this->context.getTypeManager().getTypeInfo(
			this->context.type_manager.decayType<true, true>(target_type_id.asTypeID())
		);


		if(decayed_target_type_info.qualifiers().empty() == false){
			if(decayed_target_type_info.isOptional()){
				if constexpr(ERRORS){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_DOESNT_ERROR,
						instr.ast_new.type,
						"Operator [new] doesn't error"
					);
					return Result::ERROR;

				}else{
					if(instr.args.empty()){
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type_id.asTypeID(),
							sema::Expr(this->context.sema_buffer.createDefaultNew(target_type_id.asTypeID(), true))
						);
						return Result::SUCCESS;

					}else if(instr.args.size() == 1){
						TermInfo& arg = this->get_term_info(instr.args[0]);

						if(instr.ast_new.args[0].label.has_value()){
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_OPTIONAL_NO_MATCHING_OVERLOAD,
								instr.ast_new.type,
								"No matching operator [new] overload for this type",
								Diagnostic::Info("No operator [new] of optional accepts arguments with labels")
							);
							return Result::ERROR;
						}

						if(arg.value_category == TermInfo::ValueCategory::NULL_VALUE){
							this->return_term_info(instr.output,
								TermInfo::ValueCategory::EPHEMERAL,
								TermInfo::ValueStage::COMPTIME,
								TermInfo::ValueState::NOT_APPLICABLE,
								target_type_id.asTypeID(),
								sema::Expr(this->context.sema_buffer.createDefaultNew(target_type_id.asTypeID(), true))
							);

						}else{
							if(arg.is_ephemeral() == false){
								this->emit_error(
									Diagnostic::Code::SEMA_NEW_OPTIONAL_ARG_NOT_EPHEMERAL,
									instr.ast_new.args[0].value,
									"Argument in operator [new] for optional must be ephemeral or [null]"
								);
								return Result::ERROR;
							}

							const TypeInfo::ID optional_held_type_id = this->context.type_manager.getOrCreateTypeInfo(
								TypeInfo(
									decayed_target_type_info.baseTypeID(),
									evo::SmallVector<TypeInfo::Qualifier>(
										decayed_target_type_info.qualifiers().begin(),
										std::prev(decayed_target_type_info.qualifiers().end())
									)
								)
							);

							if(this->type_check<true, true>(
								optional_held_type_id,
								arg,
								"Argument in operator [new] for optional",
								instr.ast_new.args[0].value
							).ok == false){
								return Result::ERROR;
							}

							this->return_term_info(instr.output,
								TermInfo::ValueCategory::EPHEMERAL,
								TermInfo::ValueStage::COMPTIME,
								TermInfo::ValueState::NOT_APPLICABLE,
								target_type_id.asTypeID(),
								sema::Expr(
									this->context.sema_buffer.createConversionToOptional(
										arg.getExpr(), target_type_id.asTypeID()
									)
								)
							);
						}

						return Result::SUCCESS;

					}else{
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_OPTIONAL_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info("Too may arguments")
						);
						return Result::ERROR;
					}
				}
			}

			this->emit_error(
				Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
				instr.ast_new.type,
				"Operator [new] of this type is unimplemented"
			);
			return Result::ERROR;
		}


		switch(decayed_target_type_info.baseTypeID().kind()){
			case BaseType::Kind::PRIMITIVE: {
				if constexpr(ERRORS){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_DOESNT_ERROR,
						instr.ast_new.type,
						"Operator [new] doesn't error"
					);
					return Result::ERROR;

				}else{
					if(instr.args.empty()){
						const BaseType::Primitive& primitive = this->context.getTypeManager().getPrimitive(
							decayed_target_type_info.baseTypeID().primitiveID()
						);

						if(
							primitive.kind() == Token::Kind::TYPE_RAWPTR
							|| primitive.kind() == Token::Kind::TYPE_TYPEID
						){
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_PRIMITIVE_NO_MATCHING_OVERLOAD,
								instr.ast_new.type,
								"No matching operator [new] overload for this type"
							);
							return Result::ERROR;
						}

						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type_id.asTypeID(),
							sema::Expr(this->context.sema_buffer.createDefaultNew(target_type_id.asTypeID(), true))
						);
						return Result::SUCCESS;
						
					}else if(instr.args.size() == 1){
						TermInfo& arg = this->get_term_info(instr.args[0]);

						if(arg.is_ephemeral() == false){
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_PRIMITIVE_ARG_NOT_EPHEMERAL,
								instr.ast_new.args[0].value,
								"Argument in operator [new] for primitive must be ephemeral"
							);
							return Result::ERROR;
						}

						if(this->type_check<true, true>(
							target_type_id.asTypeID(),
							arg,
							"Argument of operator [new] for primitive",
							instr.ast_new.args[0].value
						).ok == false){
							return Result::ERROR;
						}

						this->return_term_info(instr.output, arg);
						return Result::SUCCESS;
						
					}else{
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_PRIMITIVE_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info("Too may arguments")
						);
						return Result::ERROR;
					}
				}
			} break;

			case BaseType::Kind::ARRAY: {
				if constexpr(ERRORS){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_DOESNT_ERROR,
						instr.ast_new.type,
						"Operator [new] doesn't error"
					);
					return Result::ERROR;

				}else{
					if(instr.args.size() != 0){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_ARRAY_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info(
								std::format("Expected {} arguments, got {}", 0, instr.args.size())
							)
						);
						return Result::ERROR;
					}

					const BaseType::Array& array_type =
						this->context.getTypeManager().getArray(decayed_target_type_info.baseTypeID().arrayID());

					if(this->context.getTypeManager().isDefaultInitializable(array_type.elementTypeID) == false){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_ARRAY_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info("Array element type is not default initializable")
						);
						return Result::ERROR;	
					}

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type_id.asTypeID(),
						sema::Expr(this->context.sema_buffer.createDefaultNew(target_type_id.asTypeID(), true))
					);

					return Result::SUCCESS;
				}
			} break;

			case BaseType::Kind::ARRAY_REF: {
				if constexpr(ERRORS){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_DOESNT_ERROR,
						instr.ast_new.type,
						"Operator [new] doesn't error"
					);
					return Result::ERROR;

				}else{
					if(instr.args.empty()){
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type_id.asTypeID(),
							sema::Expr(this->context.sema_buffer.createDefaultNew(target_type_id.asTypeID(), true))
						);
						return Result::SUCCESS;
					}

					const BaseType::ArrayRef& array_ref =
						this->context.getTypeManager().getArrayRef(decayed_target_type_info.baseTypeID().arrayRefID());

					const size_t num_ref_ptrs = array_ref.getNumRefPtrs();

					if(instr.args.size() != num_ref_ptrs + 1){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_ARRAY_REF_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info(
								std::format("Expected {} arguments, got {}", num_ref_ptrs + 1, instr.args.size())
							)
						);
						return Result::ERROR;
					}

					if(this->get_term_info(instr.args[0]).is_ephemeral() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_ARRAY_REF_ARG_NOT_EPHEMERAL,
							instr.ast_new.args[0].value,
							"Argument in operator [new] for array reference must be ephemeral"
						);
						return Result::ERROR;
					}

					const TypeInfo::ID array_ptr_type = this->context.type_manager.getOrCreateTypeInfo(
						this->context.getTypeManager().getTypeInfo(array_ref.elementTypeID)
							.copyWithPushedQualifier(TypeInfo::Qualifier(true, array_ref.isMut, false, false))
					);

					if(this->type_check<true, true>(
						array_ptr_type,
						this->get_term_info(instr.args[0]),
						"Pointer argument of operator [new] for array reference",
						instr.ast_new.args[0].value
					).ok == false){
						return Result::ERROR;
					}

					if(instr.ast_new.args[0].label.has_value()){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_ARRAY_REF_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info("No operator [new] of array reference accepts arguments with labels")
						);
					}


					for(size_t i = 1; i < num_ref_ptrs + 1; i+=1){
						TermInfo& arg_term_info = this->get_term_info(instr.args[i]);

						if(arg_term_info.is_ephemeral() == false){
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_ARRAY_REF_ARG_NOT_EPHEMERAL,
								instr.ast_new.args[i].value,
								"Argument in operator [new] for array reference must be ephemeral"
							);
							return Result::ERROR;
						}

						if(this->type_check<true, true>(
							TypeManager::getTypeUSize(),
							arg_term_info,
							"Dimension argument of operator [new] for array reference",
							instr.ast_new.args[i].value
						).ok == false){
							return Result::ERROR;
						}

						if(instr.ast_new.args[i].label.has_value()){
							this->emit_error(
								Diagnostic::Code::SEMA_NEW_ARRAY_REF_NO_MATCHING_OVERLOAD,
								instr.ast_new.type,
								"No matching operator [new] overload for this type",
								Diagnostic::Info("No operator [new] of array reference accepts arguments with labels")
							);
						}
					}


					auto dimensions = evo::SmallVector<evo::Variant<uint64_t, sema::Expr>>();
					dimensions.reserve(array_ref.dimensions.size());
					for(const BaseType::ArrayRef::Dimension& dimension : array_ref.dimensions){
						if(dimension.isPtr()){
							dimensions.emplace_back(this->get_term_info(instr.args[dimensions.size() + 1]).getExpr());
						}
					}

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type_id.asTypeID(),
						sema::Expr(this->context.sema_buffer.createInitArrayRef(
							this->get_term_info(instr.args[0]).getExpr(), std::move(dimensions)
						))
					);
					return Result::SUCCESS;
				}
			} break;

			case BaseType::Kind::STRUCT: {
				const BaseType::Struct& target_struct =
					this->context.getTypeManager().getStruct(decayed_target_type_info.baseTypeID().structID());

				if(instr.args.empty()){
					if(target_struct.isTriviallyDefaultInitializable){
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							this->get_current_func().attributes.isComptime
								? TermInfo::ValueStage::INTERPTIME
								: TermInfo::ValueStage::RUNTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type_id.asTypeID(),
							sema::Expr(
								this->context.sema_buffer.createDefaultNew(target_type_id.asTypeID(), true)
							)
						);
						return Result::SUCCESS;

					}else if(target_struct.newInitOverloads.empty()){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_STRUCT_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info("Compiler didn't generate a default operator [new]")
						);
						return Result::ERROR;
					}

				}else if(target_struct.newInitOverloads.empty()){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_STRUCT_NO_MATCHING_OVERLOAD,
						instr.ast_new.type,
						"No matching operator [new] overload for this type",
						Diagnostic::Info("Compiler didn't generate an operator [new]")
					);
					return Result::ERROR;
				}


				auto overloads = evo::SmallVector<SelectFuncOverloadFuncInfo>();
				overloads.reserve(target_struct.newInitOverloads.size());
				for(const sema::Func::ID overload_id : target_struct.newInitOverloads){
					const sema::Func& overload = this->context.getSemaBuffer().getFunc(overload_id);

					overloads.emplace_back(overload_id, this->context.getTypeManager().getFunction(overload.typeID));
				}


				auto args = evo::SmallVector<SelectFuncOverloadArgInfo>();
				args.reserve(instr.args.size());
				for(size_t i = 0; const SymbolProc::TermInfoID& arg_id : instr.args){
					args.emplace_back(
						this->get_term_info(arg_id), instr.ast_new.args[i].value, instr.ast_new.args[i].label
					);

					i += 1;
				}

				const evo::Result<size_t> selected_overload = this->select_func_overload(
					overloads, args, instr.ast_new, false, evo::SmallVector<Diagnostic::Info>()
				);
				if(selected_overload.isError()){ return Result::ERROR; }

				const sema::Func::ID selected_func_id =
					overloads[selected_overload.value()].func_id.as<sema::Func::ID>();
				const sema::Func& selected_func = this->context.getSemaBuffer().getFunc(selected_func_id);

				const BaseType::Function& selected_func_type =
					this->context.getTypeManager().getFunction(selected_func.typeID);

				if constexpr(ERRORS){
					if(selected_func_type.hasErrorReturn() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_FUNC_DOESNT_ERROR,
							instr.ast_new.type,
							"Operator [new] doesn't error"
						);
						return Result::ERROR;
					}
				}else{
					if(selected_func_type.hasErrorReturn()){
						this->emit_error(
							Diagnostic::Code::SEMA_FUNC_ERRORS,
							instr.ast_new.type,
							"Operator [new] error not handled"
						);
						return Result::ERROR;
					}
				}

				if(this->currently_in_unsafe() == false && selected_func_type.isUnsafe){
					this->emit_error(
						Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
						instr.ast_new,
						"Unsafe operator [new] while not in an unsafe scope"
					);
					return Result::ERROR;
				}


				auto output_args = evo::SmallVector<sema::Expr>();
				output_args.reserve(selected_func.params.size());
				for(const SymbolProc::TermInfoID& arg_id : instr.args){
					output_args.emplace_back(this->get_term_info(arg_id).getExpr());
				}

				// default values
				for(size_t i = output_args.size(); i < selected_func.params.size(); i+=1){
					output_args.emplace_back(*selected_func.params[i].defaultValue);
				}



				if constexpr(IS_COMPTIME){
					this->emit_error(
						Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
						instr.ast_new,
						"Comptime operator [new] is unimplemented"
					);
					return Result::ERROR;

				}else{
					if(this->get_current_func().attributes.isComptime){
						if(selected_func.attributes.isComptime == false){
							this->emit_error(
								Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
								instr.ast_new,
								"Cannot call a non-comptime operator [new] within a comptime function",
								Diagnostic::Info(
									"Called operator [new] was defined here:", this->get_location(selected_func_id)
								)
							);
							return Result::ERROR;
						}

						this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(
							selected_func_id
						);
					}


					const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
						selected_func_id, std::move(output_args)
					);

					this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(selected_func_id);

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						this->get_current_func().attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type_id.asTypeID(),
						sema::Expr(created_func_call_id)
					);
					return Result::SUCCESS;
				}
			} break;

			case BaseType::Kind::UNION: {
				if constexpr(ERRORS){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_DOESNT_ERROR,
						instr.ast_new.type,
						"Operator [new] doesn't error"
					);
					return Result::ERROR;

				}else{
					if(instr.args.size() != 0){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_UNION_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info(
								std::format("Expected {} arguments, got {}", 0, instr.args.size())
							)
						);
						return Result::ERROR;
					}

					if(
						this->context.getTypeManager().isDefaultInitializable(decayed_target_type_info.baseTypeID())
							== false
					){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_UNION_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type"
						);
						return Result::ERROR;	
					}

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type_id.asTypeID(),
						sema::Expr(this->context.sema_buffer.createDefaultNew(target_type_id.asTypeID(), true))
					);

					return Result::SUCCESS;
				}
			} break;

			case BaseType::Kind::INTERFACE_MAP: {
				if constexpr(ERRORS){
					this->emit_error(
						Diagnostic::Code::SEMA_FUNC_DOESNT_ERROR,
						instr.ast_new.type,
						"Operator [new] doesn't error"
					);
					return Result::ERROR;

				}else{
					if(instr.args.size() != 0){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_UNION_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type",
							Diagnostic::Info(
								std::format("Expected {} arguments, got {}", 0, instr.args.size())
							)
						);
						return Result::ERROR;
					}


					if(
						this->context.getTypeManager().isDefaultInitializable(decayed_target_type_info.baseTypeID())
							== false
					){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_UNION_NO_MATCHING_OVERLOAD,
							instr.ast_new.type,
							"No matching operator [new] overload for this type"
						);
						return Result::ERROR;	
					}

				
					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type_id.asTypeID(),
						sema::Expr(this->context.sema_buffer.createDefaultNew(target_type_id.asTypeID(), true))
					);

					return Result::SUCCESS;
				}
			} break;

			default: {
				this->emit_error(
					Diagnostic::Code::SEMA_NEW_INVALID_TYPE,
					instr.ast_new.type,
					"Invalid type for operator [new]"
				);
				return Result::ERROR;
			} break;
		}
	}



	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::instr_array_init_new(const Instruction::ArrayInitNew<IS_COMPTIME>& instr) -> Result {
		const TypeInfo::VoidableID target_type_id = this->get_type(instr.type_id);
		if(target_type_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_TYPE_VOID,
				instr.array_init_new.type,
				"Operator [new] cannot accept type `Void`"
			);
			return Result::ERROR;
		}

		const TypeInfo& decayed_target_type_info = this->context.getTypeManager().getTypeInfo(
			this->context.type_manager.decayType<true, true>(target_type_id.asTypeID())
		);

		if(
			decayed_target_type_info.qualifiers().empty() == false
			|| decayed_target_type_info.baseTypeID().kind() != BaseType::Kind::ARRAY
		){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_ARRAY_INIT_NOT_ARRAY,
				instr.array_init_new.type,
				"Array initializer operator [new] cannot accept a type that's not an array"
			);
			return Result::ERROR;
		}

		const BaseType::Array& target_type = this->context.getTypeManager().getArray(
			decayed_target_type_info.baseTypeID().arrayID()
		);

		if(target_type.dimensions.size() > 1){
			this->emit_error(
				Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
				instr.array_init_new.type,
				"Array initializer operator [new] for multi-dimensional array types is currently unimplemented"
			);
			return Result::ERROR;
		}

		if(instr.values.size() != target_type.dimensions[0]){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_ARRAY_INIT_INCORRECT_SIZE,
				instr.array_init_new.keyword,
				"Array initializer operator [new] got incorrect number of values",
				Diagnostic::Info(std::format("Expected {}, got {}", target_type.dimensions[0], instr.values.size()))
			);
			return Result::ERROR;
		}


		if(
			this->context.getTypeManager().getTypeInfo(target_type.elementTypeID).isUninitPointer()
			&& this->currently_in_unsafe() == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
				instr.array_init_new,
				"Array initializer of uninitialized qualified pointers while not in an unsafe scope"
			);
			return Result::ERROR;
		}


		auto values = evo::SmallVector<sema::Expr>();
		values.reserve(instr.values.size() + size_t(target_type.terminator.has_value()));

		for(size_t i = 0; const SymbolProc::TermInfoID value_id : instr.values){
			TermInfo& value = this->get_term_info(value_id);

			if(value.is_ephemeral() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_NEW_ARRAY_INIT_VAL_NOT_EPHERMERAL,
					instr.array_init_new.values[i],
					"Array initializer operator [new] value initializer must be ephemeral"
				);
				return Result::ERROR;
			}

			if(this->type_check<true, true>(
				target_type.elementTypeID, value, "Value initializer", instr.array_init_new.values[i]
			).ok == false){
				return Result::ERROR;
			}

			values.emplace_back(value.getExpr());

			i += 1;
		}

		if(target_type.terminator.has_value()){
			values.emplace_back(
				this->generic_value_to_sema_expr(
					*target_type.terminator, this->context.getTypeManager().getTypeInfo(target_type.elementTypeID)
				)
			);
		}

		const sema::AggregateValue::ID created_aggregate_value = this->context.sema_buffer.createAggregateValue(
			std::move(values), decayed_target_type_info.baseTypeID()
		);

		const TermInfo::ValueStage value_stage = [&](){
			if constexpr(IS_COMPTIME){
				return TermInfo::ValueStage::COMPTIME;
			}else{
				if(this->currently_in_func() == false){
					return TermInfo::ValueStage::COMPTIME;

				}else if(this->get_current_func().attributes.isComptime){
					return TermInfo::ValueStage::INTERPTIME;

				}else{
					return TermInfo::ValueStage::RUNTIME;
				}
			}
		}();


		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			target_type_id.asTypeID(),
			sema::Expr(created_aggregate_value)
		);
		return Result::SUCCESS;
	}


	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::instr_designated_init_new(const Instruction::DesignatedInitNew<IS_COMPTIME>& instr)
	-> Result {
		const TypeInfo::VoidableID target_type_id = this->get_type(instr.type_id);
		if(target_type_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_TYPE_VOID,
				instr.designated_init_new.type,
				"Operator [new] cannot accept type `Void`"
			);
			return Result::ERROR;
		}

		const TypeInfo& target_type_info = this->context.getTypeManager().getTypeInfo(
			this->context.type_manager.decayType<true, true>(target_type_id.asTypeID())
		);
		if(target_type_info.qualifiers().empty() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_STRUCT_INIT_NOT_STRUCT,
				instr.designated_init_new.type,
				"Designated initializer operator [new] cannot accept a type that's not a struct or a union"
			);
			return Result::ERROR;
		}


		if(target_type_info.baseTypeID().kind() == BaseType::Kind::UNION){
			return this->union_designated_init_new(instr, target_type_id.asTypeID());

		}else if(target_type_info.baseTypeID().kind() != BaseType::Kind::STRUCT){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_STRUCT_INIT_NOT_STRUCT,
				instr.designated_init_new.type,
				"Designated initializer operator [new] cannot accept a type that's not a struct or a union"
			);
			return Result::ERROR;
		}



		const BaseType::Struct& target_type = this->context.getTypeManager().getStruct(
			target_type_info.baseTypeID().structID()
		);


		if(target_type.newInitOverloads.empty() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_NEW_STRUCT_DESIGNATED_ON_TYPE_WITH_OVEROAD_NEW,
				instr.designated_init_new,
				"Designatied initializer operator [new] on type that has overloaded operator [new]"
			);
			return Result::ERROR;
		}


		if(target_type.memberVars.empty()){
			if(instr.designated_init_new.memberInits.empty() == false){
				const AST::DesignatedInitNew::MemberInit& member_init = instr.designated_init_new.memberInits[0];

				const std::string_view member_init_ident = this->source.getTokenBuffer()[member_init.ident].getString();

				this->emit_error(
					Diagnostic::Code::SEMA_NEW_STRUCT_MEMBER_DOESNT_EXIST,
					member_init.ident,
					std::format("This struct has no member \"{}\"", member_init_ident),
					evo::SmallVector<Diagnostic::Info>{
						Diagnostic::Info("Struct is empty"),
						Diagnostic::Info(
							"Struct was declared here:",
							this->get_location(target_type_info.baseTypeID().structID())
						)
					}
				);
				return Result::ERROR;
			}


			const sema::AggregateValue::ID created_aggregate_value = this->context.sema_buffer.createAggregateValue(
				evo::SmallVector<sema::Expr>(), target_type_info.baseTypeID()
			);

			const TermInfo::ValueStage value_stage = [&](){
				if constexpr(IS_COMPTIME){
					return TermInfo::ValueStage::COMPTIME;
				}else{
					if(this->currently_in_func() == false){
						return TermInfo::ValueStage::COMPTIME;

					}else if(this->get_current_func().attributes.isComptime){
						return TermInfo::ValueStage::INTERPTIME;

					}else{
						return TermInfo::ValueStage::RUNTIME;
					}
				}
			}();


			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				target_type_id.asTypeID(),
				sema::Expr(created_aggregate_value)
			);
			return Result::SUCCESS;
		}



		const auto struct_has_member = [&](std::string_view ident) -> bool {
			for(const BaseType::Struct::MemberVar& member_var : target_type.memberVars){
				const std::string_view member_var_ident = 
					target_type.getMemberName(member_var, this->context.getSourceManager());
			
				if(member_var_ident == ident){ return true; }
			}

			return false;
		};

		auto values = evo::SmallVector<sema::Expr>();
		values.reserve(target_type.memberVars.size());

		size_t member_init_i = 0;
		for(const BaseType::Struct::MemberVar* member_var : target_type.memberVarsABI){
			const std::string_view member_var_ident =
				target_type.getMemberName(*member_var, this->context.getSourceManager());

			if(member_init_i >= instr.designated_init_new.memberInits.size()){
				if(member_var->defaultValue.has_value()){
					values.emplace_back(member_var->defaultValue->value);
					continue;
				}

				if(instr.designated_init_new.memberInits.empty()){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_STRUCT_MEMBER_NOT_SET,
						instr.designated_init_new,
						std::format("Member \"{}\" was not set in struct initializer operator [new]", member_var_ident)
					);
				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_STRUCT_MEMBER_NOT_SET,
						instr.designated_init_new,
						std::format("Member \"{}\" was not set in struct initializer operator [new]", member_var_ident),
						Diagnostic::Info(
							std::format("Member initializer for \"{}\" should go after this one", member_var_ident),
							this->get_location(instr.designated_init_new.memberInits[member_init_i - 1].ident)
						)
					);
				}

				return Result::ERROR;

			}else{
				const AST::DesignatedInitNew::MemberInit& member_init =
					instr.designated_init_new.memberInits[member_init_i];


				const std::string_view member_init_ident = this->source.getTokenBuffer()[member_init.ident].getString();

				if(member_var_ident != member_init_ident){
					if(member_var->defaultValue.has_value()){
						values.emplace_back(member_var->defaultValue->value);
						continue;
					}

					if(struct_has_member(member_init_ident)){
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_STRUCT_MEMBER_NOT_SET,
							instr.designated_init_new,
							std::format(
								"Member \"{}\" was not set in struct initializer operator [new]", member_var_ident
							),
							Diagnostic::Info(
								std::format(
									"Member initializer for \"{}\" should go before this one", member_var_ident
								),
								this->get_location(member_init.ident)
							)
						);
					}else{
						this->emit_error(
							Diagnostic::Code::SEMA_NEW_STRUCT_MEMBER_DOESNT_EXIST,
							member_init.ident,
							std::format("This struct has no member \"{}\"", member_init_ident),
							Diagnostic::Info(
								"Struct was declared here:",
								this->get_location(target_type_info.baseTypeID().structID())
							)
						);
						return Result::ERROR;
					}

					return Result::ERROR;
				}

				TermInfo& member_init_expr = this->get_term_info(instr.member_init_exprs[member_init_i]);

				if(member_init_expr.is_ephemeral() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_STRUCT_MEMBER_VAL_NOT_EPHEMERAL,
						member_init.expr,
						"Member initializer value is not ephemeral"
					);
					return Result::ERROR;
				}

				if(this->type_check<true, true>(
					member_var->typeID, member_init_expr, "Member initializer", member_init.expr
				).ok == false){
					return Result::ERROR;
				}

				values.emplace_back(member_init_expr.getExpr());

				member_init_i += 1;
			}
		}


		if(member_init_i < instr.designated_init_new.memberInits.size()){
			const AST::DesignatedInitNew::MemberInit& member_init =
				instr.designated_init_new.memberInits[member_init_i];

			const std::string_view member_init_ident = this->source.getTokenBuffer()[member_init.ident].getString();

			this->emit_error(
				Diagnostic::Code::SEMA_NEW_STRUCT_MEMBER_DOESNT_EXIST,
				member_init.ident,
				std::format("This struct has no member \"{}\"", member_init_ident),
				Diagnostic::Info(
					"Struct was declared here:",  this->get_location(target_type_info.baseTypeID().structID())
				)
			);
			return Result::ERROR;
		}


		const sema::AggregateValue::ID created_aggregate_value = this->context.sema_buffer.createAggregateValue(
			std::move(values), target_type_info.baseTypeID()
		);

		const TermInfo::ValueStage value_stage = [&](){
			if constexpr(IS_COMPTIME){
				return TermInfo::ValueStage::COMPTIME;
			}else{
				if(this->currently_in_func() == false){
					return TermInfo::ValueStage::COMPTIME;

				}else if(this->get_current_func().attributes.isComptime){
					return TermInfo::ValueStage::INTERPTIME;

				}else{
					return TermInfo::ValueStage::RUNTIME;
				}
			}
		}();


		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			target_type_id.asTypeID(),
			sema::Expr(created_aggregate_value)
		);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_prepare_try_handler(const Instruction::PrepareTryHandler& instr) -> Result {
		this->push_scope_level();

		const SemaBuffer& sema_buffer = this->context.getSemaBuffer();

		const TermInfo& attempt_expr = this->get_term_info(instr.attempt_expr);

		
		const BaseType::Function& attempt_func_type = [&]() -> const BaseType::Function& {
			if(attempt_expr.getExpr().kind() == sema::Expr::Kind::INTERFACE_CALL){
				const sema::InterfaceCall& interface_call = 
					this->context.getSemaBuffer().getInterfaceCall(attempt_expr.getExpr().interfaceCallID());

				return this->context.getTypeManager().getFunction(interface_call.funcTypeID);

			}else{
				const sema::FuncCall& attempt_func_call = sema_buffer.getFuncCall(attempt_expr.getExpr().funcCallID());

				return *attempt_func_call.target.visit([&](const auto& target) -> const BaseType::Function* {
					using Target = std::decay_t<decltype(target)>;

					if constexpr(std::is_same<Target, sema::Func::ID>()){
						return &this->context.getTypeManager().getFunction(sema_buffer.getFunc(target).typeID);
						
					}else if constexpr(std::is_same<Target, IntrinsicFunc::Kind>()){
						const TypeInfo::ID type_info_id = this->context.getIntrinsicFuncInfo(target).typeID;
						const TypeInfo& type_info = this->context.getTypeManager().getTypeInfo(type_info_id);
						return &this->context.getTypeManager().getFunction(type_info.baseTypeID().funcID());
						
					}else if constexpr(std::is_same<Target, sema::TemplateIntrinsicFuncInstantiation::ID>()){
						const sema::TemplateIntrinsicFuncInstantiation& instantiation =
							this->context.getSemaBuffer().getTemplateIntrinsicFuncInstantiation(target);

						const Context::TemplateIntrinsicFuncInfo& template_intrinsic_func_info = 
							this->context.getTemplateIntrinsicFuncInfo(instantiation.kind);

						auto instantiation_args = evo::SmallVector<std::optional<TypeInfo::VoidableID>>();
						instantiation_args.reserve(instantiation.templateArgs.size());
						using TemplateArg = evo::Variant<TypeInfo::VoidableID, core::GenericValue>;
						for(const TemplateArg& template_arg : instantiation.templateArgs){
							if(template_arg.is<TypeInfo::VoidableID>()){
								instantiation_args.emplace_back(template_arg.as<TypeInfo::VoidableID>());
							}else{
								instantiation_args.emplace_back();
							}
						}

						return &this->context.getTypeManager().getFunction(
							this->context.type_manager.getOrCreateFunction(
								template_intrinsic_func_info.getTypeInstantiation(instantiation_args)
							).funcID()
						);
						
					}else{
						static_assert(false, "Unsupported func call target");
					}
				});
			}
		}();

		
		if(
			attempt_func_type.errorTypes.size() != instr.except_params.size()
			&& attempt_func_type.errorTypes[0].isVoid() == false
		){
			this->emit_error(
				Diagnostic::Code::SEMA_TRY_EXCEPT_PARAMS_WRONG_NUM,
				instr.handler_kind_token_id,
				"Number of except parameters does not match attempt function call",
				Diagnostic::Info(
					std::format("Expected {}, got {}", attempt_func_type.errorTypes.size(), instr.except_params.size())
				)
			);
			return Result::ERROR;
		}

		auto except_params = evo::SmallVector<sema::Expr>();
		except_params.reserve(instr.except_params.size());
		for(size_t i = 0; i < instr.except_params.size(); i+=1){
			const Token& except_param_token = this->source.getTokenBuffer()[instr.except_params[i]];

			if(except_param_token.kind() == Token::lookupKind("_")){
				except_params.emplace_back(sema::Expr::createNone());
				continue;
			}

			const std::string_view except_param_ident_str = except_param_token.getString();

			const sema::ExceptParam::ID except_param_id = this->context.sema_buffer.createExceptParam(
				instr.except_params[i], uint32_t(i), attempt_func_type.errorTypes[i].asTypeID()
			);
			except_params.emplace_back(sema::Expr(except_param_id));

			if(this->add_ident_to_scope(
				except_param_ident_str, instr.except_params[i], true, except_param_id
			).isError()){
				return Result::ERROR;
			}

			this->add_ident_value_state(except_param_id, sema::ScopeLevel::ValueState::INIT);
		}

		this->return_term_info(instr.output_except_params,
			TermInfo::ValueCategory::EXCEPT_PARAM_PACK,
			this->get_current_func().attributes.isComptime
				? TermInfo::ValueStage::INTERPTIME
		: TermInfo::ValueStage::RUNTIME,
			TermInfo::ExceptParamPack{},
			std::move(except_params)
		);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_try_else_expr(const Instruction::TryElseExpr& instr) -> Result {
		const TermInfo& attempt_expr = this->get_term_info(instr.attempt_expr);
		TermInfo& except_expr = this->get_term_info(instr.except_expr);

		if(attempt_expr.value_category != TermInfo::ValueCategory::EPHEMERAL){
			this->emit_error(
				Diagnostic::Code::SEMA_TRY_ELSE_ATTEMPT_NOT_FUNC_CALL,
				instr.try_else.attemptExpr,
				"Attempt in try/else expression is not function call"
			);
			return Result::ERROR;
		}

		if(
			attempt_expr.getExpr().kind() != sema::Expr::Kind::FUNC_CALL
			&& attempt_expr.getExpr().kind() != sema::Expr::Kind::INTERFACE_CALL
		){
			this->emit_error(
				Diagnostic::Code::SEMA_TRY_ELSE_ATTEMPT_NOT_FUNC_CALL,
				instr.try_else.attemptExpr,
				"Attempt in try/else expression is not function call"
			);
			return Result::ERROR;
		}

		if(attempt_expr.isMultiValue()){
			this->emit_error(
				Diagnostic::Code::SEMA_TRY_ELSE_ATTEMPT_NOT_SINGLE,
				instr.try_else.attemptExpr,
				"Attempt function call in try/else expression returns multiple values"
			);
			return Result::ERROR;
		}

		if(except_expr.is_ephemeral() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_TRY_ELSE_EXCEPT_NOT_EPHEMERAL,
				instr.try_else.exceptExpr,
				"Except in try/else expression is not function call"
			);
			return Result::ERROR;
		}

		if(this->type_check<true, true>(
			attempt_expr.type_id.as<TypeInfo::ID>(),
			except_expr,
			"Except in try/else expression",
			instr.try_else.exceptExpr
		).ok == false){
			return Result::ERROR;
		}

		const TermInfo& except_params_term_info = this->get_term_info(instr.except_params);
		auto except_params = evo::SmallVector<sema::ExceptParam::ID>();
		except_params.reserve(except_params_term_info.getExceptParamPack().size());
		for(const sema::Expr& except_param : except_params_term_info.getExceptParamPack()){
			if(except_param.kind() == sema::Expr::Kind::EXCEPT_PARAM){
				except_params.emplace_back(except_param.exceptParamID());
			}
		}


		using ValueStage = TermInfo::ValueStage;
		const ValueStage value_stage = [&](){
			if(attempt_expr.value_stage == ValueStage::COMPTIME && except_expr.value_stage == ValueStage::COMPTIME){
				return TermInfo::ValueStage::COMPTIME;
			}

			if(attempt_expr.value_stage >= ValueStage::INTERPTIME && except_expr.value_stage >= ValueStage::INTERPTIME){
				return TermInfo::ValueStage::INTERPTIME;
			}

			return TermInfo::ValueStage::RUNTIME;
		}();


		if(this->pop_scope_level().isError()){ return Result::ERROR; }


		const sema::Expr try_else_expr = [&](){
			if(attempt_expr.getExpr().kind() == sema::Expr::Kind::FUNC_CALL){
				return sema::Expr(
					this->context.sema_buffer.createTryElseExpr(
						attempt_expr.getExpr(), except_expr.getExpr(), std::move(except_params)
					)
				);
			}else{
				return sema::Expr(
					this->context.sema_buffer.createTryElseInterfaceExpr(
						attempt_expr.getExpr(), except_expr.getExpr(), std::move(except_params)
					)
				);
			}
		}();

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			attempt_expr.type_id,
			try_else_expr
		);
		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_begin_expr_block(const Instruction::BeginExprBlock& instr) -> Result {
		const sema::BlockExpr::ID sema_block_expr_id = this->context.sema_buffer.createBlockExpr(instr.label);
		sema::BlockExpr& sema_block_expr = this->context.sema_buffer.block_exprs[sema_block_expr_id];

		///////////////////////////////////
		// check for label reuse

		const std::string_view label_str = this->source.getTokenBuffer()[instr.label].getString();
		for(size_t i = this->scope.size() - 1; const sema::ScopeLevel::ID& target_scope_level_id : this->scope){
			EVO_DEFER([&](){ i -= 1; });

			if(i == this->scope.getCurrentEncapsulatingSymbolIndex()){ break; }

			const sema::ScopeLevel& target_scope_level = 
				this->context.sema_buffer.scope_manager.getLevel(target_scope_level_id);

			if(target_scope_level.hasLabel() == false){ continue; }

			if(label_str == this->source.getTokenBuffer()[target_scope_level.getLabel()].getString()){
				this->emit_error(
					Diagnostic::Code::SEMA_IDENT_ALREADY_IN_SCOPE,
					instr.label,
					std::format("Label \"{}\" was already defined in this scope", label_str),
					Diagnostic::Info("First defined here:", this->get_location(target_scope_level.getLabel()))
				);
				return Result::ERROR;
			}
		}


		///////////////////////////////////
		// build outputs

		this->push_scope_level(sema_block_expr.block, instr.label, sema_block_expr_id);

		sema_block_expr.outputs.reserve(instr.output_types.size());
		for(size_t i = 0; const SymbolProc::TypeID& output_type_id : instr.output_types){
			const TypeInfo::VoidableID output_type = this->get_type(output_type_id);

			if(output_type.isVoid()){
				this->emit_error(
					Diagnostic::Code::SEMA_BLOCK_EXPR_OUTPUT_PARAM_VOID,
					instr.block.outputs[i].typeID,
					"Block expression output cannot be type `Void`"
				);
				return Result::ERROR;
			}

			sema_block_expr.outputs.emplace_back(output_type.asTypeID(), instr.block.outputs[i].ident);

			if(instr.block.outputs[i].ident.has_value()){
				const Token::ID ident_token_id = *instr.block.outputs[i].ident;

				const std::string_view ident_str = this->source.getTokenBuffer()[ident_token_id].getString();

				const sema::BlockExprOutput::ID block_expr_output = this->context.sema_buffer.createBlockExprOutput(
					uint32_t(i), instr.label, ident_token_id, output_type.asTypeID()
				);

				if(this->add_ident_to_scope(
					ident_str, *instr.block.outputs[i].ident, true, block_expr_output
				).isError()){
					return Result::ERROR;
				}

				this->add_ident_value_state(
					block_expr_output, sema::ScopeLevel::ValueState::UNINIT
				);
			}

			i += 1;
		}

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_end_expr_block(const Instruction::EndExprBlock& instr) -> Result {
		if(this->get_current_scope_level().isTerminated() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_BLOCK_EXPR_NOT_TERMINATED, instr.block, "Block expression not terminated"
			);
			return Result::ERROR;
		}

		const sema::BlockExpr::ID sema_block_expr_id =
			this->get_current_scope_level().getLabelNode().as<sema::BlockExpr::ID>();
		const sema::BlockExpr& sema_block_expr = this->context.sema_buffer.getBlockExpr(sema_block_expr_id);

		if(sema_block_expr.outputs.size() == 1){
			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				this->get_current_func().attributes.isComptime
					? TermInfo::ValueStage::INTERPTIME
					: TermInfo::ValueStage::RUNTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				sema_block_expr.outputs[0].typeID,
				sema::Expr(sema_block_expr_id)
			);
		}else{
			auto types = evo::SmallVector<TypeInfo::ID>();
			types.reserve(sema_block_expr.outputs.size());
			for(const sema::BlockExpr::Output& output : sema_block_expr.outputs){
				types.emplace_back(output.typeID);
			}

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				this->get_current_func().attributes.isComptime
					? TermInfo::ValueStage::INTERPTIME
					: TermInfo::ValueStage::RUNTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				std::move(types),
				sema::Expr(sema_block_expr_id)
			);
		}


		if(this->pop_scope_level<PopScopeLevelKind::LABEL_TERMINATE>().isError()){ return Result::ERROR; }
		if(this->end_sub_scopes(this->get_location(instr.block.closeBrace)).isError()){ return Result::ERROR; }
		return Result::SUCCESS;
	}



	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::instr_indexer(const Instruction::Indexer<IS_COMPTIME>& instr) -> Result {
		TermInfo& target = this->get_term_info(instr.target);

		if(target.type_id.is<TypeInfo::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
				instr.indexer.target,
				"Invalid target for indexer"
			);
			return Result::ERROR;
		}

		if(
			target.value_state != TermInfo::ValueState::INIT
			&& target.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.indexer.target,
				"Indexer target must be initialized"
			);
			return Result::ERROR;
		}

		const TypeInfo& decayed_target_type = this->context.getTypeManager().getTypeInfo(
			this->context.type_manager.decayType<true, true>(target.type_id.as<TypeInfo::ID>())
		);



		bool is_arr_ref = false;
		bool is_mut_arr_ref = false;
		bool is_ptr = false;

		auto elem_type = std::optional<TypeInfo::ID>();

		const TypeInfo* element_type = nullptr;


		switch(decayed_target_type.baseTypeID().kind()){
			case BaseType::Kind::ARRAY: {
				if(decayed_target_type.qualifiers().empty() == false){
					if(decayed_target_type.qualifiers().size() == 1 && decayed_target_type.isPointer()){
						is_ptr = true;
					}else{
						if(decayed_target_type.isOptional()){
							this->emit_error(
								Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
								instr.indexer,
								"Invalid target for indexer",
								Diagnostic::Info("Optional values need to be unwrapped")
							);
						}else{
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(
								target.type_id.as<TypeInfo::ID>(), infos, "Type of indexer: "
							);
							this->emit_error(
								Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
								instr.indexer,
								"Invalid target for indexer",
								std::move(infos)
							);
						}
						return Result::ERROR;
					}
				}

				const BaseType::Array& target_array_type =
					this->context.getTypeManager().getArray(decayed_target_type.baseTypeID().arrayID());

				if(target_array_type.dimensions.size() != instr.indices.size()){
					this->emit_error(
						Diagnostic::Code::SEMA_INDEXER_INCORRECT_NUM_INDICES,
						instr.indexer.indices[std::min(instr.indices.size() - 1, target_array_type.dimensions.size())],
						"Incorrect number of indices in indexer for the target array type",
						evo::SmallVector<Diagnostic::Info>{
							Diagnostic::Info(std::format("Expected: {}", target_array_type.dimensions.size())),
							Diagnostic::Info(std::format("Got:      {}", instr.indices.size())),
						}
					);
					return Result::ERROR;
				}

				element_type = &this->context.type_manager.getTypeInfo(target_array_type.elementTypeID);
			} break;

			case BaseType::Kind::ARRAY_REF: {
				is_arr_ref = true;

				if(decayed_target_type.qualifiers().empty() == false){
					if(decayed_target_type.qualifiers().size() == 1 && decayed_target_type.isPointer()){
						is_ptr = true;
					}else{
						if(decayed_target_type.isOptional()){
							this->emit_error(
								Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
								instr.indexer,
								"Invalid target for indexer",
								Diagnostic::Info("Optional values need to be unwrapped")
							);
						}else{
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(
								target.type_id.as<TypeInfo::ID>(), infos, "Type of indexer: "
							);
							this->emit_error(
								Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
								instr.indexer,
								"Invalid target for indexer",
								std::move(infos)
							);
						}
						return Result::ERROR;
					}
				}

				const BaseType::ArrayRef& target_array_ref_type =
					this->context.getTypeManager().getArrayRef(decayed_target_type.baseTypeID().arrayRefID());

				is_mut_arr_ref = target_array_ref_type.isMut;

				if(target_array_ref_type.dimensions.size() != instr.indices.size()){
					this->emit_error(
						Diagnostic::Code::SEMA_INDEXER_INCORRECT_NUM_INDICES,
						instr.indexer.indices[
							std::min(instr.indices.size() - 1, target_array_ref_type.dimensions.size())
						],
						"Incorrect number of indices in indexer for the target array reference type",
						evo::SmallVector<Diagnostic::Info>{
							Diagnostic::Info(std::format("Expected: {}", target_array_ref_type.dimensions.size())),
							Diagnostic::Info(std::format("Got:      {}", instr.indices.size())),
						}
					);
					return Result::ERROR;
				}

				element_type = &this->context.type_manager.getTypeInfo(target_array_ref_type.elementTypeID);
			} break;

			case BaseType::Kind::STRUCT: {
				const BaseType::Struct& target_struct_type = 
					this->context.getTypeManager().getStruct(decayed_target_type.baseTypeID().structID());

				if(decayed_target_type.qualifiers().empty() == false){
					if(decayed_target_type.qualifiers().size() == 1 && decayed_target_type.isPointer()){
						is_ptr = true;
					}else{
						if(decayed_target_type.isOptional()){
							this->emit_error(
								Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
								instr.indexer,
								"Invalid target for indexer",
								Diagnostic::Info("Optional values need to be unwrapped")
							);
						}else{
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(
								target.type_id.as<TypeInfo::ID>(), infos, "Type of indexer: "
							);
							this->emit_error(
								Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
								instr.indexer,
								"Invalid target for indexer",
								std::move(infos)
							);
						}
						return Result::ERROR;
					}
				}

				if(target_struct_type.indexerOverloads.empty()){
					this->emit_error(
						Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
						instr.indexer,
						"Invalid target for indexer",
						Diagnostic::Info("This struct type has no indexer overload")
					);
					return Result::ERROR;
				}

				auto func_infos = evo::SmallVector<SelectFuncOverloadFuncInfo, 4>();
				func_infos.reserve(target_struct_type.indexerOverloads.size());
				for(const sema::Func::ID indexer_overload_id : target_struct_type.indexerOverloads){
					const sema::Func& indexer_overload = this->context.getSemaBuffer().getFunc(indexer_overload_id);
					const BaseType::Function& indexer_overload_type =
						this->context.getTypeManager().getFunction(indexer_overload.typeID);

					func_infos.emplace_back(indexer_overload_id, indexer_overload_type);
				}

				auto arg_infos = evo::SmallVector<SelectFuncOverloadArgInfo, 4>();
				arg_infos.reserve(instr.indices.size());
				if(is_ptr){
					const TypeInfo::ID target_deref_type_id = this->context.type_manager.getOrCreateTypeInfo(
						decayed_target_type.copyWithPoppedQualifier()
					);

					target.value_category = decayed_target_type.qualifiers().back().isMut
						? TermInfo::ValueCategory::CONCRETE_MUT
						: TermInfo::ValueCategory::CONCRETE_CONST;

					target.type_id = target_deref_type_id;

					target.getExpr() = sema::Expr(
						this->context.sema_buffer.createDeref(target.getExpr(), target_deref_type_id)
					);
				}
				arg_infos.emplace_back(target, instr.indexer.target, std::nullopt);
				for(size_t i = 0; const SymbolProc::TermInfoID index_id : instr.indices){
					TermInfo& index = this->get_term_info(index_id);
					
					arg_infos.emplace_back(index, instr.indexer.indices[i], std::nullopt);

					i += 1;
				}

				const evo::Result<size_t> selected_overload_index = this->select_func_overload(
					func_infos, arg_infos, instr.indexer, true, evo::SmallVector<Diagnostic::Info>{}
				);
				if(selected_overload_index.isError()){ return Result::ERROR; }

				const SelectFuncOverloadFuncInfo& selected_overload_info = func_infos[selected_overload_index.value()];
				const sema::Func::ID selected_overload_id = selected_overload_info.func_id.as<sema::Func::ID>();


				if(this->get_current_func().attributes.isComptime){
					const sema::Func& selected_overload = this->context.getSemaBuffer().getFunc(selected_overload_id);

					if(selected_overload.attributes.isComptime == false){
						this->emit_error(
							Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
							instr.indexer,
							"Cannot call a non-comptime operator overload within a comptime function",
							Diagnostic::Info(
								"Called operator overload was defined here:", this->get_location(selected_overload_id)
							)
						);
						return Result::ERROR;
					}

					this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>()
						.dependent_funcs.emplace(selected_overload_id);
				}


				auto sema_args = evo::SmallVector<sema::Expr>();
				sema_args.reserve(arg_infos.size());
				for(const SelectFuncOverloadArgInfo& arg_info : arg_infos){
					sema_args.emplace_back(arg_info.term_info.getExpr());
				}

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					target.value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					selected_overload_info.func_type.returnTypes[0].asTypeID(),
					sema::Expr(
						this->context.sema_buffer.createFuncCall(
							selected_overload_info.func_id.as<sema::Func::ID>(), std::move(sema_args)
						)
					)
				);
				return Result::SUCCESS;
			} break;

			default: {
				this->emit_error(
					Diagnostic::Code::SEMA_INDEXER_INVALID_TARGET,
					instr.indexer,
					"Invalid target for indexer"
				);
				return Result::ERROR;
			} break;
		}


		auto indices = evo::SmallVector<sema::Expr>();
		indices.reserve(instr.indices.size());
		for(size_t i = 0; const SymbolProc::TermInfoID index_id : instr.indices){
			TermInfo& index = this->get_term_info(index_id);

			if(this->type_check<true, true>(
				TypeManager::getTypeUSize(), index, "Index in indexer", instr.indexer.indices[i]
			).ok == false){
				return Result::ERROR;
			}

			indices.emplace_back(index.getExpr());

			i += 1;
		}


		auto resultant_qualifiers = evo::SmallVector<TypeInfo::Qualifier>();
		resultant_qualifiers.reserve(element_type->qualifiers().size() + 1);
		for(const TypeInfo::Qualifier& qualifier : element_type->qualifiers()){
			resultant_qualifiers.emplace_back(qualifier);
		}
		resultant_qualifiers.emplace_back(
			true,
			target.is_mutable() || (is_ptr && decayed_target_type.qualifiers().back().isMut) || is_mut_arr_ref,
			false,
			false
		);

		const TypeInfo::ID resultant_type_id = this->context.type_manager.getOrCreateTypeInfo(
			TypeInfo(element_type->baseTypeID(), std::move(resultant_qualifiers))
		);

		const sema::Expr sema_indexer_expr = [&](){
			const sema::Expr target_expr = [&]() -> sema::Expr {
				if(is_ptr){
					const TypeInfo::ID derefed_type_id = this->context.type_manager.getOrCreateTypeInfo(
						decayed_target_type.copyWithPoppedQualifier()
					);

					return sema::Expr(this->context.sema_buffer.createDeref(target.getExpr(), derefed_type_id));

				}else{
					return target.getExpr();
				}
			}();

			if(is_arr_ref){
				return sema::Expr(this->context.sema_buffer.createArrayRefIndexer(
					target_expr, decayed_target_type.baseTypeID().arrayRefID(), std::move(indices)
				));

			}else if(is_ptr){
				const TypeInfo::ID derefed_type_id = this->context.type_manager.getOrCreateTypeInfo(
					this->context.getTypeManager()
						.getTypeInfo(target.type_id.as<TypeInfo::ID>()).copyWithPoppedQualifier()
				);

				return sema::Expr(this->context.sema_buffer.createIndexer(
					target_expr, derefed_type_id, std::move(indices)
				));

			}else{
				return sema::Expr(this->context.sema_buffer.createIndexer(
					target_expr, target.type_id.as<TypeInfo::ID>(), std::move(indices)
				));
			}
		}();


		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			target.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			resultant_type_id,
			sema_indexer_expr
		);
		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_templated_term(const Instruction::TemplatedTerm& instr) -> Result {
		const TermInfo& templated_type_term_info = this->get_term_info(instr.base);

		if(
			templated_type_term_info.value_category != TermInfo::ValueCategory::TEMPLATE_TYPE
			&& templated_type_term_info.value_category != TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED
		){
			this->emit_error(
				Diagnostic::Code::SEMA_NOT_TEMPLATED_TYPE_WITH_TEMPLATE_ARGS,
				instr.templated_expr.base,
				"Base of templated type is not a template"
			);
			return Result::ERROR;
		}

		const sema::TemplatedStruct& sema_templated_struct = [&]() -> const sema::TemplatedStruct& {
			if(templated_type_term_info.type_id.is<sema::StructTemplateAlias::ID>()){
				const sema::StructTemplateAlias* target_alias =
					&this->context.getSemaBuffer().getStructTemplateAlias(
						templated_type_term_info.type_id.as<sema::StructTemplateAlias::ID>()
					);

				while(target_alias->aliasedID.is<sema::StructTemplateAlias::ID>()){
					target_alias = &this->context.getSemaBuffer().getStructTemplateAlias(
						target_alias->aliasedID.as<sema::StructTemplateAlias::ID>()
					);
				}

				return this->context.getSemaBuffer().getTemplatedStruct(
					target_alias->aliasedID.as<sema::TemplatedStruct::ID>()
				);

			}else{
				return this->context.getSemaBuffer().getTemplatedStruct(
					templated_type_term_info.type_id.as<sema::TemplatedStruct::ID>()
				);
			}
		}();

		Source& instantiation_source = this->context.source_manager[sema_templated_struct.symbolProc.source_id];

		BaseType::StructTemplate& struct_template = 
			this->context.type_manager.getStructTemplate(sema_templated_struct.templateID);


		///////////////////////////////////
		// check args

		if(instr.arguments.size() < struct_template.minNumTemplateArgs){
			auto infos = evo::SmallVector<Diagnostic::Info>();

			if(struct_template.hasAnyDefaultParams()){
				infos.emplace_back(
					std::format(
						"This type requires at least {}, got {}",
						struct_template.minNumTemplateArgs, instr.arguments.size()
					)
				);
			}else{
				infos.emplace_back(
					std::format(
						"This type requires {}, got {}", struct_template.minNumTemplateArgs, instr.arguments.size()
					)
				);
			}

			this->emit_error(
				Diagnostic::Code::SEMA_TEMPLATE_TOO_FEW_ARGS,
				instr.templated_expr,
				"Too few template arguments for this type",
				std::move(infos)
			);
			return Result::ERROR;
		}


		if(instr.arguments.size() > struct_template.params.size()){
			auto infos = evo::SmallVector<Diagnostic::Info>();

			if(struct_template.hasAnyDefaultParams()){
				infos.emplace_back(
					std::format(
						"This type requires at most {}, got {}",
						struct_template.params.size(), instr.arguments.size()
					)
				);
			}else{
				infos.emplace_back(
					std::format(
						"This type requires {}, got {}", struct_template.params.size(), instr.arguments.size()
					)
				);
			}

			this->emit_error(
				Diagnostic::Code::SEMA_TEMPLATE_TOO_MANY_ARGS,
				instr.templated_expr,
				"Too many template arguments for this type",
				std::move(infos)
			);
			return Result::ERROR;
		}


		///////////////////////////////////
		// get instantiation args

		bool is_deducer = false;


		this->scope.pushTemplateDeclInstantiationTypesScope();
		EVO_DEFER([&](){ this->scope.popTemplateDeclInstantiationTypesScope(); });

		auto instantiation_lookup_args = evo::SmallVector<BaseType::StructTemplate::Arg>();
		instantiation_lookup_args.reserve(instr.arguments.size());

		auto instantiation_args = evo::SmallVector<evo::Variant<TypeInfo::VoidableID, sema::Expr>>();
		instantiation_args.reserve(instr.arguments.size());
		for(size_t i = 0; const evo::Variant<SymbolProc::TermInfoID, SymbolProc::TypeID>& arg : instr.arguments){
			EVO_DEFER([&](){ i += 1; });

			if(arg.is<SymbolProc::TermInfoID>()){
				TermInfo& arg_term_info = this->get_term_info(arg.as<SymbolProc::TermInfoID>());

				if(arg_term_info.isMultiValue()){
					this->emit_error(
						Diagnostic::Code::SEMA_MULTI_RETURN_INTO_SINGLE_VALUE,
						instr.templated_expr.args[i],
						"Template argument cannot be multiple values"
					);
					return Result::ERROR;
				}

				if(arg_term_info.value_category == TermInfo::ValueCategory::TYPE){
					const TypeInfo::VoidableID arg_type_voidable_id = arg_term_info.type_id.as<TypeInfo::VoidableID>();

					if(this->context.getTypeManager().isTypeDeducer(arg_type_voidable_id)){
						instantiation_lookup_args.emplace_back(arg_type_voidable_id);
						is_deducer = true;
						continue;
					}


					if(struct_template.params[i].isExpr()){
						const ASTBuffer& ast_buffer = this->source.getASTBuffer();
						const AST::StructDef& ast_struct =
							ast_buffer.getStructDef(sema_templated_struct.symbolProc.ast_node);
						const AST::TemplatePack& ast_template_pack =
							ast_buffer.getTemplatePack(*ast_struct.templatePack);

						this->emit_error(
							Diagnostic::Code::SEMA_TEMPLATE_INVALID_ARG,
							instr.templated_expr.args[i],
							"Expected an expression template argument, got a type",
							Diagnostic::Info(
								"Parameter declared here:", this->get_location(ast_template_pack.params[i].ident)
							)
						);
						return Result::ERROR;
					}

					const TypeInfo::VoidableID decayed_arg_type_id =
						this->context.type_manager.decayVoidableType<false, true>(arg_type_voidable_id);

					instantiation_lookup_args.emplace_back(decayed_arg_type_id);
					instantiation_args.emplace_back(decayed_arg_type_id);
					continue;
				}

				if(struct_template.params[i].isType()){
					const ASTBuffer& ast_buffer = this->source.getASTBuffer();
					const AST::StructDef& ast_struct =
						ast_buffer.getStructDef(sema_templated_struct.symbolProc.ast_node);
					const AST::TemplatePack& ast_template_pack = ast_buffer.getTemplatePack(*ast_struct.templatePack);

					if(
						arg_term_info.value_category == TermInfo::ValueCategory::TEMPLATE_TYPE
						|| arg_term_info.value_category == TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED
					){
						this->emit_error(
							Diagnostic::Code::SEMA_TEMPLATE_TYPE_NOT_INSTANTIATED,
							instr.templated_expr.args[i],
							"Templated type needs to be instantiated",
							Diagnostic::Info(
								"Type declared here:",
								this->get_location(arg_term_info.type_id.as<sema::TemplatedStruct::ID>())
							)
						);
					}else{
						this->emit_error(
							Diagnostic::Code::SEMA_TEMPLATE_INVALID_ARG,
							instr.templated_expr.args[i],
							"Expected a type template argument, got an expression",
							Diagnostic::Info(
								"Parameter declared here:", this->get_location(ast_template_pack.params[i].ident)
							)
						);
					}

					return Result::ERROR;
				}



				const evo::Result<TypeInfo::ID> expr_type_id = [&]() -> evo::Result<TypeInfo::ID> {
					if(struct_template.params[i].typeID->isTemplateDeclInstantiation()){
						const AST::StructDef& ast_struct =
							this->source.getASTBuffer().getStructDef(sema_templated_struct.symbolProc.ast_node);
						const AST::TemplatePack& ast_template_pack = 
							this->source.getASTBuffer().getTemplatePack(*ast_struct.templatePack);

						const evo::Result<TypeInfo::VoidableID> resolved_type = this->resolve_type(
							this->source.getASTBuffer().getType(ast_template_pack.params[i].type)
						);
						if(resolved_type.isError()){ return evo::resultError; }

						if(resolved_type.value().isVoid()){
							this->emit_error(
								Diagnostic::Code::SEMA_TEMPLATE_PARAM_CANNOT_BE_TYPE_VOID,
								ast_template_pack.params[i].type,
								"Template expression parameter cannot be type `Void`"
							);
							return evo::resultError;
						}

						return resolved_type.value().asTypeID();
					}else{
						return *struct_template.params[i].typeID;
					}
				}();
				if(expr_type_id.isError()){ return Result::ERROR; }
				
			
				if(this->type_check<true, true>(
					expr_type_id.value(), arg_term_info, "Template argument", instr.templated_expr.args[i]
				).ok == false){
					return Result::ERROR;
				}

				const sema::Expr& arg_expr = arg_term_info.getExpr();
				instantiation_args.emplace_back(arg_expr);
				instantiation_lookup_args.emplace_back(this->sema_expr_to_generic_value(arg_expr));
				
			}else{
				const ASTBuffer& ast_buffer = instantiation_source.getASTBuffer();
				const AST::StructDef& ast_struct = ast_buffer.getStructDef(sema_templated_struct.symbolProc.ast_node);
				const AST::TemplatePack& ast_template_pack = ast_buffer.getTemplatePack(*ast_struct.templatePack);

				const TypeInfo::VoidableID type_id = this->get_type(arg.as<SymbolProc::TypeID>());

				if(this->context.getTypeManager().isTypeDeducer(type_id)){
					instantiation_lookup_args.emplace_back(type_id);
					is_deducer = true;
					continue;
				}

				if(struct_template.params[i].isExpr()){
					this->emit_error(
						Diagnostic::Code::SEMA_TEMPLATE_INVALID_ARG,
						instr.templated_expr.args[i],
						"Expected an expression template argument, got a type",
						Diagnostic::Info(
							"Parameter declared here:",
							Diagnostic::Location::get(ast_template_pack.params[i].ident, instantiation_source)
						)
					);
					return Result::ERROR;
				}


				const TypeInfo::VoidableID decayed_type_id =
					this->context.type_manager.decayVoidableType<false, true>(type_id);

				instantiation_lookup_args.emplace_back(decayed_type_id);
				instantiation_args.emplace_back(decayed_type_id);

				this->scope.addTemplateDeclInstantiationType(
					instantiation_source.getTokenBuffer()[ast_template_pack.params[i].ident].getString(),
					decayed_type_id
				);
			}
		}


		// default values
		for(size_t i = instr.arguments.size(); i < struct_template.params.size(); i+=1){
			struct_template.params[i].defaultValue.visit([&](const auto& default_value) -> void {
				using DefaultValue = std::decay_t<decltype(default_value)>;

				if constexpr(std::is_same<DefaultValue, std::monostate>()){
					evo::debugFatalBreak("Expected template default value, found none");

				}else if constexpr(std::is_same<DefaultValue, sema::Expr>()){
					instantiation_lookup_args.emplace_back(this->sema_expr_to_generic_value(default_value));
					instantiation_args.emplace_back(default_value);

				}else if constexpr(std::is_same<DefaultValue, TypeInfo::VoidableID>()){
					instantiation_lookup_args.emplace_back(default_value);
					instantiation_args.emplace_back(default_value);

				}else{
					static_assert(false, "Unsupported template default value type");
				}
			});
		}



		///////////////////////////////////
		// lookup / create instantiation

		if(is_deducer){
			const BaseType::ID created_struct_template_deducer = this->context.type_manager.createStructTemplateDeducer(
				BaseType::StructTemplateDeducer(
					this->source.getID(), sema_templated_struct.templateID, std::move(instantiation_lookup_args)
				)
			);

			this->return_struct_instantiation(
				instr.instantiation, created_struct_template_deducer.structTemplateDeducerID()
			);
			return Result::SUCCESS;
		}


		const BaseType::StructTemplate::InstantiationInfo instantiation_info =
			struct_template.createOrLookupInstantiation(std::move(instantiation_lookup_args));

		if(instantiation_info.needsToBeCompiled()){
			auto symbol_proc_builder = SymbolProcBuilder(this->context, instantiation_source);

			const sema::ScopeManager::Scope::ID instantiation_sema_scope_id = 
				this->context.sema_buffer.scope_manager.copyScope(*sema_templated_struct.symbolProc.sema_scope_id);


			///////////////////////////////////
			// build instantiation

			auto instantiation_locations =
				evo::SmallVector<Diagnostic::Location>(this->symbol_proc.instantiation_locations);
			instantiation_locations.emplace_back(this->get_location(instr.templated_expr));

			const evo::Result<SymbolProc::ID> instantiation_symbol_proc_id = symbol_proc_builder.buildTemplateInstance(
				sema_templated_struct.symbolProc,
				instantiation_info.instantiation,
				instantiation_sema_scope_id,
				sema_templated_struct.templateID,
				*instantiation_info.instantiationID,
				std::move(instantiation_locations)
			);
			if(instantiation_symbol_proc_id.isError()){ return Result::ERROR; }

			instantiation_info.instantiation.symbolProcID = instantiation_symbol_proc_id.value();


			///////////////////////////////////
			// add instantiation args to scope

			sema::ScopeManager::Scope& instantiation_sema_scope =
				this->context.sema_buffer.scope_manager.getScope(instantiation_sema_scope_id);

			instantiation_sema_scope.pushLevel(this->context.sema_buffer.scope_manager.createLevel());

			const AST::StructDef& struct_template_decl = 
				instantiation_source.getASTBuffer().getStructDef(sema_templated_struct.symbolProc.ast_node);

			const AST::TemplatePack& ast_template_pack = instantiation_source.getASTBuffer().getTemplatePack(
				*struct_template_decl.templatePack
			);

			for(size_t i = 0; const evo::Variant<TypeInfo::VoidableID, sema::Expr>& arg : instantiation_args){
				EVO_DEFER([&](){ i += 1; });

				const evo::Result<> add_ident_result = [&](){
					if(arg.is<TypeInfo::VoidableID>()){
						return this->add_ident_to_scope(
							instantiation_sema_scope,
							instantiation_source.getTokenBuffer()[ast_template_pack.params[i].ident].getString(),
							ast_template_pack.params[i].ident,
							true,
							sema::ScopeLevel::TemplateTypeParamFlag{},
							arg.as<TypeInfo::VoidableID>(),
							ast_template_pack.params[i].ident
						);

					}else{
						const TypeInfo::ID expr_type_id = [&]() -> TypeInfo::ID {
							if(struct_template.params[i].typeID->isTemplateDeclInstantiation()){
								const AST::StructDef& ast_struct = instantiation_source.getASTBuffer().getStructDef(
									sema_templated_struct.symbolProc.ast_node
								);
								const AST::TemplatePack& ast_template_pack = 
									instantiation_source.getASTBuffer().getTemplatePack(*ast_struct.templatePack);

								const evo::Result<TypeInfo::VoidableID> resolved_type = this->resolve_type(
									instantiation_source.getASTBuffer().getType(ast_template_pack.params[i].type)
								);

								evo::debugAssert(
									resolved_type.isError() == false, "Should have already checked not an error"
								);

								evo::debugAssert(
									resolved_type.value().isVoid() == false, "Should have already checked not Void"
								);

								return resolved_type.value().asTypeID();
							}else{
								return *struct_template.params[i].typeID;
							}
						}();

						return this->add_ident_to_scope(
							instantiation_sema_scope,
							instantiation_source.getTokenBuffer()[ast_template_pack.params[i].ident].getString(),
							ast_template_pack.params[i].ident,
							true,
							sema::ScopeLevel::TemplateExprParamFlag{},
							expr_type_id,
							arg.as<sema::Expr>(),
							ast_template_pack.params[i].ident	
						);
					}
				}();

				if(add_ident_result.isError()){ return Result::ERROR; }
			}


			///////////////////////////////////
			// wait on instantiation
			
			SymbolProc& instantiation_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(
				instantiation_symbol_proc_id.value()
			);
			SymbolProc::WaitOnResult wait_on_result = instantiation_symbol_proc.waitOnDeclIfNeeded(
				this->symbol_proc_id, this->context, instantiation_symbol_proc_id.value()
			);
			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:
					evo::debugFatalBreak("Should never be possible");

				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(instantiation_symbol_proc_id.value());
					[[fallthrough]];
				}

				case SymbolProc::WaitOnResult::WAITING:
					break;

				case SymbolProc::WaitOnResult::WAS_ERRORED:
					evo::debugFatalBreak("Should never be possible");

				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:
					evo::debugFatalBreak("Should never be possible");

				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:
					return Result::ERROR; // not sure this is possible just in case
			}

			this->return_struct_instantiation(
				instr.instantiation,
				instantiation_info.instantiation,
				templated_type_term_info.value_category == TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED
			);


			instantiation_symbol_proc.setStatusInQueue();
			this->context.add_task_to_work_manager(instantiation_symbol_proc_id.value());

			return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;

		}else{
			this->return_struct_instantiation(
				instr.instantiation,
				instantiation_info.instantiation,
				templated_type_term_info.value_category == TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED
			);

			// TODO(FUTURE): better way of doing this?
			while(instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed).has_value() == false){
				std::this_thread::yield();
			}

			SymbolProc& instantiation_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(
				*instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed)
			);

			SymbolProc::WaitOnResult wait_on_result = instantiation_symbol_proc.waitOnDeclIfNeeded(
				this->symbol_proc_id,
				this->context,
				*instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed)
			);
			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:
					return Result::SUCCESS;

				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(
						*instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed)
					);
					[[fallthrough]];
				}
				
				case SymbolProc::WaitOnResult::WAITING:
					return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
				
				case SymbolProc::WaitOnResult::WAS_ERRORED:
					return Result::ERROR;
				
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:
					evo::debugFatalBreak("Should never be possible");
				
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:
					return Result::ERROR; // not sure this is possible but just in case
			}

			evo::unreachable();
		}
	}


	template<bool WAIT_FOR_DEF>
	auto SemanticAnalyzer::instr_templated_term_wait(const Instruction::TemplatedTermWait<WAIT_FOR_DEF>& instr)
	-> Result {
		const SymbolProc::StructInstantiationInfo instantiation = this->get_struct_instantiation(instr.instantiation);

		if(instantiation.id.is<const BaseType::StructTemplate::Instantiation*>()){
			const BaseType::StructTemplate::Instantiation& actual_instantiation = 
				*instantiation.id.as<const BaseType::StructTemplate::Instantiation*>();

			if(actual_instantiation.errored.load(std::memory_order::relaxed)){ return Result::ERROR; }
			evo::debugAssert(actual_instantiation.structID.has_value(), "Should already be completed");

			if(instantiation.requires_pub){
				const BaseType::Struct& instantiated_struct =
					this->context.getTypeManager().getStruct(*actual_instantiation.structID);

				if(instantiated_struct.isPub == false){
					this->emit_error(
						Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
						instr.templated_expr.base,
						"This struct template instantiation does not have the #pub attribute",
						Diagnostic::Info(
							"Struct template defined here:", this->get_location(*actual_instantiation.structID)
						)
					);
					return Result::ERROR;
				}
			}

			const TypeInfo::ID target_type_id = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(BaseType::ID(*actual_instantiation.structID))
			);

			if constexpr(WAIT_FOR_DEF){
				const SymbolProc::ID target_symbol_proc_id =
					*this->context.symbol_proc_manager.getTypeSymbolProc(target_type_id);

				const SymbolProc::WaitOnResult wait_on_result = this->context.symbol_proc_manager
					.getSymbolProc(target_symbol_proc_id)
					.waitOnDefIfNeeded(this->symbol_proc_id, this->context, target_symbol_proc_id);

				switch(wait_on_result){
					case SymbolProc::WaitOnResult::NOT_NEEDED:                 break;
					case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
						this->context.symbol_proc_manager.symbol_proc_unsuspended();
						this->context.add_task_to_work_manager(target_symbol_proc_id);
						[[fallthrough]];
					}
					case SymbolProc::WaitOnResult::WAITING:                    return Result::NEED_TO_WAIT;
					case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
					case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: evo::debugFatalBreak("Not possible");
					case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
				}
			}

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TYPE, TypeInfo::VoidableID(target_type_id)
			);

			return Result::SUCCESS;

		}else{
			evo::debugAssert(
				instantiation.id.is<BaseType::StructTemplateDeducer::ID>(), "Unknown struct instantiation kind"
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TYPE,
				TypeInfo::VoidableID(
					this->context.type_manager.getOrCreateTypeInfo(
						TypeInfo(BaseType::ID(instantiation.id.as<BaseType::StructTemplateDeducer::ID>()))
					)
				)
			);

			return Result::SUCCESS;
		}
	}


	auto SemanticAnalyzer::instr_push_template_decl_instantiation_types_scope() -> Result {
		this->scope.pushTemplateDeclInstantiationTypesScope();
		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_pop_template_decl_instantiation_types_scope() -> Result {
		this->scope.popTemplateDeclInstantiationTypesScope();
		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_add_template_decl_instantiation_type(
		const Instruction::AddTemplateDeclInstantiationType& instr
	) -> Result {
		this->scope.addTemplateDeclInstantiationType(instr.ident, std::nullopt);
		return Result::SUCCESS;
	}



	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::instr_expr_as(const Instruction::As<IS_COMPTIME>& instr) -> Result {
		TermInfo& expr = this->get_term_info(instr.expr);
		const TypeInfo::VoidableID target_type = this->get_type(instr.target_type);

		if(target_type.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_AS_TO_VOID,
				instr.infix.rhs,
				"Operator [as] cannot convert to type `Void`"
			);
			return Result::ERROR;
		}

		if(expr.value_category == TermInfo::ValueCategory::EPHEMERAL_FLUID){
			if(expr.getExpr().kind() == sema::Expr::Kind::INT_VALUE){
				if(this->context.getTypeManager().isIntegral(target_type.asTypeID())){ // int to int
					if(this->type_check<true, true>(
						target_type.asTypeID(), expr, "Operator [as]", instr.infix
					).ok == false){
						return Result::ERROR;
					}

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type.asTypeID(),
						expr.getExpr()
					);
					return Result::SUCCESS;

				}else{ // int to float
					const sema::IntValue& initial_val = 
						this->context.sema_buffer.getIntValue(expr.getExpr().intValueID());

					const sema::FloatValue::ID new_float_value = this->context.sema_buffer.createFloatValue(
						core::GenericFloat::createF128FromInt(initial_val.value, true),
						this->context.getTypeManager().getTypeInfo(target_type.asTypeID()).baseTypeID()
					);

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type.asTypeID(),
						sema::Expr(new_float_value)
					);
					return Result::SUCCESS;

				}

			}else{
				if(this->context.getTypeManager().isIntegral(target_type.asTypeID())){ // float to int
					const unsigned width = unsigned(this->context.getTypeManager().numBits(target_type.asTypeID()));
					const bool is_signed = this->context.getTypeManager().isSignedIntegral(target_type.asTypeID());

					const sema::FloatValue& initial_val = 
						this->context.sema_buffer.getFloatValue(expr.getExpr().floatValueID());

					const sema::IntValue::ID new_int_value = this->context.sema_buffer.createIntValue(
						initial_val.value.toGenericInt(width, is_signed),
						this->context.getTypeManager().getTypeInfo(target_type.asTypeID()).baseTypeID()
					);

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type.asTypeID(),
						sema::Expr(new_int_value)
					);

					return Result::SUCCESS;

				}else{ // float to float
					if(this->type_check<true, true>(
						target_type.asTypeID(), expr, "Operator [as]", instr.infix
					).ok == false){
						return Result::ERROR;
					}

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type.asTypeID(),
						expr.getExpr()
					);
					return Result::SUCCESS;
				}
			}
		}


		if(expr.value_state != TermInfo::ValueState::INIT && expr.value_state != TermInfo::ValueState::NOT_APPLICABLE){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			if(expr.value_state == TermInfo::ValueState::MOVED_FROM){
				infos.emplace_back("Argument was already moved from");
			}

			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"Argument for operator [as] must be initialized",
				std::move(infos)
			);
			return Result::ERROR;
		}



		{
			const std::optional<Result> as_interface_map_res = this->operator_as_check_interface_map(
				expr, expr.type_id.as<TypeInfo::ID>(), target_type.asTypeID(), instr.output, instr.infix
			);

			if(as_interface_map_res.has_value()){ return *as_interface_map_res; }
		}



		TypeManager& type_manager = this->context.type_manager;

		const TypeInfo::ID from_underlying_type_id = type_manager.getUnderlyingType(expr.type_id.as<TypeInfo::ID>());
		const TypeInfo& from_underlying_type = type_manager.getTypeInfo(from_underlying_type_id);

		const TypeInfo::ID to_underlying_type_id = type_manager.getUnderlyingType(target_type.asTypeID());
		const TypeInfo& to_underlying_type = type_manager.getTypeInfo(to_underlying_type_id);


		if(from_underlying_type.qualifiers().empty() == false){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
			this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
			this->emit_error(
				Diagnostic::Code::SEMA_AS_INVALID_FROM,
				instr.infix.lhs,
				"No valid operator [as] for this type",
				std::move(infos)
			);
			return Result::ERROR;
		}

		if(from_underlying_type.baseTypeID().kind() == BaseType::Kind::STRUCT){
			const BaseType::Struct& from_struct = this->context.getTypeManager().getStruct(
				from_underlying_type.baseTypeID().structID()
			);

			const auto find = from_struct.operatorAsOverloads.find(
				this->context.type_manager.decayType<false, false>(target_type.asTypeID())
			);

			if(find == from_struct.operatorAsOverloads.end()){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
				this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix.rhs,
					"No valid operator [as] to this type",
					std::move(infos)
				);
				return Result::ERROR;
			}

			const sema::Func::ID selected_func_id = find->second;

			const sema::Func& selected_func = this->context.getSemaBuffer().getFunc(selected_func_id);
			const BaseType::Function& selected_func_type =
				this->context.getTypeManager().getFunction(selected_func.typeID);

			switch(selected_func_type.params[0].kind){
				case BaseType::Function::Param::Kind::READ: {
					// no checking needed
				} break;

				case BaseType::Function::Param::Kind::MUT: {
					if(expr.is_mutable() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_AS_EXPR_DOESNT_SUPPORT_THIS_PARAM_KIND,
							instr.infix.lhs,
							"The selected operator [as] requires a mutable LHS as the [this] parameter kind is [mut]",
							Diagnostic::Info(
								"Selected operator [as] defined here:", this->get_location(selected_func_id)
							)
						);
						return Result::ERROR;
					}
				} break;

				case BaseType::Function::Param::Kind::IN: {
					if(expr.is_ephemeral() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_AS_EXPR_DOESNT_SUPPORT_THIS_PARAM_KIND,
							instr.infix.lhs,
							"The selected operator [as] requires an ephemeral LHS as the [this] parameter kind is [in]",
							Diagnostic::Info(
								"Selected operator [as] defined here:", this->get_location(selected_func_id)
							)
						);
						return Result::ERROR;
					}
				} break;

				case BaseType::Function::Param::Kind::C: {
					evo::debugFatalBreak("Shouldn't have a [this] param of kind C");
				} break;
			}



			if(this->currently_in_func()){
				if(this->get_current_func().attributes.isComptime){
					if(selected_func.attributes.isComptime == false){
						this->emit_error(
							Diagnostic::Code::SEMA_EXPR_NOT_COMPTIME,
							instr.infix,
							"Operator [as] in a comptime scope must be comptime"
						);
						return Result::ERROR;
					}

					this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(selected_func_id);
				}

			}else if(selected_func.attributes.isComptime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_EXPR_NOT_COMPTIME,
					instr.infix,
					"Operator [as] in a comptime scope must be comptime"
				);
				return Result::ERROR;
			}


			if(this->currently_in_unsafe() == false && selected_func_type.isUnsafe){
				this->emit_error(
					Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
					instr.infix,
					"Unsafe operator [as] while not in an unsafe scope"
				);
				return Result::ERROR;
			}


			const sema::FuncCall::ID conversion_call = this->context.sema_buffer.createFuncCall(
				selected_func_id, evo::SmallVector<sema::Expr>{expr.getExpr()}
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				expr.value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				target_type.asTypeID(),
				sema::Expr(conversion_call)
			);
			return Result::SUCCESS;
		}



		if(to_underlying_type.qualifiers().empty() == false){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
			this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
			this->emit_error(
				Diagnostic::Code::SEMA_AS_INVALID_TO,
				instr.infix.rhs,
				"No valid operator [as] to this type",
				std::move(infos)
			);
			return Result::ERROR;
		}

		if(to_underlying_type.baseTypeID().kind() == BaseType::Kind::ARRAY_REF){
			if(from_underlying_type.qualifiers().empty() == false || to_underlying_type.qualifiers().empty() == false){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
				this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix.rhs,
					"No valid operator [as] to this type",
					std::move(infos)
				);
				return Result::ERROR;
			}

			if(from_underlying_type.baseTypeID().kind() != BaseType::Kind::ARRAY){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
				this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix.rhs,
					"No valid operator [as] to this type",
					std::move(infos)
				);
				return Result::ERROR;
			}

			const BaseType::Array& from_array = 
				this->context.getTypeManager().getArray(from_underlying_type.baseTypeID().arrayID());

			const BaseType::ArrayRef& to_array_ref = 
				this->context.getTypeManager().getArrayRef(to_underlying_type.baseTypeID().arrayRefID());

			if(
				this->context.type_manager.decayType<false, false>(from_array.elementTypeID)
				!= this->context.type_manager.decayType<false, false>(to_array_ref.elementTypeID)
			){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
				this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix.rhs,
					"No valid operator [as] to this type",
					std::move(infos)
				);
				return Result::ERROR;
			}


			if(from_array.dimensions.size() != to_array_ref.dimensions.size()){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
				this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix.rhs,
					"No valid operator [as] to this type",
					std::move(infos)
				);
				return Result::ERROR;
			}


			if(to_array_ref.terminator.has_value() && from_array.terminator != to_array_ref.terminator){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
				this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix.rhs,
					"No valid operator [as] to this type",
					std::move(infos)
				);
				return Result::ERROR;
			}


			if(to_array_ref.isMut && expr.is_const()){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
				this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
				infos.emplace_back("Did you mean to make the target array reference read only?");
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix.rhs,
					"No valid operator [as] to this type",
					std::move(infos)
				);
				return Result::ERROR;
			}


			auto dimensions = evo::SmallVector<evo::Variant<uint64_t, sema::Expr>>();
			dimensions.reserve(from_array.dimensions.size());
			for(size_t i = 0; uint64_t dimension : from_array.dimensions){
				if(to_array_ref.dimensions[i].isPtr()){
					dimensions.emplace_back(dimension);
				}else{
					if(dimension != to_array_ref.dimensions[i].length()){
						this->emit_error(
							Diagnostic::Code::SEMA_AS_INVALID_TO,
							instr.infix.rhs,
							"No valid operator [as] to this type",
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info(std::format("Dimension mismatch (index {})", i)),
								Diagnostic::Info(std::format("Expected dimension: {}", dimension)),
								Diagnostic::Info(
									std::format("Got dimension:      {}", to_array_ref.dimensions[i].length())
								),
							}
						);
						return Result::ERROR;
					}
				}

				i += 1;
			}

			const sema::Expr created_array_to_array_ref = sema::Expr(
				this->context.sema_buffer.createInitArrayRef(
					sema::Expr(this->context.sema_buffer.createAddrOf(expr.getExpr())), std::move(dimensions)
				)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				expr.value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				target_type.asTypeID(),
				created_array_to_array_ref
			);
			return Result::SUCCESS;

		}else if(
			from_underlying_type.baseTypeID().kind() != BaseType::Kind::PRIMITIVE
			|| to_underlying_type.baseTypeID().kind() != BaseType::Kind::PRIMITIVE
		){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
			this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
			this->emit_error(
				Diagnostic::Code::SEMA_AS_INVALID_TO,
				instr.infix.rhs,
				"No valid operator [as] to this type",
				std::move(infos)
			);
			return Result::ERROR;
		}



		const BaseType::Primitive& from_primitive =
			type_manager.getPrimitive(from_underlying_type.baseTypeID().primitiveID());

		const BaseType::Primitive& to_primitive =
			type_manager.getPrimitive(to_underlying_type.baseTypeID().primitiveID());


		if(from_primitive.kind() == Token::Kind::TYPE_RAWPTR){
			if(to_primitive.kind() != Token::Kind::TYPE_RAWPTR){
				auto infos = evo::SmallVector<Diagnostic::Info>();
				this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
				this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix,
					"Operator [as] cannot convert a pointer to this type",
					std::move(infos)
				);
				return Result::ERROR;
			}


			const TypeInfo::ID from_decayed_type_id =
				this->context.type_manager.decayType<false, false>(expr.type_id.as<TypeInfo::ID>());
			const TypeInfo& from_decayed_type = type_manager.getTypeInfo(from_decayed_type_id);

			const TypeInfo::ID to_decayed_type_id =
				this->context.type_manager.decayType<false, false>(target_type.asTypeID());
			const TypeInfo& to_decayed_type = type_manager.getTypeInfo(to_decayed_type_id);


			if(from_decayed_type.isPointer() && to_decayed_type.isPointer()){
				this->emit_error(
					Diagnostic::Code::SEMA_AS_INVALID_TO,
					instr.infix,
					"Operator [as] cannot convert from a pointer to a pointer"
				);
				return Result::ERROR;
			}


			if(
				this->currently_in_unsafe() == false
				&& from_decayed_type_id != to_decayed_type_id
				&& from_decayed_type.baseTypeID().kind() == BaseType::Kind::PRIMITIVE
				&& this->context.getTypeManager().getPrimitive(from_decayed_type.baseTypeID().primitiveID())
					== Token::Kind::TYPE_RAWPTR
			){
				this->emit_error(
					Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
					instr.infix,
					"Unsafe operator [as] while not in an unsafe scope"
				);
				return Result::ERROR;
			}


			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				expr.value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				target_type.asTypeID(),
				expr.getExpr()
			);
			return Result::SUCCESS;
			
		}else if(to_primitive.kind() == Token::Kind::TYPE_RAWPTR){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Expression type: ");
			this->diagnostic_print_type_info(target_type.asTypeID(), infos,          "Target type:     ");
			this->emit_error(
				Diagnostic::Code::SEMA_AS_INVALID_TO,
				instr.infix.rhs,
				"No valid operator [as] to this type",
				std::move(infos)
			);
			return Result::ERROR;
		}


		// if converting to same type, no conversion needed
		if(from_underlying_type_id == to_underlying_type_id){
			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				expr.value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				target_type.asTypeID(),
				expr.getExpr()
			);
			return Result::SUCCESS;
		}


		if(from_underlying_type_id == TypeManager::getTypeBool()){
			if constexpr(IS_COMPTIME){
				const TypeInfo& to_type = type_manager.getTypeInfo(target_type.asTypeID());

				switch(to_primitive.kind()){
					case Token::Kind::TYPE_I_N: case Token::Kind::TYPE_UI_N: {
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(this->context.sema_buffer.createIntValue(
								core::GenericInt(
									unsigned(to_primitive.bitWidth()),
									uint64_t(
										this->context.getSemaBuffer().getBoolValue(expr.getExpr().boolValueID()).value
									)
								),
								to_type.baseTypeID()
							))
						);
					} break;

					case Token::Kind::TYPE_F16: {
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF32(
									float(
										this->context.getSemaBuffer().getBoolValue(expr.getExpr().boolValueID()).value
									)
								).asF16(),
								to_type.baseTypeID()
							))
						);
					} break;

					case Token::Kind::TYPE_BF16: {
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF32(
									float(
										this->context.getSemaBuffer().getBoolValue(expr.getExpr().boolValueID()).value
									)
								).asBF16(),
								to_type.baseTypeID()
							))
						);
					} break;

					case Token::Kind::TYPE_F32: {
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF32(
									float(
										this->context.getSemaBuffer().getBoolValue(expr.getExpr().boolValueID()).value
									)
								),
								to_type.baseTypeID()
							))
						);
					} break;

					case Token::Kind::TYPE_F64: {
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF64(
									double(
										this->context.getSemaBuffer().getBoolValue(expr.getExpr().boolValueID()).value
									)
								),
								to_type.baseTypeID()
							))
						);
					} break;

					case Token::Kind::TYPE_F80: {
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF64(
									double(
										this->context.getSemaBuffer().getBoolValue(expr.getExpr().boolValueID()).value
									)
								).asF80(),
								to_type.baseTypeID()
							))
						);
					} break;

					case Token::Kind::TYPE_F128: {
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF64(
									double(
										this->context.getSemaBuffer().getBoolValue(expr.getExpr().boolValueID()).value
									)
								).asF128(),
								to_type.baseTypeID()
							))
						);
					} break;

					default: evo::debugFatalBreak("Invalid primitive type");
				}

				return Result::SUCCESS;

			}else{
				switch(to_primitive.kind()){
					case Token::Kind::TYPE_I_N: case Token::Kind::TYPE_UI_N: {
						using InstantiationID = sema::TemplateIntrinsicFuncInstantiation::ID;
						const InstantiationID instantiation_id =
							this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::ZEXT,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									from_underlying_type_id, to_underlying_type_id
								}
							);

						const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
							instantiation_id, evo::SmallVector<sema::Expr>{expr.getExpr()}
						);

						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							expr.value_stage,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(created_func_call_id)
						);
						return Result::SUCCESS;
					} break;

					case Token::Kind::TYPE_F16: case Token::Kind::TYPE_BF16: case Token::Kind::TYPE_F32:
					case Token::Kind::TYPE_F64: case Token::Kind::TYPE_F80:  case Token::Kind::TYPE_F128: {
						using InstantiationID = sema::TemplateIntrinsicFuncInstantiation::ID;

						const TypeInfo::ID type_id_UI1 = this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(this->context.type_manager.getOrCreatePrimitiveBaseType(Token::Kind::TYPE_UI_N, 1))
						);


						const InstantiationID bitcast_instantiation_id =
							this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::BIT_CAST,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									from_underlying_type_id, TypeInfo::VoidableID(type_id_UI1)
								}
							);

						const sema::FuncCall::ID bitcast_call = this->context.sema_buffer.createFuncCall(
							bitcast_instantiation_id, evo::SmallVector<sema::Expr>{expr.getExpr()}
						);


						const InstantiationID conv_instantiation_id =
							this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::I_TO_F,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									TypeInfo::VoidableID(type_id_UI1), to_underlying_type_id
								}
							);

						const sema::FuncCall::ID conversion_call = this->context.sema_buffer.createFuncCall(
							conv_instantiation_id, evo::SmallVector<sema::Expr>{sema::Expr(bitcast_call)}
						);

						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							expr.value_stage,
							TermInfo::ValueState::NOT_APPLICABLE,
							target_type.asTypeID(),
							sema::Expr(conversion_call)
						);
						return Result::SUCCESS;
					} break;

					default: evo::debugFatalBreak("Invalid primitive type");
				}
			}

		}else if(to_underlying_type_id == TypeManager::getTypeBool()){
			if constexpr(IS_COMPTIME){
				auto comptime_intrinsic_evaluator = ComptimeIntrinsicEvaluator(
					this->context.type_manager, this->context.sema_buffer
				);

				switch(from_primitive.kind()){
					case Token::Kind::TYPE_I_N: case Token::Kind::TYPE_UI_N: {
						this->return_term_info(
							instr.output,
							comptime_intrinsic_evaluator.neq(
								from_underlying_type_id,
								this->context.getSemaBuffer().getIntValue(expr.getExpr().intValueID()).value,
								core::GenericInt(from_primitive.bitWidth(), 0)
							)
						);
					} break;

					case Token::Kind::TYPE_F16: {
						this->return_term_info(
							instr.output,
							comptime_intrinsic_evaluator.neq(
								from_underlying_type_id,
								this->context.getSemaBuffer().getFloatValue(expr.getExpr().floatValueID()).value,
								core::GenericFloat::createF16(0)
							)
						);
					} break;

					case Token::Kind::TYPE_BF16: {
						this->return_term_info(
							instr.output,
							comptime_intrinsic_evaluator.neq(
								from_underlying_type_id,
								this->context.getSemaBuffer().getFloatValue(expr.getExpr().floatValueID()).value,
								core::GenericFloat::createBF16(0)
							)
						);
					} break;

					case Token::Kind::TYPE_F32: {
						this->return_term_info(
							instr.output,
							comptime_intrinsic_evaluator.neq(
								from_underlying_type_id,
								this->context.getSemaBuffer().getFloatValue(expr.getExpr().floatValueID()).value,
								core::GenericFloat::createF32(0)
							)
						);
					} break;

					case Token::Kind::TYPE_F64: {
						this->return_term_info(
							instr.output,
							comptime_intrinsic_evaluator.neq(
								from_underlying_type_id,
								this->context.getSemaBuffer().getFloatValue(expr.getExpr().floatValueID()).value,
								core::GenericFloat::createF64(0)
							)
						);
					} break;

					case Token::Kind::TYPE_F80: {
						this->return_term_info(
							instr.output,
							comptime_intrinsic_evaluator.neq(
								from_underlying_type_id,
								this->context.getSemaBuffer().getFloatValue(expr.getExpr().floatValueID()).value,
								core::GenericFloat::createF80(0)
							)
						);
					} break;

					case Token::Kind::TYPE_F128: {
						this->return_term_info(
							instr.output,
							comptime_intrinsic_evaluator.neq(
								from_underlying_type_id,
								this->context.getSemaBuffer().getFloatValue(expr.getExpr().floatValueID()).value,
								core::GenericFloat::createF128(0)
							)
						);
					} break;

					default: evo::debugFatalBreak("Unknown or unsupported underlying type");
				}

			}else{
				const sema::Expr zero = [&](){
					switch(from_primitive.kind()){
						case Token::Kind::TYPE_I_N: case Token::Kind::TYPE_UI_N: {
							return sema::Expr(this->context.sema_buffer.createIntValue(
								core::GenericInt(from_primitive.bitWidth(), 0), from_underlying_type.baseTypeID()
							));
						} break;

						case Token::Kind::TYPE_F16: {
							return sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF16(0), from_underlying_type.baseTypeID()
							));
						} break;

						case Token::Kind::TYPE_BF16: {
							return sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createBF16(0), from_underlying_type.baseTypeID()
							));
						} break;

						case Token::Kind::TYPE_F32: {
							return sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF32(0), from_underlying_type.baseTypeID()
							));
						} break;

						case Token::Kind::TYPE_F64: {
							return sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF64(0), from_underlying_type.baseTypeID()
							));
						} break;

						case Token::Kind::TYPE_F80: {
							return sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF80(0), from_underlying_type.baseTypeID()
							));
						} break;

						case Token::Kind::TYPE_F128: {
							return sema::Expr(this->context.sema_buffer.createFloatValue(
								core::GenericFloat::createF128(0), from_underlying_type.baseTypeID()
							));
						} break;

						default: evo::debugFatalBreak("Unknown or unsupported underlying type");
					}
				}();


				const sema::TemplateIntrinsicFuncInstantiation::ID instantiation_id = 
					this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
						TemplateIntrinsicFunc::Kind::NEQ,
						evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
							from_underlying_type_id, to_underlying_type_id
						}
					);

				const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
					instantiation_id, evo::SmallVector<sema::Expr>{expr.getExpr(), zero}
				);

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					expr.value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					target_type.asTypeID(),
					sema::Expr(created_func_call_id)
				);
			}

			return Result::SUCCESS;
		}


		struct TypeConversionData{
			enum class Kind{
				INTEGER,
				UNSIGNED_INTEGER,
				FLOAT,
			} kind;
			unsigned width;
		};

		auto get_type_conversion_data = [this](const BaseType::Primitive& primitive_type) -> TypeConversionData {
			switch(primitive_type.kind()){
				case Token::Kind::TYPE_I_N:
					return TypeConversionData(TypeConversionData::Kind::INTEGER, primitive_type.bitWidth());
				case Token::Kind::TYPE_UI_N:
					return TypeConversionData(TypeConversionData::Kind::UNSIGNED_INTEGER, primitive_type.bitWidth());
				case Token::Kind::TYPE_F16:  return TypeConversionData(TypeConversionData::Kind::FLOAT, 16);
				case Token::Kind::TYPE_BF16: return TypeConversionData(TypeConversionData::Kind::FLOAT, 16);
				case Token::Kind::TYPE_F32:  return TypeConversionData(TypeConversionData::Kind::FLOAT, 32);
				case Token::Kind::TYPE_F64:  return TypeConversionData(TypeConversionData::Kind::FLOAT, 64);
				case Token::Kind::TYPE_F80:  return TypeConversionData(TypeConversionData::Kind::FLOAT, 80);
				case Token::Kind::TYPE_F128: return TypeConversionData(TypeConversionData::Kind::FLOAT, 128);

				default: evo::debugFatalBreak("Unknown or unsupported underlying type");
			}
		};

		const TypeConversionData from_data = get_type_conversion_data(from_primitive);
		const TypeConversionData to_data = get_type_conversion_data(to_primitive);


		if constexpr(IS_COMPTIME){
			auto comptime_intrinsic_evaluator = ComptimeIntrinsicEvaluator(
				this->context.type_manager, this->context.sema_buffer
			);

			switch(from_data.kind){
				case TypeConversionData::Kind::INTEGER: {
					switch(to_data.kind){
						case TypeConversionData::Kind::INTEGER: case TypeConversionData::Kind::UNSIGNED_INTEGER: {
							if(from_data.width < to_data.width){
								this->return_term_info(instr.output,
									comptime_intrinsic_evaluator.sext(
										target_type.asTypeID(),
										this->context.sema_buffer.getIntValue(expr.getExpr().intValueID()).value
									)
								);
							}else{
								this->return_term_info(instr.output,
									comptime_intrinsic_evaluator.trunc(
										target_type.asTypeID(),
										this->context.sema_buffer.getIntValue(expr.getExpr().intValueID()).value
									)
								);
							}
						} break;

						case TypeConversionData::Kind::FLOAT: {
							this->return_term_info(instr.output,
								comptime_intrinsic_evaluator.iToF(
									target_type.asTypeID(),
									this->context.sema_buffer.getIntValue(expr.getExpr().intValueID()).value
								)
							);
						} break;
					}
				} break;

				case TypeConversionData::Kind::UNSIGNED_INTEGER: {
					switch(to_data.kind){
						case TypeConversionData::Kind::INTEGER: case TypeConversionData::Kind::UNSIGNED_INTEGER: {
							if(from_data.width < to_data.width){
								this->return_term_info(instr.output,
									comptime_intrinsic_evaluator.iToF(
										target_type.asTypeID(),
										this->context.sema_buffer.getIntValue(expr.getExpr().intValueID()).value
									)
								);
							}else{
								this->return_term_info(instr.output,
									comptime_intrinsic_evaluator.trunc(
										target_type.asTypeID(),
										this->context.sema_buffer.getIntValue(expr.getExpr().intValueID()).value
									)
								);
							}
						} break;

						case TypeConversionData::Kind::FLOAT: {
							this->return_term_info(instr.output,
								comptime_intrinsic_evaluator.iToF(
									target_type.asTypeID(),
									this->context.sema_buffer.getIntValue(expr.getExpr().intValueID()).value
								)
							);
						} break;
					}
				} break;

				case TypeConversionData::Kind::FLOAT: {
					switch(to_data.kind){
						case TypeConversionData::Kind::INTEGER: case TypeConversionData::Kind::UNSIGNED_INTEGER: {
							this->return_term_info(instr.output,
								comptime_intrinsic_evaluator.fToI(
									target_type.asTypeID(),
									this->context.sema_buffer.getFloatValue(expr.getExpr().floatValueID()).value
								)
							);
						} break;

						case TypeConversionData::Kind::FLOAT: {
							if(from_data.width < to_data.width){
								this->return_term_info(instr.output,
									comptime_intrinsic_evaluator.fext(
										target_type.asTypeID(),
										this->context.sema_buffer.getFloatValue(expr.getExpr().floatValueID()).value
									)
								);
							}else{
								this->return_term_info(instr.output,
									comptime_intrinsic_evaluator.ftrunc(
										target_type.asTypeID(),
										this->context.sema_buffer.getFloatValue(expr.getExpr().floatValueID()).value
									)
								);
							}
						} break;
					}
				} break;
			}

			return Result::SUCCESS;

		}else{
			const TemplateIntrinsicFunc::Kind intrinsic_kind = [&](){
				switch(from_data.kind){
					case TypeConversionData::Kind::INTEGER: {
						switch(to_data.kind){
							case TypeConversionData::Kind::INTEGER: case TypeConversionData::Kind::UNSIGNED_INTEGER: {
								if(from_data.width < to_data.width){
									return TemplateIntrinsicFunc::Kind::SEXT;
								}else{
									return TemplateIntrinsicFunc::Kind::TRUNC;
								}
							} break;

							case TypeConversionData::Kind::FLOAT: {
								return TemplateIntrinsicFunc::Kind::I_TO_F;
							} break;
						}
					} break;

					case TypeConversionData::Kind::UNSIGNED_INTEGER: {
						switch(to_data.kind){
							case TypeConversionData::Kind::INTEGER: case TypeConversionData::Kind::UNSIGNED_INTEGER: {
								if(from_data.width < to_data.width){
									return TemplateIntrinsicFunc::Kind::ZEXT;
								}else{
									return TemplateIntrinsicFunc::Kind::TRUNC;
								}
							} break;

							case TypeConversionData::Kind::FLOAT: {
								return TemplateIntrinsicFunc::Kind::I_TO_F;
							} break;
						}
					} break;

					case TypeConversionData::Kind::FLOAT: {
						switch(to_data.kind){
							case TypeConversionData::Kind::INTEGER: case TypeConversionData::Kind::UNSIGNED_INTEGER: {
								return TemplateIntrinsicFunc::Kind::F_TO_I;
							} break;

							case TypeConversionData::Kind::FLOAT: {
								if(from_data.width < to_data.width){
									return TemplateIntrinsicFunc::Kind::FEXT;
								}else{
									return TemplateIntrinsicFunc::Kind::FTRUNC;
								}
							} break;
						}
					} break;
				}

				evo::debugFatalBreak("Unknown or unsupported TypeConversionData::Kind");
			}();

			using InstantiationID = sema::TemplateIntrinsicFuncInstantiation::ID;
			const InstantiationID instantiation_id = this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
				intrinsic_kind,
				evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
					from_underlying_type_id, to_underlying_type_id
				}
			);

			const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
				instantiation_id, evo::SmallVector<sema::Expr>{expr.getExpr()}
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				expr.value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				target_type.asTypeID(),
				sema::Expr(created_func_call_id)
			);
			return Result::SUCCESS;
		}
	}

	auto SemanticAnalyzer::operator_as_check_interface_map(
		const TermInfo& from_expr,
		const TypeInfo::ID from_type_id,
		const TypeInfo::ID to_type_id,
		SymbolProc::TermInfoID output_id,
		const AST::Infix& ast_infix
	) -> std::optional<Result> {
		const TypeInfo::ID decayed_from_type_id = this->context.type_manager.decayType<false, false>(from_type_id);
		const TypeInfo& decayed_from_type = this->context.getTypeManager().getTypeInfo(decayed_from_type_id);


		const TypeInfo::ID decayed_to_type_id = this->context.type_manager.decayType<false, false>(to_type_id);
		const TypeInfo& decayed_to_type = this->context.getTypeManager().getTypeInfo(decayed_to_type_id);


		TypeInfo::ID target_interface_impl_type_id = decayed_from_type_id;

		const evo::Result<bool> qualifiers_check_result = 
			this->type_qualifiers_check(decayed_to_type.qualifiers(), decayed_from_type.qualifiers());

		if(qualifiers_check_result.isError() || qualifiers_check_result.value()){
			// if there are qualifiers, didn't match
			// Allows for qualified type that implement the interface to pass
			if(decayed_to_type.qualifiers().empty() == false){ return std::nullopt; }
			
		}else{
			// remove matching qualifiers
			target_interface_impl_type_id =
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(decayed_from_type.baseTypeID()));
		}


		switch(decayed_to_type.baseTypeID().kind()){
			case BaseType::Kind::DUMMY: evo::debugFatalBreak("Invalid type");

			case BaseType::Kind::PRIMITIVE:               return std::nullopt;
			case BaseType::Kind::FUNCTION:                return std::nullopt;
			case BaseType::Kind::ARRAY:                   return std::nullopt;
			case BaseType::Kind::ARRAY_DEDUCER:           evo::debugFatalBreak("Invalid operator [as] target");
			case BaseType::Kind::ARRAY_REF:               return std::nullopt;
			case BaseType::Kind::ARRAY_REF_DEDUCER:       evo::debugFatalBreak("Invalid operator [as] target");
			case BaseType::Kind::ALIAS:                   evo::debugFatalBreak("Should never hit here");
			case BaseType::Kind::DISTINCT_ALIAS:          return std::nullopt;
			case BaseType::Kind::STRUCT:                  return std::nullopt;
			case BaseType::Kind::STRUCT_TEMPLATE:         evo::debugFatalBreak("Invalid operator [as] target");
			case BaseType::Kind::STRUCT_TEMPLATE_DEDUCER: evo::debugFatalBreak("Invalid operator [as] target");
			case BaseType::Kind::UNION:                   return std::nullopt;
			case BaseType::Kind::ENUM:                    return std::nullopt;
			case BaseType::Kind::TYPE_DEDUCER:            evo::debugFatalBreak("Invalid operator [as] target");
			case BaseType::Kind::INTERFACE:               return std::nullopt;

			case BaseType::Kind::POLY_INTERFACE_REF: {
				const BaseType::PolyInterfaceRef& target_poly_interface_ref = 
					this->context.getTypeManager().getPolyInterfaceRef(
						decayed_to_type.baseTypeID().polyInterfaceRefID()
					);

				BaseType::Interface& target_interface =
					this->context.type_manager.getInterface(target_poly_interface_ref.interfaceID);

				const evo::Expected<bool, Result> implements_result = this->type_implements_interface(
					target_interface, target_interface_impl_type_id, this->get_location(ast_infix)
				);

				if(implements_result.has_value() == false){ return implements_result.error(); }
				if(implements_result.value() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_MAP_TYPE_DOESNT_IMPL_INTERFACE,
						ast_infix,
						"Base type of interface map doesn't implement the target interface"
					);
					return Result::ERROR;
				}


				if(target_poly_interface_ref.isMut && from_expr.is_const()){
					this->emit_error(
						Diagnostic::Code::SEMA_AS_CONST_TO_MUT_POLY_INTERFACE_REF,
						ast_infix,
						"Operator [as] cannot convert a const expression to a mutable polymorphic interface reference"
					);
					return Result::ERROR;
				}

				const sema::MakeInterfacePtr::ID make_interface_ptr_id = 
					this->context.sema_buffer.createMakeInterfacePtr(
						from_expr.getExpr(), target_poly_interface_ref.interfaceID, from_type_id
					);

				this->return_term_info(output_id,
					TermInfo::ValueCategory::EPHEMERAL,
					from_expr.value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					to_type_id,
					sema::Expr(make_interface_ptr_id)
				);
				return Result::SUCCESS;
			} break;

			case BaseType::Kind::INTERFACE_MAP: {
				const BaseType::InterfaceMap& target_interface_map = 
					this->context.getTypeManager().getInterfaceMap(decayed_to_type.baseTypeID().interfaceMapID());

				BaseType::Interface& target_interface =
					this->context.type_manager.getInterface(target_interface_map.interfaceID);

				const evo::Expected<bool, Result> implements_result = this->type_implements_interface(
					target_interface, target_interface_impl_type_id, this->get_location(ast_infix)
				);

				if(implements_result.has_value() == false){ return implements_result.error(); }
				if(implements_result.value() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_MAP_TYPE_DOESNT_IMPL_INTERFACE,
						ast_infix,
						"Base type of interface map doesn't implement the target interface"
					);
					return Result::ERROR;
				}

				this->return_term_info(output_id,
					from_expr.value_category,
					from_expr.value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					to_type_id,
					from_expr.getExpr()
				);
				return Result::SUCCESS;
			} break;
		}

		evo::debugFatalBreak("Unknown base type");
	}



	auto SemanticAnalyzer::instr_optional_null_check(const Instruction::OptionalNullCheck& instr) -> Result {
		const TermInfo& lhs = this->get_term_info(instr.lhs);

		if(lhs.type_id.is<TypeInfo::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_OPTIONAL_NULL_CHECK_INVALID_LHS,
				instr.infix.lhs,
				"LHS cannot be compared to [null]",
				Diagnostic::Info("Only optional values can be compared to [null]")
			);
			return Result::ERROR;
		}

		if(
			lhs.value_state != TermInfo::ValueState::INIT
			&& lhs.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"LHS of [null] comparison must be initialized"
			);
			return Result::ERROR;
		}

		const TypeInfo::ID lhs_decayed_type_id =
			this->context.type_manager.decayType<true, false>(lhs.type_id.as<TypeInfo::ID>());
		const TypeInfo& lhs_decayed_type = this->context.getTypeManager().getTypeInfo(lhs_decayed_type_id);

		if(lhs_decayed_type.isOptional() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_OPTIONAL_NULL_CHECK_INVALID_LHS,
				instr.infix.lhs,
				"LHS cannot be compared to [null]",
				Diagnostic::Info("Only optional values can be compared to [null]")
			);
			return Result::ERROR;
		}

		const bool is_equal = this->source.getTokenBuffer()[instr.infix.opTokenID].kind() == Token::lookupKind("==");
			
		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EPHEMERAL,
			lhs.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			TypeManager::getTypeBool(),
			sema::Expr(this->context.sema_buffer.createOptionalNullCheck(lhs.getExpr(), lhs_decayed_type_id, is_equal))
		);
		return Result::SUCCESS;
	}



	template<bool IS_COMPTIME, Instruction::MathInfixKind MATH_INFIX_KIND>
	auto SemanticAnalyzer::instr_expr_math_infix(const Instruction::MathInfix<IS_COMPTIME, MATH_INFIX_KIND>& instr)
	-> Result {
		TermInfo& lhs = this->get_term_info(instr.lhs);
		TermInfo& rhs = this->get_term_info(instr.rhs);

		if(lhs.isSingleNormalValue() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_MATH_INFIX_INVALID_LHS, instr.infix.lhs, "Invalid LHS of math infix operator"
			);
			return Result::ERROR;
		}

		if(rhs.isSingleNormalValue() == false){
			if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::COMPARATIVE){
				const Token::Kind op_kind = this->source.getTokenBuffer()[instr.infix.opTokenID].kind();

				if(op_kind == Token::lookupKind("==") || op_kind == Token::lookupKind("!=")){
					if(rhs.value_category != TermInfo::ValueCategory::TAGGED_UNION_FIELD_ACCESSOR){
						this->emit_error(
							Diagnostic::Code::SEMA_MATH_INFIX_INVALID_RHS,
							instr.infix.rhs,
							"Invalid RHS of math infix operator"
						);
						return Result::ERROR;
					}

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_MATH_INFIX_INVALID_RHS,
						instr.infix.rhs,
						"Invalid RHS of math infix operator"
					);
					return Result::ERROR;
				}
			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_MATH_INFIX_INVALID_RHS, instr.infix.rhs, "Invalid RHS of math infix operator"
				);
				return Result::ERROR;
			}
		}


		if(
			lhs.value_state != TermInfo::ValueState::INIT
			&& lhs.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"LHS of math infix operator must be initialized"
			);
			return Result::ERROR;
		}

		if(
			rhs.value_state != TermInfo::ValueState::INIT
			&& rhs.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.rhs,
				"RHS of math infix operator must be initialized"
			);
			return Result::ERROR;
		}


		if(lhs.type_id.is<TypeInfo::ID>()){
			if(rhs.type_id.is<TypeInfo::ID>()){ // neither lhs nor rhs fluid
				const TypeInfo::ID lhs_decayed_type_id =
					this->context.type_manager.decayType<false, false>(lhs.type_id.as<TypeInfo::ID>());

				const TypeInfo::ID rhs_decayed_type_id =
					this->context.type_manager.decayType<false, false>(rhs.type_id.as<TypeInfo::ID>());


				const TypeInfo& lhs_decayed_type = this->context.getTypeManager().getTypeInfo(lhs_decayed_type_id);
				const TypeInfo& rhs_decayed_type = this->context.getTypeManager().getTypeInfo(rhs_decayed_type_id);


				if(
					lhs_decayed_type.qualifiers().empty()
					&& lhs_decayed_type.baseTypeID().kind() == BaseType::Kind::STRUCT
				){
					const BaseType::Struct& lhs_struct =
						this->context.getTypeManager().getStruct(lhs_decayed_type.baseTypeID().structID());

					const evo::Expected<sema::FuncCall::ID, Result> infix_overload_result = 
						this->infix_overload_impl(lhs_struct.infixOverloads, lhs, rhs, instr.infix);

					if(infix_overload_result.has_value() == false){
						return infix_overload_result.error();
					}


					const sema::FuncCall& created_func_call =
						this->context.getSemaBuffer().getFuncCall(infix_overload_result.value());

					const sema::Func& target_func =
						this->context.getSemaBuffer().getFunc(created_func_call.target.as<sema::Func::ID>());

					const BaseType::Function& target_func_type =
						this->context.getTypeManager().getFunction(target_func.typeID);


					if(target_func_type.isUnsafe && this->currently_in_unsafe() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
							instr.infix,
							"Call to unsafe math infix operator while not in an unsafe scope"
						);
						return Result::ERROR;
					}


					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						lhs.value_stage,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_func_type.returnTypes[0].asTypeID(),
						sema::Expr(infix_overload_result.value())
					);
					return Result::SUCCESS;

				}else if(
					rhs_decayed_type.qualifiers().empty()
					&& rhs_decayed_type.baseTypeID().kind() == BaseType::Kind::STRUCT
				){
					const BaseType::Struct& rhs_struct =
						this->context.getTypeManager().getStruct(rhs_decayed_type.baseTypeID().structID());

					const evo::Expected<sema::FuncCall::ID, Result> infix_overload_result = 
						this->infix_overload_impl(rhs_struct.infixOverloads, lhs, rhs, instr.infix);

					if(infix_overload_result.has_value() == false){
						return infix_overload_result.error();
					}


					const sema::FuncCall& created_func_call =
						this->context.getSemaBuffer().getFuncCall(infix_overload_result.value());

					const sema::Func& target_func =
						this->context.getSemaBuffer().getFunc(created_func_call.target.as<sema::Func::ID>());

					const BaseType::Function& target_func_type =
						this->context.getTypeManager().getFunction(target_func.typeID);

					if(target_func_type.isUnsafe && this->currently_in_unsafe() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
							instr.infix,
							"Call to unsafe math infix operator while not in an unsafe scope"
						);
						return Result::ERROR;
					}

					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						rhs.value_stage,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_func_type.returnTypes[0].asTypeID(),
						sema::Expr(infix_overload_result.value())
					);
					return Result::SUCCESS;
				}



				if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::COMPARATIVE){
					const Token::Kind op_kind = this->source.getTokenBuffer()[instr.infix.opTokenID].kind();

					if(this->type_check<true, true>(
						lhs.type_id.as<TypeInfo::ID>(),
						rhs,
						std::format(
							"RHS of infix [{}] operator",
							this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
						),
						instr.infix
					).ok == false){
						return Result::ERROR;
					}

					if(op_kind == Token::lookupKind("==") || op_kind == Token::lookupKind("!=")){
						if(lhs_decayed_type.qualifiers().empty() == false){
							if(lhs_decayed_type.qualifiers().back().isPtr){
								if(lhs_decayed_type.baseTypeID().kind() == BaseType::Kind::INTERFACE){
									auto infos = evo::SmallVector<Diagnostic::Info>();
									this->diagnostic_print_type_info(
										lhs.type_id.as<TypeInfo::ID>(), infos, "LHS type: "
									);
									this->emit_error(
										Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
										instr.infix.lhs,
										std::format(
											"Infix [{}] of interface pointers is invalid",
											this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
										),
										std::move(infos)
									);
									return Result::ERROR;
								}

							}else{
								evo::debugAssert(
									lhs_decayed_type.qualifiers().back().isOptional, "Unknown type qualifiers"
								);

								if(this->context.getTypeManager().isComparable(
									lhs_decayed_type_id, this->context.getSemaBuffer()
								) == false){
									auto infos = evo::SmallVector<Diagnostic::Info>();
									this->diagnostic_print_type_info(
										lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: "
									);
									this->emit_error(
										Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
										instr.infix.lhs,
										std::format(
											"Infix [{}] of this type is invalid",
											this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
										),
										std::move(infos)
									);
									return Result::ERROR;
								}

								const sema::SameTypeCmp::ID same_type_cmp = this->context.sema_buffer.createSameTypeCmp(
									lhs_decayed_type_id,
									lhs.getExpr(),
									rhs.getExpr(),
									op_kind == Token::lookupKind("==")
								);

								this->return_term_info(instr.output,
									TermInfo::ValueCategory::EPHEMERAL,
									lhs.value_stage,
									TermInfo::ValueState::NOT_APPLICABLE,
									TypeManager::getTypeBool(),
									sema::Expr(same_type_cmp)
								);
								return Result::SUCCESS;
							}

						}else{
							switch(lhs_decayed_type.baseTypeID().kind()){
								case BaseType::Kind::PRIMITIVE: {
									// do nothing...
								} break;

								case BaseType::Kind::FUNCTION: {
									this->emit_error(
										Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
										instr.infix,
										std::format(
											"Infix [{}] operator of functions is unimplemented",
											this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
										)
									);
									return Result::ERROR;
								} break;

								case BaseType::Kind::ARRAY: case BaseType::Kind::ARRAY_REF: case BaseType::Kind::UNION:{
									if(this->context.getTypeManager().isComparable(
										lhs_decayed_type_id, this->context.getSemaBuffer()
									) == false){
										auto infos = evo::SmallVector<Diagnostic::Info>();
										this->diagnostic_print_type_info(
											lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: "
										);
										this->emit_error(
											Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
											instr.infix.lhs,
											std::format(
												"Infix [{}] of this type is invalid",
												this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
											),
											std::move(infos)
										);
										return Result::ERROR;
									}

									const sema::SameTypeCmp::ID same_type_cmp = 
										this->context.sema_buffer.createSameTypeCmp(
											lhs_decayed_type_id,
											lhs.getExpr(),
											rhs.getExpr(),
											op_kind == Token::lookupKind("==")
										);

									this->return_term_info(instr.output,
										TermInfo::ValueCategory::EPHEMERAL,
										lhs.value_stage,
										TermInfo::ValueState::NOT_APPLICABLE,
										TypeManager::getTypeBool(),
										sema::Expr(same_type_cmp)
									);
									return Result::SUCCESS;
								} break;
								
								case BaseType::Kind::ENUM: {
									// do nothing...
								} break;

								case BaseType::Kind::DUMMY: evo::debugFatalBreak("Invalid type");

								case BaseType::Kind::ARRAY_DEDUCER:
								case BaseType::Kind::STRUCT_TEMPLATE:
								case BaseType::Kind::STRUCT_TEMPLATE_DEDUCER:
								case BaseType::Kind::TYPE_DEDUCER:
								case BaseType::Kind::INTERFACE:
								case BaseType::Kind::INTERFACE_MAP: {
									evo::debugFatalBreak("Invalid type to be compared");
								} break;


								case BaseType::Kind::ALIAS: case BaseType::Kind::DISTINCT_ALIAS: {
									evo::debugFatalBreak("Should have been skipped by getting decayed type");
								} break;

								case BaseType::Kind::STRUCT: {
									evo::debugFatalBreak("Should have already been checked");
								} break;
							}
						}

					}else{ // <, <=, >, >=
						if(
							lhs_decayed_type.qualifiers().empty() == false
							|| lhs_decayed_type.baseTypeID().kind() != BaseType::Kind::PRIMITIVE
							|| this->context.getTypeManager().getPrimitive(
									lhs_decayed_type.baseTypeID().primitiveID()
								).kind() == Token::Kind::TYPE_TYPEID
						){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(
								lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: "
							);
							this->emit_error(
								Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
								instr.infix.lhs,
								std::format(
									"Infix [{}] of this type is invalid",
									this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
								),
								std::move(infos)
							);
							return Result::ERROR;
						}
					}

				}else if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::SHIFT){
					if(this->context.getTypeManager().isIntegral(lhs_decayed_type_id) == false){
						auto infos = evo::SmallVector<Diagnostic::Info>();
						this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "LHS type: ");
						this->emit_error(
							Diagnostic::Code::SEMA_MATH_INFIX_INVALID_LHS,
							instr.infix.lhs,
							std::format(
								"LHS of [{}] operator must be integral",
								this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
							),
							std::move(infos)
						);
						return Result::ERROR;
					}

					if(this->context.getTypeManager().isUnsignedIntegral(rhs_decayed_type_id) == false){
						auto infos = evo::SmallVector<Diagnostic::Info>();
						this->diagnostic_print_type_info(rhs.type_id.as<TypeInfo::ID>(), infos, "RHS type: ");
						this->emit_error(
							Diagnostic::Code::SEMA_MATH_INFIX_INVALID_RHS,
							instr.infix.lhs,
							std::format(
								"RHS of operator [{}] must be unsigned integral",
								this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
							),
							std::move(infos)
						);
						return Result::ERROR;
					}

					const uint64_t num_bits_lhs_type =
						this->context.getTypeManager().numBits(lhs_decayed_type_id);

					const uint64_t num_bits_rhs_type =
						this->context.getTypeManager().numBits(rhs_decayed_type_id);

					const uint64_t expected_num_bits_rhs_type =
						uint64_t(std::ceil(std::log2(double(num_bits_lhs_type))));

					if(num_bits_rhs_type != expected_num_bits_rhs_type){
						auto infos = evo::SmallVector<Diagnostic::Info>();
						infos.emplace_back(std::format("Correct type: UI{}", expected_num_bits_rhs_type));
						this->diagnostic_print_type_info(rhs.type_id.as<TypeInfo::ID>(), infos, "LHS type:     ");
						this->emit_error(
							Diagnostic::Code::SEMA_MATH_INFIX_INVALID_RHS,
							instr.infix.rhs,
							std::format(
								"RHS of operator [{}] is incorrect bit-width for this LHS",
								this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
							),
							std::move(infos)
						);
						return Result::ERROR;
					}

				}else{
					if(this->type_check<true, true>(
						lhs.type_id.as<TypeInfo::ID>(),
						rhs,
						std::format(
							"RHS of infix [{}] operator", this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
						),
						instr.infix
					).ok == false){
						return Result::ERROR;
					}

					if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::MATH){
						if(
							this->context.getTypeManager().isIntegral(lhs_decayed_type_id) == false
							&& this->context.getTypeManager().isFloatingPoint(lhs_decayed_type_id) == false
						){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: ");
							this->emit_error(
								Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
								instr.infix,
								"No matching operation for this type",
								std::move(infos)
							);
							return Result::ERROR;
						}
					
					}else if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::INTEGRAL_MATH){
						if(this->context.getTypeManager().isIntegral(lhs_decayed_type_id) == false){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: ");
							this->emit_error(
								Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
								instr.infix,
								"No matching operation for this type",
								std::move(infos)
							);
							return Result::ERROR;
						}

					}else if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::LOGICAL){
						if(lhs_decayed_type_id != TypeManager::getTypeBool()){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: ");
							this->emit_error(
								Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
								instr.infix,
								"No matching operation for this type",
								std::move(infos)
							);
							return Result::ERROR;
						}

					}else if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::BITWISE_LOGICAL){
						if(lhs_decayed_type.qualifiers().empty() == false){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: ");
							this->emit_error(
								Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
								instr.infix,
								"No matching operation for this type",
								std::move(infos)
							);
							return Result::ERROR;
						}

						switch(lhs_decayed_type.baseTypeID().kind()){
							case BaseType::Kind::PRIMITIVE: {
								const BaseType::Primitive& lhs_decayed_primitive = 
									this->context.getTypeManager().getPrimitive(
										lhs_decayed_type.baseTypeID().primitiveID()
									);

								if(
									this->context.getTypeManager().isIntegral(lhs_decayed_type_id) == false
									&& lhs_decayed_primitive.kind() != Token::Kind::TYPE_BOOL
								){
									auto infos = evo::SmallVector<Diagnostic::Info>();
									this->diagnostic_print_type_info(
										lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: "
									);
									this->emit_error(
										Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
										instr.infix,
										"No matching operation for this type",
										std::move(infos)
									);
									return Result::ERROR;
								}
							} break;

							case BaseType::Kind::ENUM: {
								// do nothing...
							} break;

							default: {
								auto infos = evo::SmallVector<Diagnostic::Info>();
								this->diagnostic_print_type_info(
									lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: "
								);
								this->emit_error(
									Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
									instr.infix,
									"No matching operation for this type",
									std::move(infos)
								);
								return Result::ERROR;
							} break;
						}
					}
				}


			}else{ // rhs fluid
				const TypeInfo::ID lhs_decayed_type_id =
					this->context.type_manager.decayType<false, false>(lhs.type_id.as<TypeInfo::ID>());

				const TypeInfo& lhs_decayed_type = this->context.getTypeManager().getTypeInfo(lhs_decayed_type_id);

				if(lhs_decayed_type.baseTypeID().kind() == BaseType::Kind::STRUCT){
					const BaseType::Struct& lhs_struct =
						this->context.getTypeManager().getStruct(lhs_decayed_type.baseTypeID().structID());

					const evo::Expected<sema::FuncCall::ID, Result> infix_overload_result = 
						this->infix_overload_impl(lhs_struct.infixOverloads, lhs, rhs, instr.infix);

					if(infix_overload_result.has_value() == false){
						return infix_overload_result.error();
					}


					const sema::FuncCall& created_func_call =
						this->context.getSemaBuffer().getFuncCall(infix_overload_result.value());

					const sema::Func& target_func =
						this->context.getSemaBuffer().getFunc(created_func_call.target.as<sema::Func::ID>());

					const BaseType::Function& target_func_type =
						this->context.getTypeManager().getFunction(target_func.typeID);

					if(target_func_type.isUnsafe && this->currently_in_unsafe() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
							instr.infix,
							"Call to unsafe math infix operator while not in an unsafe scope"
						);
						return Result::ERROR;
					}


					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						lhs.value_stage,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_func_type.returnTypes[0].asTypeID(),
						sema::Expr(infix_overload_result.value())
					);
					return Result::SUCCESS;
				}


				if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::SHIFT){
					if(this->context.getTypeManager().isIntegral(lhs_decayed_type_id) == false){
						auto infos = evo::SmallVector<Diagnostic::Info>();
						this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "LHS type: ");
						this->emit_error(
							Diagnostic::Code::SEMA_MATH_INFIX_INVALID_LHS,
							instr.infix.lhs,
							std::format(
								"LHS of [{}] operator must be integral",
								this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
							),
							std::move(infos)
						);
						return Result::ERROR;
					}

					const uint64_t num_bits_lhs_type =
						this->context.getTypeManager().numBits(lhs_decayed_type_id);

					const uint32_t expected_num_bits_rhs_type =
						uint32_t(std::ceil(std::log2(double(num_bits_lhs_type))));

					const TypeInfo::ID expected_rhs_type = this->context.type_manager.getOrCreateTypeInfo(
						TypeInfo(
							this->context.type_manager.getOrCreatePrimitiveBaseType(
								Token::Kind::TYPE_UI_N, expected_num_bits_rhs_type
							)
						)
					);

					if(this->type_check<true, true>(
						expected_rhs_type,
						rhs,
						std::format(
							"RHS of operator [{}]", this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
						),
						instr.infix.rhs
					).ok == false){
						return Result::ERROR;
					}


				}else{
					if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::COMPARATIVE){
						const Token::Kind op_kind = this->source.getTokenBuffer()[instr.infix.opTokenID].kind();

						if(op_kind == Token::lookupKind("==") || op_kind == Token::lookupKind("!=")){
							if(rhs.value_category == TermInfo::ValueCategory::TAGGED_UNION_FIELD_ACCESSOR){
								const TermInfo::TaggedUnionFieldAccessor& tagged_union_field_accessor = 
									rhs.type_id.as<TermInfo::TaggedUnionFieldAccessor>();

								if(
									lhs_decayed_type.qualifiers().empty() == false
									|| lhs_decayed_type.baseTypeID().kind() != BaseType::Kind::UNION
									|| lhs_decayed_type.baseTypeID().unionID() != tagged_union_field_accessor.union_id
								){
									this->error_type_mismatch(
										this->context.type_manager.getOrCreateTypeInfo(
											TypeInfo(BaseType::ID(tagged_union_field_accessor.union_id))
										),
										lhs,
										"RHS of union tag comparison",
										instr.infix.lhs
									);
									return Result::ERROR;
								}
								
								if constexpr(IS_COMPTIME){
									this->emit_error(
										Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
										instr.infix,
										"Comptime comparison of union tag is unimplemented"
									);
									return Result::ERROR;
								}else{
									this->return_term_info(instr.output,
										TermInfo::ValueCategory::EPHEMERAL,
										lhs.value_stage,
										TermInfo::ValueState::NOT_APPLICABLE,
										TypeManager::getTypeBool(),
										sema::Expr(
											this->context.sema_buffer.createUnionTagCmp(
												lhs.getExpr(),
												lhs_decayed_type.baseTypeID().unionID(),
												tagged_union_field_accessor.field_index,
												op_kind == Token::lookupKind("==")
											)
										)
									);
									return Result::SUCCESS;
								}
							}
						}
					}



					if(this->type_check<true, true>(
						lhs_decayed_type_id,
						rhs,
						std::format(
							"RHS of operator [{}]", this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
						),
						instr.infix.rhs
					).ok == false){
						return Result::ERROR;
					}

					if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::MATH){
						if(
							this->context.getTypeManager().isIntegral(lhs_decayed_type_id) == false
							&& this->context.getTypeManager().isFloatingPoint(lhs_decayed_type_id) == false
						){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(lhs_decayed_type_id, infos, "Argument type: ");
							this->emit_error(
								Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
								instr.infix,
								"No matching operation for this type",
								std::move(infos)
							);
							return Result::ERROR;
						}
					
					}else if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::INTEGRAL_MATH){
						if(this->context.getTypeManager().isIntegral(lhs_decayed_type_id) == false){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: ");
							this->emit_error(
								Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
								instr.infix,
								"No matching operation for this type",
								std::move(infos)
							);
							return Result::ERROR;
						}
					}
				}
			}

		}else if(rhs.type_id.is<TypeInfo::ID>()){ // lhs fluid
			const TypeInfo::ID rhs_decayed_type_id =
				this->context.type_manager.decayType<false, false>(rhs.type_id.as<TypeInfo::ID>());

			const TypeInfo& rhs_decayed_type = this->context.getTypeManager().getTypeInfo(rhs_decayed_type_id);

			if(rhs_decayed_type.baseTypeID().kind() == BaseType::Kind::STRUCT){
				const BaseType::Struct& rhs_struct =
					this->context.getTypeManager().getStruct(rhs_decayed_type.baseTypeID().structID());

				const evo::Expected<sema::FuncCall::ID, Result> infix_overload_result = 
					this->infix_overload_impl(rhs_struct.infixOverloads, lhs, rhs, instr.infix);

				if(infix_overload_result.has_value() == false){
					return infix_overload_result.error();
				}


				const sema::FuncCall& created_func_call =
					this->context.getSemaBuffer().getFuncCall(infix_overload_result.value());

				const sema::Func& target_func =
					this->context.getSemaBuffer().getFunc(created_func_call.target.as<sema::Func::ID>());

				const BaseType::Function& target_func_type =
					this->context.getTypeManager().getFunction(target_func.typeID);

				if(target_func_type.isUnsafe && this->currently_in_unsafe() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
						instr.infix,
						"Call to unsafe math infix operator while not in an unsafe scope"
					);
					return Result::ERROR;
				}

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					rhs.value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					target_func_type.returnTypes[0].asTypeID(),
					sema::Expr(infix_overload_result.value())
				);
				return Result::SUCCESS;
			}

			if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::SHIFT){
				if(this->context.getTypeManager().isUnsignedIntegral(rhs_decayed_type_id) == false){
					auto infos = evo::SmallVector<Diagnostic::Info>();
					this->diagnostic_print_type_info(rhs.type_id.as<TypeInfo::ID>(), infos, "RHS type: ");
					this->emit_error(
						Diagnostic::Code::SEMA_MATH_INFIX_INVALID_RHS,
						instr.infix.rhs,
						std::format(
							"RHS of operator [{}] must be unsigned integral",
							this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
						),
						std::move(infos)
					);
					return Result::ERROR;
				}


				const uint64_t num_bits_rhs_type =
					this->context.getTypeManager().numBits(rhs_decayed_type_id);

				if(num_bits_rhs_type > 23){
					this->emit_error(
						Diagnostic::Code::SEMA_CANNOT_CONVERT_FLUID_VALUE,
						instr.infix.lhs,
						"Cannot implicitly convert this fluid value to the target type as the target type is invalid",
						evo::SmallVector<Diagnostic::Info>{
							Diagnostic::Info(std::format("Target type bit-width:   {}", num_bits_rhs_type)),
							Diagnostic::Info("Largest valid bit-width: 23"),
						}
					);
					return Result::ERROR;
				}

				const uint32_t expected_num_bits_lhs_type = uint32_t(1 << num_bits_rhs_type);

				const TypeInfo::ID expected_lhs_type = this->context.type_manager.getOrCreateTypeInfo(
					TypeInfo(
						this->context.type_manager.getOrCreatePrimitiveBaseType(
							Token::Kind::TYPE_UI_N, expected_num_bits_lhs_type
						)
					)
				);

				if(this->type_check<true, true>(
					expected_lhs_type,
					lhs,
					std::format(
						"LHS of [{}] operator",
						this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
					),
					instr.infix
				).ok == false){
					return Result::ERROR;
				}


			}else{
				if(this->type_check<true, true>(
					rhs_decayed_type_id,
					lhs,
					std::format(
						"LHS of [{}] operator",
						this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
					),
					instr.infix
				).ok == false){
					return Result::ERROR;
				}

				if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::MATH){
					if(
						this->context.getTypeManager().isIntegral(rhs_decayed_type_id) == false
						&& this->context.getTypeManager().isFloatingPoint(rhs_decayed_type_id) == false
					){
						auto infos = evo::SmallVector<Diagnostic::Info>();
						this->diagnostic_print_type_info(rhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: ");
						this->emit_error(
							Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
							instr.infix,
							"No matching operation for this type",
							std::move(infos)
						);
						return Result::ERROR;
					}
				
				}else if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::INTEGRAL_MATH){
					if(this->context.getTypeManager().isIntegral(rhs_decayed_type_id) == false){
						auto infos = evo::SmallVector<Diagnostic::Info>();
						this->diagnostic_print_type_info(rhs.type_id.as<TypeInfo::ID>(), infos, "Argument type: ");
						this->emit_error(
							Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
							instr.infix,
							"No matching operation for this type",
							std::move(infos)
						);
						return Result::ERROR;
					}
				}
			}

		}else{ // both lhs and rhs fluid
			if(lhs.getExpr().kind() != rhs.getExpr().kind()){
				this->emit_error(
					Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
					instr.infix,
					std::format(
						"LHS and RHS of operator [{}] must match fluid kind",
						this->source.getTokenBuffer()[instr.infix.opTokenID].kind()
					)
				);
				return Result::ERROR;
			}


			this->return_term_info(instr.output,
				this->comptime_infix_math(
					this->source.getTokenBuffer()[instr.infix.opTokenID].kind(),
					lhs.getExpr(),
					rhs.getExpr(),
					std::nullopt
				)
			);
			return Result::SUCCESS;
		}


		if constexpr(IS_COMPTIME){
			if constexpr(MATH_INFIX_KIND == Instruction::MathInfixKind::LOGICAL){
				const bool lhs_bool_value = this->context.sema_buffer.getBoolValue(lhs.getExpr().boolValueID()).value;
				const bool rhs_bool_value = this->context.sema_buffer.getBoolValue(rhs.getExpr().boolValueID()).value;

				const bool bool_value = [&](){
					if(this->source.getTokenBuffer()[instr.infix.opTokenID].kind() == Token::lookupKind("&&")){
						return lhs_bool_value & rhs_bool_value;

					}else{
						evo::debugAssert(
							this->source.getTokenBuffer()[instr.infix.opTokenID].kind() == Token::lookupKind("||"),
							"Unknown logical infix operator"
						);

						return lhs_bool_value | rhs_bool_value;
					}
				}();

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					TypeManager::getTypeBool(),
					sema::Expr(this->context.sema_buffer.createBoolValue(bool_value))
				);

			}else{
				this->return_term_info(instr.output,
					this->comptime_infix_math(
						this->source.getTokenBuffer()[instr.infix.opTokenID].kind(),
						lhs.getExpr(),
						rhs.getExpr(),
						this->context.type_manager.decayType<true, false>(lhs.type_id.as<TypeInfo::ID>())
					)
				);
			}
			return Result::SUCCESS;

		}else{
			auto resultant_type = std::optional<TypeInfo::ID>();

			const TypeInfo::ID lhs_decayed_type_id 

			=
				this->context.type_manager.decayType<false, false>(lhs.type_id.as<TypeInfo::ID>());

			const Token::Kind op_kind = this->source.getTokenBuffer()[instr.infix.opTokenID].kind();

			if(op_kind == Token::lookupKind("&&")){
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					lhs.value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					TypeManager::getTypeBool(),
					sema::Expr(this->context.sema_buffer.createLogicalAnd(lhs.getExpr(), rhs.getExpr()))
				);
				return Result::SUCCESS;

			}else if(op_kind == Token::lookupKind("||")){
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					lhs.value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					TypeManager::getTypeBool(),
					sema::Expr(this->context.sema_buffer.createLogicalOr(lhs.getExpr(), rhs.getExpr()))
				);
				return Result::SUCCESS;
			}


			const sema::TemplateIntrinsicFuncInstantiation::ID instantiation_id = [&](){
				switch(this->source.getTokenBuffer()[instr.infix.opTokenID].kind()){
					case Token::lookupKind("=="): {
						resultant_type = TypeManager::getTypeBool();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::EQ,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("!="): {
						resultant_type = TypeManager::getTypeBool();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::NEQ,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("<"): {
						resultant_type = TypeManager::getTypeBool();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::LT,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("<="): {
						resultant_type = TypeManager::getTypeBool();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::LTE,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind(">"): {
						resultant_type = TypeManager::getTypeBool();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::GT,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind(">="): {
						resultant_type = TypeManager::getTypeBool();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::GTE,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("&"): case Token::lookupKind("&="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::AND,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("|"): case Token::lookupKind("|="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::OR,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("^"): case Token::lookupKind("^="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::XOR,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("<<"): case Token::lookupKind("<<="): {
						const TypeInfo::ID rhs_decayed_type_id = 
							this->context.type_manager.decayType<false, false>(rhs.type_id.as<TypeInfo::ID>());

						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::SHL,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id, rhs_decayed_type_id, core::GenericValue(true)
							}
						);
					} break;

					case Token::lookupKind("<<|"): case Token::lookupKind("<<|="): {
						const TypeInfo::ID rhs_decayed_type_id = 
							this->context.type_manager.decayType<false, false>(rhs.type_id.as<TypeInfo::ID>());

						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::SHL_SAT,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id, rhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind(">>"): case Token::lookupKind(">>="): {
						const TypeInfo::ID rhs_decayed_type_id = 
							this->context.type_manager.decayType<false, false>(rhs.type_id.as<TypeInfo::ID>());

						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::SHR,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id, rhs_decayed_type_id, core::GenericValue(true)
							}
						);
					} break;

					case Token::lookupKind("+"): case Token::lookupKind("+="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						if(this->context.getTypeManager().isIntegral(lhs_decayed_type_id)){
							return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::ADD,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									lhs_decayed_type_id, core::GenericValue(false)
								}
							);
						}else{
							return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::FADD,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									lhs_decayed_type_id
								}
							);
						}
					} break;

					case Token::lookupKind("+%"): case Token::lookupKind("+%="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::ADD,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id, core::GenericValue(true)
							}
						);
					} break;

					case Token::lookupKind("+|"): case Token::lookupKind("+|="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::ADD_SAT,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("-"): case Token::lookupKind("-="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						if(this->context.getTypeManager().isIntegral(lhs_decayed_type_id)){
							return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::SUB,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									lhs_decayed_type_id, core::GenericValue(false)
								}
							);
						}else{
							return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::FSUB,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									lhs_decayed_type_id
								}
							);
						}
					} break;

					case Token::lookupKind("-%"): case Token::lookupKind("-%="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::SUB,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id, core::GenericValue(true)
							}
						);
					} break;

					case Token::lookupKind("-|"): case Token::lookupKind("-|="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::SUB_SAT,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("*"): case Token::lookupKind("*="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						if(this->context.getTypeManager().isIntegral(lhs_decayed_type_id)){
							return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::MUL,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									lhs_decayed_type_id, core::GenericValue(false)
								}
							);
						}else{
							return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::FMUL,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									lhs_decayed_type_id
								}
							);
						}
					} break;

					case Token::lookupKind("*%"): case Token::lookupKind("*%="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::MUL,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id, core::GenericValue(true)
							}
						);
					} break;

					case Token::lookupKind("*|"): case Token::lookupKind("*|="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::MUL_SAT,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					case Token::lookupKind("/"): case Token::lookupKind("/="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						if(this->context.getTypeManager().isIntegral(lhs_decayed_type_id)){
							return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::DIV,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									lhs_decayed_type_id, core::GenericValue(false)
								}
							);
						}else{
							return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
								TemplateIntrinsicFunc::Kind::FDIV,
								evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
									lhs_decayed_type_id
								}
							);
						}
					} break;

					case Token::lookupKind("%"): case Token::lookupKind("%="): {
						resultant_type = lhs.type_id.as<TypeInfo::ID>();

						return this->context.sema_buffer.createTemplateIntrinsicFuncInstantiation(
							TemplateIntrinsicFunc::Kind::REM,
							evo::SmallVector<evo::Variant<TypeInfo::VoidableID, core::GenericValue>>{
								lhs_decayed_type_id
							}
						);
					} break;

					default: {
						evo::debugFatalBreak("Invalid infix math operator");
					} break;
				}
			}();

			const sema::FuncCall::ID created_func_call_id = this->context.sema_buffer.createFuncCall(
				instantiation_id, evo::SmallVector<sema::Expr>{lhs.getExpr(), rhs.getExpr()}
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::EPHEMERAL,
				lhs.value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				*resultant_type,
				sema::Expr(created_func_call_id)
			);
			return Result::SUCCESS;
		}
	}


	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::instr_expr_accessor(const Instruction::Accessor<NEEDS_DEF>& instr) -> Result {
		const std::string_view rhs_ident_str = this->source.getTokenBuffer()[instr.rhs_ident].getString();
		const TermInfo& lhs = this->get_term_info(instr.lhs);

		if(lhs.type_id.is<Source::ID>()){
			return this->module_accessor<NEEDS_DEF>(instr, rhs_ident_str, lhs);

		}else if(lhs.type_id.is<ClangSource::ID>()){
			return this->clang_module_accessor<NEEDS_DEF>(instr, rhs_ident_str, lhs);

		}else if(lhs.type_id.is<TypeInfo::VoidableID>()){
			return this->type_accessor<NEEDS_DEF>(instr, rhs_ident_str, lhs);

		}else if(lhs.type_id.is<BuiltinModule::ID>()){
			return this->builtin_module_accessor<NEEDS_DEF>(instr, rhs_ident_str, lhs);
		}

		if(lhs.type_id.is<TypeInfo::ID>() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_ACCESSOR_LHS,
				instr.infix.lhs,
				"Accessor operator of this LHS is invalid"
			);
			return Result::ERROR;
		}

		if(
			lhs.value_state != TermInfo::ValueState::INIT
			&& lhs.value_state != TermInfo::ValueState::INITIALIZING
			&& lhs.value_state != TermInfo::ValueState::NOT_APPLICABLE
		){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
				instr.infix.lhs,
				"LHS of accessor operator must be initialized or initializing"
			);
			return Result::ERROR;
		}


		const TypeInfo::ID decayed_lhs_type_id =
			this->context.type_manager.decayType<true, false>(lhs.type_id.as<TypeInfo::ID>());
		const TypeInfo& decayed_lhs_type = this->context.getTypeManager().getTypeInfo(decayed_lhs_type_id);

		bool is_pointer = false;

		if(decayed_lhs_type.qualifiers().empty() == false){
			if(lhs.value_stage == TermInfo::ValueStage::COMPTIME){
				this->emit_error(
					Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
					instr.infix.lhs,
					"Accessor operator of this LHS is unimplemented"
				);
				return Result::ERROR;
			}else{
				if(decayed_lhs_type.qualifiers().size() > 1){
					if(
						decayed_lhs_type.qualifiers().back().isOptional == false
						&& decayed_lhs_type.qualifiers()[decayed_lhs_type.qualifiers().size() - 2].isOptional
					){
						return this->optional_accessor<NEEDS_DEF>(
							instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, true
						);
					}

					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_ACCESSOR_RHS,
						instr.infix.lhs,
						"Accessor operator of this LHS is invalid"
					);
					return Result::ERROR;
				}

				if(decayed_lhs_type.qualifiers().back().isOptional){
					return this->optional_accessor<NEEDS_DEF>(
						instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, false
					);
				}

				is_pointer = true;
			}
		}


		switch(decayed_lhs_type.baseTypeID().kind()){
			case BaseType::Kind::STRUCT: {
				return this->struct_accessor<NEEDS_DEF>(
					instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, is_pointer
				);
			} break;

			case BaseType::Kind::UNION: {
				return this->union_accessor<NEEDS_DEF>(
					instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, is_pointer
				);
			} break;

			case BaseType::Kind::ENUM: {
				return this->enum_accessor<NEEDS_DEF>(
					instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, is_pointer
				);
			} break;

			case BaseType::Kind::ARRAY: {
				return this->array_accessor<NEEDS_DEF>(
					instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, is_pointer
				);
			} break;

			case BaseType::Kind::ARRAY_REF: {
				return this->array_ref_accessor<NEEDS_DEF>(
					instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, is_pointer
				);
			} break;

			case BaseType::Kind::POLY_INTERFACE_REF: {
				return this->interface_accessor<NEEDS_DEF>(
					instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, true
				);
			} break;

			case BaseType::Kind::INTERFACE_MAP: {
				return this->interface_accessor<NEEDS_DEF>(
					instr, rhs_ident_str, lhs, decayed_lhs_type_id, decayed_lhs_type, false
				);
			} break;

			default: {
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ACCESSOR_LHS,
					instr.infix.lhs,
					"Accessor operator of this LHS is invalid"
				);
				return Result::ERROR;
			} break;
		}

	}



	auto SemanticAnalyzer::instr_primitive_type(const Instruction::PrimitiveType& instr) -> Result {
		auto base_type = std::optional<BaseType::ID>();
		auto qualifiers = evo::SmallVector<TypeInfo::Qualifier>();

		const Token::ID primitive_type_token_id = ASTBuffer::getPrimitiveType(instr.ast_type.base);
		const Token& primitive_type_token = this->source.getTokenBuffer()[primitive_type_token_id];

		switch(primitive_type_token.kind()){
			case Token::Kind::TYPE_VOID: {
				if(instr.ast_type.qualifiers.empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_VOID_WITH_QUALIFIERS,
						instr.ast_type.base,
						"Type \"Void\" cannot have qualifiers"
					);
					return Result::ERROR;
				}
				this->return_type(instr.output, TypeInfo::VoidableID::Void());
				return Result::SUCCESS;
			} break;

			case Token::Kind::TYPE_INT:           case Token::Kind::TYPE_ISIZE:        case Token::Kind::TYPE_UINT:
			case Token::Kind::TYPE_USIZE:         case Token::Kind::TYPE_F32:          case Token::Kind::TYPE_F64:
			case Token::Kind::TYPE_BYTE:          case Token::Kind::TYPE_BOOL:         case Token::Kind::TYPE_CHAR:
			case Token::Kind::TYPE_RAWPTR:        case Token::Kind::TYPE_TYPEID:       case Token::Kind::TYPE_C_WCHAR:
			case Token::Kind::TYPE_C_SHORT:       case Token::Kind::TYPE_C_USHORT:     case Token::Kind::TYPE_C_INT:
			case Token::Kind::TYPE_C_UINT:        case Token::Kind::TYPE_C_LONG:       case Token::Kind::TYPE_C_ULONG:
			case Token::Kind::TYPE_C_LONG_LONG:   case Token::Kind::TYPE_C_ULONG_LONG:
			case Token::Kind::TYPE_C_LONG_DOUBLE: {
				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(primitive_type_token.kind());
			} break;

			case Token::Kind::TYPE_I_N: case Token::Kind::TYPE_UI_N: {
				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(
					primitive_type_token.kind(), primitive_type_token.getBitWidth()
				);
			} break;


			case Token::Kind::TYPE_F16: {
				// TODO(FUTURE): not supported on WASM
				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(primitive_type_token.kind());
			} break;

			case Token::Kind::TYPE_BF16: {
				// TODO(FUTURE): not supported on WASM, SPIR
				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(primitive_type_token.kind());
			} break;

			case Token::Kind::TYPE_F80: {
				if(this->context.getConfig().target.architecture != core::Target::Architecture::X86_64){
					// yes, the compier only supports x86_64 right now (v0.0.208.0), but here for future proofing
					this->emit_error(
						Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
						instr.ast_type,
						"Type `F80` is currenlty unimplemented on this platform"
					);
					return Result::ERROR;
				}

				if(this->get_package().warn.experimentalF80){
					this->emit_warning(
						Diagnostic::Code::SEMA_WARN_EXPERIMENTAL_F80,
						instr.ast_type,
						"Type `F80` is experimental, and may not work as expected"
					);
				}

				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(primitive_type_token.kind());
			} break;

			case Token::Kind::TYPE_F128: {
				this->emit_error(
					Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
					instr.ast_type,
					"Type `F128` is currenlty unimplemented"
				);
				return Result::ERROR;
			} break;


			case Token::Kind::TYPE_TYPE: {
				this->emit_error(
					Diagnostic::Code::SEMA_GENERIC_TYPE_NOT_IN_TEMPLATE_PACK_DECL,
					instr.ast_type,
					"Type `Type` may only be used in a template pack declaration"
				);
				return Result::ERROR;
			} break;

			default: {
				evo::debugFatalBreak("Unknown or unsupported PrimitiveType: {}", primitive_type_token.kind());
			} break;
		}

		evo::debugAssert(base_type.has_value(), "Base type was not set");

		qualifiers.reserve(qualifiers.size() + instr.ast_type.qualifiers.size());
		for(const AST::Type::Qualifier& qualifier : instr.ast_type.qualifiers){
			qualifiers.emplace_back(qualifier.isPtr, qualifier.isMut, qualifier.isUninit, qualifier.isOptional);
		}

		if(this->check_type_qualifiers(qualifiers, instr.ast_type).isError()){ return Result::ERROR; }

		this->return_type(
			instr.output,
			TypeInfo::VoidableID(
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(*base_type, std::move(qualifiers)))
			)
		);
		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::instr_primitive_type_term(const Instruction::PrimitiveTypeTerm& instr) -> Result {
		auto base_type = std::optional<BaseType::ID>();
		auto qualifiers = evo::SmallVector<TypeInfo::Qualifier>();

		const Token::ID primitive_type_token_id = ASTBuffer::getPrimitiveType(instr.ast_type.base);
		const Token& primitive_type_token = this->source.getTokenBuffer()[primitive_type_token_id];

		switch(primitive_type_token.kind()){
			case Token::Kind::TYPE_VOID: {
				if(instr.ast_type.qualifiers.empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_VOID_WITH_QUALIFIERS,
						instr.ast_type.base,
						"Type \"Void\" cannot have qualifiers"
					);
					return Result::ERROR;
				}
				this->return_term_info(instr.output, TermInfo::ValueCategory::TYPE, TypeInfo::VoidableID::Void());
				return Result::SUCCESS;
			} break;

			case Token::Kind::TYPE_INT:           case Token::Kind::TYPE_ISIZE:        case Token::Kind::TYPE_UINT:
			case Token::Kind::TYPE_USIZE:         case Token::Kind::TYPE_F32:          case Token::Kind::TYPE_F64:
			case Token::Kind::TYPE_BYTE:          case Token::Kind::TYPE_BOOL:         case Token::Kind::TYPE_CHAR:
			case Token::Kind::TYPE_RAWPTR:        case Token::Kind::TYPE_TYPEID:       case Token::Kind::TYPE_C_WCHAR:
			case Token::Kind::TYPE_C_SHORT:       case Token::Kind::TYPE_C_USHORT:     case Token::Kind::TYPE_C_INT:
			case Token::Kind::TYPE_C_UINT:        case Token::Kind::TYPE_C_LONG:       case Token::Kind::TYPE_C_ULONG:
			case Token::Kind::TYPE_C_LONG_LONG:   case Token::Kind::TYPE_C_ULONG_LONG:
			case Token::Kind::TYPE_C_LONG_DOUBLE: {
				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(primitive_type_token.kind());
			} break;

			case Token::Kind::TYPE_I_N: case Token::Kind::TYPE_UI_N: {
				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(
					primitive_type_token.kind(), primitive_type_token.getBitWidth()
				);
			} break;


			case Token::Kind::TYPE_F16: {
				// TODO(FUTURE): not supported on WASM
				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(primitive_type_token.kind());
			} break;

			case Token::Kind::TYPE_BF16: {
				// TODO(FUTURE): not supported on WASM, SPIR
				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(primitive_type_token.kind());
			} break;

			case Token::Kind::TYPE_F80: {
				if(this->context.getConfig().target.architecture != core::Target::Architecture::X86_64){
					// yes, the compier only supports x86_64 right now (v0.0.208.0), but here for future proofing
					this->emit_error(
						Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
						instr.ast_type,
						"Type `F80` is currenlty unimplemented on this platform"
					);
					return Result::ERROR;
				}

				if(this->get_package().warn.experimentalF80){
					this->emit_warning(
						Diagnostic::Code::SEMA_WARN_EXPERIMENTAL_F80,
						instr.ast_type,
						"Type `F80` is experimental, and may not work as expected"
					);
				}

				base_type = this->context.type_manager.getOrCreatePrimitiveBaseType(primitive_type_token.kind());
			} break;

			case Token::Kind::TYPE_F128: {
				this->emit_error(
					Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
					instr.ast_type,
					"Type `F128` is currenlty unimplemented"
				);
				return Result::ERROR;
			} break;


			case Token::Kind::TYPE_TYPE: {
				this->emit_error(
					Diagnostic::Code::SEMA_GENERIC_TYPE_NOT_IN_TEMPLATE_PACK_DECL,
					instr.ast_type,
					"Type `Type` may only be used in a template pack declaration"
				);
				return Result::ERROR;
			} break;

			default: {
				evo::debugFatalBreak("Unknown or unsupported PrimitiveType: {}", primitive_type_token.kind());
			} break;
		}

		evo::debugAssert(base_type.has_value(), "Base type was not set");

		qualifiers.reserve(qualifiers.size() + instr.ast_type.qualifiers.size());
		for(const AST::Type::Qualifier& qualifier : instr.ast_type.qualifiers){
			qualifiers.emplace_back(qualifier.isPtr, qualifier.isMut, qualifier.isUninit, qualifier.isOptional);
		}

		if(this->check_type_qualifiers(qualifiers, instr.ast_type).isError()){ return Result::ERROR; }

		this->return_term_info(
			instr.output,
			TermInfo::ValueCategory::TYPE,
			TypeInfo::VoidableID(
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(*base_type, std::move(qualifiers)))
			)
		);
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_array_type(const Instruction::ArrayType& instr) -> Result {
		const TypeInfo::VoidableID elem_type = this->get_type(instr.elem_type);

		if(elem_type.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_ARRAY_ELEM_TYPE_VOID,
				instr.array_type.elemType,
				"Element type of an array type cannot be type `Void`"
			);
			return Result::ERROR;
		}

		const bool is_deducer = [&](){
			for(const SymbolProc::TermInfoID& length_term_info_id : instr.dimensions){
				if(this->get_term_info(length_term_info_id).value_category == TermInfo::ValueCategory::EXPR_DEDUCER){
					return true;
				}
			}

			if(instr.terminator.has_value() == false){ return false; }
			return this->get_term_info(*instr.terminator).value_category == TermInfo::ValueCategory::EXPR_DEDUCER;
		}();


		if(is_deducer){
			auto dimensions = evo::SmallVector<BaseType::ArrayDeducer::Dimension>();
			dimensions.reserve(instr.dimensions.size());

			for(size_t i = 0; const SymbolProc::TermInfoID& length_term_info_id : instr.dimensions){
				TermInfo& length_term_info = this->get_term_info(length_term_info_id);

				if(length_term_info.value_category == TermInfo::ValueCategory::EXPR_DEDUCER){
					dimensions.emplace_back(length_term_info.type_id.as<TermInfo::ExprDeducerType>().deducer_token_id);

				}else{
					if(this->type_check<true, true>(
						TypeManager::getTypeUSize(),
						length_term_info,
						"Array dimension",
						*instr.array_type.dimensions[i]
					).ok == false){
						return Result::ERROR;
					}

					dimensions.emplace_back(
						static_cast<uint64_t>(
							this->context.getSemaBuffer().getIntValue(length_term_info.getExpr().intValueID()).value
						)
					);

				}

				i += 1;
			}


			auto terminator = evo::Variant<std::monostate, core::GenericValue, Token::ID>();
			if(instr.terminator.has_value()){
				TermInfo& terminator_term_info = this->get_term_info(*instr.terminator);

				if(terminator_term_info.value_category == TermInfo::ValueCategory::EXPR_DEDUCER){
					terminator = terminator_term_info.type_id.as<TermInfo::ExprDeducerType>().deducer_token_id;
					
				}else{
					if(this->type_check<true, true>(
						elem_type.asTypeID(), terminator_term_info, "Array terminator", *instr.array_type.terminator
					).ok == false){
						return Result::ERROR;
					}

					terminator = this->sema_expr_to_generic_value(terminator_term_info.getExpr());
				}
			}


			const BaseType::ID array_deducer_type = this->context.type_manager.getOrCreateArrayDeducer(
				BaseType::ArrayDeducer(
					this->source.getID(), elem_type.asTypeID(), std::move(dimensions), std::move(terminator)
				)
			);


			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TYPE,
				TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(array_deducer_type)))
			);
			return Result::SUCCESS;
			
		}else{
			auto dimensions = evo::SmallVector<uint64_t>();
			dimensions.reserve(instr.dimensions.size());
			for(size_t i = 0; const SymbolProc::TermInfoID& length_term_info_id : instr.dimensions){
				TermInfo& length_term_info = this->get_term_info(length_term_info_id);

				if(this->type_check<true, true>(
					TypeManager::getTypeUSize(), length_term_info, "Array dimension", *instr.array_type.dimensions[i]
				).ok == false){
					return Result::ERROR;
				}

				dimensions.emplace_back(
					static_cast<uint64_t>(
						this->context.getSemaBuffer().getIntValue(length_term_info.getExpr().intValueID()).value
					)
				);

				i += 1;
			}


			auto terminator = std::optional<core::GenericValue>();
			if(instr.terminator.has_value()){
				TermInfo& terminator_term_info = this->get_term_info(*instr.terminator);

				if(this->type_check<true, true>(
					elem_type.asTypeID(), terminator_term_info, "Array terminator", *instr.array_type.terminator
				).ok == false){
					return Result::ERROR;
				}

				terminator.emplace(this->sema_expr_to_generic_value(terminator_term_info.getExpr()));
			}


			const BaseType::ID array_type = this->context.type_manager.getOrCreateArray(
				BaseType::Array(elem_type.asTypeID(), std::move(dimensions), std::move(terminator))
			);


			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TYPE,
				TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(array_type)))
			);
			return Result::SUCCESS;
		}
	}


	auto SemanticAnalyzer::instr_array_ref(const Instruction::ArrayRef& instr) -> Result {
		const TypeInfo::VoidableID elem_type = this->get_type(instr.elem_type);

		if(elem_type.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_ARRAY_ELEM_TYPE_VOID,
				instr.array_type.elemType,
				"Element type of an array type cannot be type `Void`"
			);
			return Result::ERROR;
		}


		const bool is_deducer = [&](){
			if(this->context.getTypeManager().isTypeDeducer(elem_type.asTypeID())){ return true; }

			for(const std::optional<SymbolProc::TermInfoID> length_term_info_id : instr.dimensions){
				if(length_term_info_id.has_value() == false){ continue; }

				if(this->get_term_info(*length_term_info_id).value_category == TermInfo::ValueCategory::EXPR_DEDUCER){
					return true;
				}
			}

			if(instr.terminator.has_value() == false){ return false; }
			return this->get_term_info(*instr.terminator).value_category == TermInfo::ValueCategory::EXPR_DEDUCER;
		}();


		if(is_deducer){
			auto dimensions = evo::SmallVector<BaseType::ArrayRefDeducer::Dimension>();
			dimensions.reserve(instr.dimensions.size());
			for(size_t i = 0; const std::optional<SymbolProc::TermInfoID>& length_term_info_id : instr.dimensions){
				if(length_term_info_id.has_value()){
					TermInfo& length_term_info = this->get_term_info(*length_term_info_id);

					if(length_term_info.value_category == TermInfo::ValueCategory::EXPR_DEDUCER){
						dimensions.emplace_back(
							length_term_info.type_id.as<TermInfo::ExprDeducerType>().deducer_token_id
						);

					}else{

						if(this->type_check<true, true>(
							TypeManager::getTypeUSize(),
							length_term_info,
							"Array reference dimension",
							*instr.array_type.dimensions[i]
						).ok == false){
							return Result::ERROR;
						}

						dimensions.emplace_back(
							static_cast<uint64_t>(
								this->context.getSemaBuffer().getIntValue(length_term_info.getExpr().intValueID()).value
							)
						);
					}

				}else{
					dimensions.emplace_back(BaseType::ArrayRefDeducer::Dimension::ptr());
				}

				i += 1;
			}


			auto terminator = evo::Variant<std::monostate, core::GenericValue, Token::ID>();
			if(instr.terminator.has_value()){
				TermInfo& terminator_term_info = this->get_term_info(*instr.terminator);

				if(terminator_term_info.value_category == TermInfo::ValueCategory::EXPR_DEDUCER){
					terminator = terminator_term_info.type_id.as<TermInfo::ExprDeducerType>().deducer_token_id;

				}else{
					if(this->type_check<true, true>(
						elem_type.asTypeID(),
						terminator_term_info,
						"Array reference terminator",
						*instr.array_type.terminator
					).ok == false){
						return Result::ERROR;
					}

					terminator = this->sema_expr_to_generic_value(terminator_term_info.getExpr());
				}
			}


			const BaseType::ID array_ref_type = this->context.type_manager.getOrCreateArrayRefDeducer(
				BaseType::ArrayRefDeducer(
					this->source.getID(),
					elem_type.asTypeID(),
					std::move(dimensions),
					std::move(terminator),
					*instr.array_type.refIsMut
				)
			);


			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TYPE,
				TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(array_ref_type)))
			);
			return Result::SUCCESS;

		}else{
			auto dimensions = evo::SmallVector<BaseType::ArrayRef::Dimension>();
			dimensions.reserve(instr.dimensions.size());
			for(size_t i = 0; const std::optional<SymbolProc::TermInfoID>& length_term_info_id : instr.dimensions){
				if(length_term_info_id.has_value()){
					TermInfo& length_term_info = this->get_term_info(*length_term_info_id);

					if(this->type_check<true, true>(
						TypeManager::getTypeUSize(),
						length_term_info,
						"Array reference dimension",
						*instr.array_type.dimensions[i]
					).ok == false){
						return Result::ERROR;
					}

					dimensions.emplace_back(
						static_cast<uint64_t>(
							this->context.getSemaBuffer().getIntValue(length_term_info.getExpr().intValueID()).value
						)
					);

				}else{
					dimensions.emplace_back(BaseType::ArrayRef::Dimension::ptr());
				}

				i += 1;
			}


			auto terminator = std::optional<core::GenericValue>();
			if(instr.terminator.has_value()){
				TermInfo& terminator_term_info = this->get_term_info(*instr.terminator);	

				if(this->type_check<true, true>(
					elem_type.asTypeID(),
					terminator_term_info,
					"Array reference terminator",
					*instr.array_type.terminator
				).ok == false){
					return Result::ERROR;
				}

				terminator.emplace(this->sema_expr_to_generic_value(terminator_term_info.getExpr()));
			}


			const BaseType::ID array_ref_type = this->context.type_manager.getOrCreateArrayRef(
				BaseType::ArrayRef(
					elem_type.asTypeID(), std::move(dimensions), std::move(terminator), *instr.array_type.refIsMut
				)
			);


			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TYPE,
				TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(array_ref_type)))
			);
			return Result::SUCCESS;
		}
	}




	auto SemanticAnalyzer::instr_interface_map(const Instruction::InterfaceMap& instr) -> Result {
		const TypeInfo::VoidableID got_interface_type_id = this->get_type(instr.interface);

		if(got_interface_type_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_INTERFACE_MAP_NOT_INTERFACE,
				instr.interface_map.interface,
				"Target interface of interface map must be an interface"
			);
			return Result::ERROR;
		}

		const TypeInfo& got_interface_type =
			this->context.getTypeManager().getTypeInfo(got_interface_type_id.asTypeID());

		if(got_interface_type.baseTypeID().kind() != BaseType::Kind::INTERFACE){
			this->emit_error(
				Diagnostic::Code::SEMA_INTERFACE_MAP_NOT_INTERFACE,
				instr.interface_map.interface,
				"Target interface of interface map must be an interface"
			);
			return Result::ERROR;
		}

		if(got_interface_type.qualifiers().empty() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_INTERFACE_MAP_NOT_INTERFACE,
				instr.interface_map.interface,
				"Target interface of interface map must be an interface",
				Diagnostic::Info("Note: Target interface type cannot have qualifiers")
			);
			return Result::ERROR;
		}


		BaseType::Interface& got_interface =
			this->context.type_manager.getInterface(got_interface_type.baseTypeID().interfaceID());


		if(instr.base_type.has_value() == false){
			if(got_interface.isPolymorphic == false){
				this->emit_error(
					Diagnostic::Code::SEMA_POLY_INTERFACE_MAP_NOT_POLY_INTERFACE,
					instr.interface_map.interface,
					"Target interface of polymorphic interface map must be a polymorphic interface"
				);
				return Result::ERROR;
			}


			const bool is_mut = [&]() -> bool {
				const Token& base_token =
					this->source.getTokenBuffer()[instr.interface_map.underlyingType.as<Token::ID>()];
				return base_token.kind() == Token::lookupKind("*mut");
			}();


			const BaseType::ID created_base_type_id = this->context.type_manager.getOrCreatePolyInterfaceRef(
				BaseType::PolyInterfaceRef(got_interface_type.baseTypeID().interfaceID(), is_mut)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TYPE,
				TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(created_base_type_id)))
			);
			return Result::SUCCESS;
		}

		
		const TypeInfo::VoidableID base_type_id = this->get_type(*instr.base_type);

		if(base_type_id.isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_INTERFACE_MAP_TYPE_DOESNT_IMPL_INTERFACE,
				instr.interface_map,
				"Base type of interface map doesn't implement the target interface"
			);
			return Result::ERROR;
		}


		if(this->context.getTypeManager().isTypeDeducer(base_type_id.asTypeID())){
			// do nothing
		}else{
			const evo::Expected<bool, Result> implements_result = this->type_implements_interface(
				got_interface, base_type_id.asTypeID(), this->get_location(instr.interface_map)
			);

			if(implements_result.has_value()){
				if(implements_result.value() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_MAP_TYPE_DOESNT_IMPL_INTERFACE,
						instr.interface_map,
						"Base type of interface map doesn't implement the target interface"
					);
					return Result::ERROR;
				}
			}else{
				return implements_result.error();
			}
		}

		const BaseType::ID created_base_type_id = this->context.type_manager.getOrCreateInterfaceMap(
			BaseType::InterfaceMap(
				base_type_id.asTypeID(), got_interface_type.baseTypeID().interfaceID()
			)
		);

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::TYPE,
			TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(created_base_type_id)))
		);
		return Result::SUCCESS;
	}



	auto SemanticAnalyzer::instr_type_id_converter(const Instruction::TypeIDConverter& instr) -> Result {
		TermInfo& type_id_expr = this->get_term_info(instr.expr);

		if(this->type_check<true, true>(
			TypeManager::getTypeTypeID(), type_id_expr, "Type ID converter", instr.type_id_converter.expr
		).ok == false){
			return Result::ERROR;
		}

		const sema::IntValue& int_value =
			this->context.getSemaBuffer().getIntValue(type_id_expr.getExpr().intValueID());

		const TypeInfo::ID target_type_id = TypeInfo::ID(uint32_t(int_value.value));

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::TYPE,
			TypeInfo::VoidableID(target_type_id)
		);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_qualified_type(const Instruction::QualifiedType& instr) -> Result {
		auto base_type_id = std::optional<TypeInfo::ID>();
		const TermInfo& term_info = this->get_term_info(instr.base_type);
		switch(term_info.value_category){
			case TermInfo::ValueCategory::TYPE: {
				evo::debugAssert(
					this->get_term_info(instr.base_type).type_id.as<TypeInfo::VoidableID>().isVoid() == false,
					"`Void` cannot be a qualified type"
				);
				base_type_id = term_info.type_id.as<TypeInfo::VoidableID>().asTypeID();
			} break;

			case TermInfo::ValueCategory::TEMPLATE_TYPE: case TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED: {
				this->emit_error(
					Diagnostic::Code::SEMA_TEMPLATE_TYPE_NOT_INSTANTIATED,
					instr.ast_type.base,
					"Templated type needs to be instantiated",
					Diagnostic::Info(
						"Type declared here:", this->get_location(term_info.type_id.as<sema::TemplatedStruct::ID>())
					)
				);
				return Result::ERROR;
			} break;

			case TermInfo::ValueCategory::TEMPLATE_DECL_INSTANTIATION_TYPE: {
				this->return_type(instr.output, TypeInfo::VoidableID(TypeInfo::ID::createTemplateDeclInstantiation()));
				return Result::SUCCESS;
			} break;

			default: {
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_TYPE,
					instr.ast_type.base,
					"Invalid base type"
				);
				return Result::ERROR;
			} break;
		}

		const TypeInfo& base_type = this->context.getTypeManager().getTypeInfo(*base_type_id);

		auto qualifiers = evo::SmallVector<TypeInfo::Qualifier>(
			base_type.qualifiers().begin(), base_type.qualifiers().end()
		);
		qualifiers.reserve(qualifiers.size() + instr.ast_type.qualifiers.size());
		for(const AST::Type::Qualifier& qualifier : instr.ast_type.qualifiers){
			qualifiers.emplace_back(qualifier.isPtr, qualifier.isMut, qualifier.isUninit, qualifier.isOptional);
		}

		if(this->check_type_qualifiers(qualifiers, instr.ast_type).isError()){ return Result::ERROR; }


		this->return_type(
			instr.output,
			TypeInfo::VoidableID(
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(base_type.baseTypeID(), std::move(qualifiers)))
			)
		);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_qualified_type_term(const Instruction::QualifiedTypeTerm& instr) -> Result {
		auto base_type_id = std::optional<TypeInfo::ID>();
		const TermInfo& term_info = this->get_term_info(instr.base_type);
		switch(term_info.value_category){
			case TermInfo::ValueCategory::TYPE: {
				evo::debugAssert(
					this->get_term_info(instr.base_type).type_id.as<TypeInfo::VoidableID>().isVoid() == false,
					"`Void` cannot be a qualified type"
				);
				base_type_id = term_info.type_id.as<TypeInfo::VoidableID>().asTypeID();
			} break;

			case TermInfo::ValueCategory::TEMPLATE_TYPE: case TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED: {
				if(instr.ast_type.qualifiers.empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_TYPE,
						instr.ast_type.base,
						"Invalid base type",
						Diagnostic::Info("NOTE: non-instantiated struct templates cannot have qualifiers")
					);
					return Result::ERROR;
				}

				this->return_term_info(instr.output, term_info);
				return Result::SUCCESS;
			} break;

			case TermInfo::ValueCategory::TEMPLATE_DECL_INSTANTIATION_TYPE: {
				this->return_term_info(
					instr.output,
					TermInfo::ValueCategory::TYPE,
					TypeInfo::VoidableID(TypeInfo::ID::createTemplateDeclInstantiation())
				);
				return Result::SUCCESS;
			} break;

			default: {
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_TYPE,
					instr.ast_type.base,
					"Invalid base type"
				);
				return Result::ERROR;
			} break;
		}

		const TypeInfo& base_type = this->context.getTypeManager().getTypeInfo(*base_type_id);

		auto qualifiers = evo::SmallVector<TypeInfo::Qualifier>(
			base_type.qualifiers().begin(), base_type.qualifiers().end()
		);
		qualifiers.reserve(qualifiers.size() + instr.ast_type.qualifiers.size());
		for(const AST::Type::Qualifier& qualifier : instr.ast_type.qualifiers){
			qualifiers.emplace_back(qualifier.isPtr, qualifier.isMut, qualifier.isUninit, qualifier.isOptional);
		}

		if(this->check_type_qualifiers(qualifiers, instr.ast_type).isError()){ return Result::ERROR; }


		this->return_term_info(
			instr.output,
			TermInfo::ValueCategory::TYPE,
			TypeInfo::VoidableID(
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(base_type.baseTypeID(), std::move(qualifiers)))
			)
		);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_base_type_ident(const Instruction::BaseTypeIdent& instr) -> Result {
		const evo::Expected<TermInfo, Result> lookup_ident_result = this->lookup_ident_impl<true>(instr.ident);
		if(lookup_ident_result.has_value() == false){ return lookup_ident_result.error(); }

		this->return_term_info(instr.output, lookup_ident_result.value());
		return Result::SUCCESS;
	}






	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::instr_ident(const Instruction::Ident<NEEDS_DEF>& instr) -> Result {
		const evo::Expected<TermInfo, Result> lookup_ident_result = this->lookup_ident_impl<NEEDS_DEF>(instr.ident);
		if(lookup_ident_result.has_value() == false){ return lookup_ident_result.error(); }

		if(
			this->scope.inEncapsulatingSymbol()
			&& this->scope.getCurrentEncapsulatingSymbol().is<sema::Func::ID>()
			&& this->expr_in_func_is_valid_value_stage(lookup_ident_result.value(), instr.ident) == false
		){
			return Result::ERROR;
		}

		this->return_term_info(instr.output, std::move(lookup_ident_result.value()));
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_intrinsic(const Instruction::Intrinsic& instr) -> Result {
		const std::string_view intrinsic_name = this->source.getTokenBuffer()[instr.intrinsic].getString();


		const std::optional<IntrinsicFunc::Kind> intrinsic_kind = IntrinsicFunc::lookupKind(intrinsic_name);
		if(intrinsic_kind.has_value()){
			if(*intrinsic_kind == IntrinsicFunc::Kind::PANIC){
				const bool need_to_wait = this->context.symbol_proc_manager.waitOnSymbolProcOfBuiltinSymbolIfNeeded(
					SymbolProcManager::constevalLookupBuiltinSymbolKind("panic"),
					this->symbol_proc_id,
					this->context
				);
				if(need_to_wait){ return Result::NEED_TO_WAIT; }

				this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(*this->context.panic);
			}

			const TypeInfo::ID intrinsic_type = this->context.getIntrinsicFuncInfo(*intrinsic_kind).typeID;

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::INTRINSIC_FUNC,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				intrinsic_type,
				sema::Expr(*intrinsic_kind)
			);
			return Result::SUCCESS;
		}

		const std::optional<TemplateIntrinsicFunc::Kind> template_intrinsic_kind = 
			TemplateIntrinsicFunc::lookupKind(intrinsic_name);
		if(template_intrinsic_kind.has_value()){
			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TEMPLATE_INTRINSIC_FUNC, *template_intrinsic_kind
			);
			return Result::SUCCESS;
		}


		if(intrinsic_name == "pthr"){
			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_MODULE, BuiltinModule::ID::PTHR
			);
			return Result::SUCCESS;
			
		}else if(intrinsic_name == "build"){
			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_MODULE, BuiltinModule::ID::BUILD
			);
			return Result::SUCCESS;

		}


		this->emit_error(
			Diagnostic::Code::SEMA_INTRINSIC_DOESNT_EXIST,
			instr.intrinsic,
			std::format("Intrinsic \"@{}\" doesn't exist", intrinsic_name)
		);
		return Result::ERROR;
	}



	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::instr_type_this(const Instruction::TypeThis<NEEDS_DEF>& instr) -> Result {
		const std::optional<EncapsulatingSymbolID> current_type_scope = 
			this->scope.getCurrentTypeScopeIfExists();

		if(current_type_scope.has_value() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_TYPE_THIS_NOT_IN_VALID_TYPE_SCOPE,
				instr.type_this,
				"Type \"This\" not in valid type scope"
			);
			return Result::ERROR;
		}

		if(current_type_scope->is<BaseType::Interface::ID>()){
			this->emit_error(
				Diagnostic::Code::SEMA_TYPE_THIS_NOT_IN_VALID_TYPE_SCOPE,
				instr.type_this,
				"Type \"This\" not in valid type scope",
				Diagnostic::Info("\"This\" cannot be used within an interface")
			);
			return Result::ERROR;
		}


		if(current_type_scope->is<EncapsulatingSymbolID::InterfaceImplInfo>()){
			this->return_term_info(instr.output,
				TermInfo::ValueCategory::TYPE,
				TypeInfo::VoidableID(current_type_scope->as<EncapsulatingSymbolID::InterfaceImplInfo>().targetTypeID)
			);
			return Result::SUCCESS;
		}

		const TypeInfo::ID current_type_id = this->context.type_manager.getOrCreateTypeInfo(
			TypeInfo(BaseType::ID(current_type_scope->as<BaseType::Struct::ID>()))
		);

		if constexpr(NEEDS_DEF){
			const BaseType::Struct& struct_type = 
				this->context.getTypeManager().getStruct(current_type_scope->as<BaseType::Struct::ID>());

			if(struct_type.defCompleted.load(std::memory_order::relaxed) == false){
				SymbolProc::ID struct_type_symbol_proc_id =
					*this->context.symbol_proc_manager.getTypeSymbolProc(current_type_id);

				SymbolProc& struct_type_symbol_proc =
					this->context.symbol_proc_manager.getSymbolProc(struct_type_symbol_proc_id);

				const SymbolProc::WaitOnResult wait_on_result = struct_type_symbol_proc.waitOnDefIfNeeded(
					this->symbol_proc_id, this->context, struct_type_symbol_proc_id
				);
					
				switch(wait_on_result){
					case SymbolProc::WaitOnResult::NOT_NEEDED:  break;
					case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
						this->context.symbol_proc_manager.symbol_proc_unsuspended();
						this->context.add_task_to_work_manager(struct_type_symbol_proc_id);
						[[fallthrough]];
					}
					case SymbolProc::WaitOnResult::WAITING:     return Result::NEED_TO_WAIT;
					case SymbolProc::WaitOnResult::WAS_ERRORED: return Result::ERROR;

					case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:
						evo::debugFatalBreak("Should be impossible");

					case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED: return Result::ERROR;
				}
			}
		}

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::TYPE,
			TypeInfo::VoidableID(current_type_id)
		);
		return Result::SUCCESS;
	}


	auto SemanticAnalyzer::instr_literal(const Instruction::Literal& instr) -> Result {
		const Token& literal_token = this->source.getTokenBuffer()[instr.literal];
		switch(literal_token.kind()){
			case Token::Kind::LITERAL_INT: {
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL_FLUID,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					TermInfo::FluidType{},
					sema::Expr(this->context.sema_buffer.createIntValue(
						core::GenericInt(256, literal_token.getInt()), std::nullopt
					))
				);
				return Result::SUCCESS;
			} break;

			case Token::Kind::LITERAL_FLOAT: {
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL_FLUID,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					TermInfo::FluidType{},
					sema::Expr(this->context.sema_buffer.createFloatValue(
						core::GenericFloat::createF128(literal_token.getFloat()), std::nullopt
					))
				);
				return Result::SUCCESS;
			} break;

			case Token::Kind::LITERAL_BOOL: {
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					this->context.getTypeManager().getTypeBool(),
					sema::Expr(this->context.sema_buffer.createBoolValue(literal_token.getBool()))
				);
				return Result::SUCCESS;
			} break;

			case Token::Kind::LITERAL_STRING: {
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					this->context.type_manager.getOrCreateTypeInfo(
						TypeInfo(
							this->context.type_manager.getOrCreateArray(
								BaseType::Array(
									this->context.getTypeManager().getTypeChar(),
									evo::SmallVector<uint64_t>{literal_token.getString().size()},
									core::GenericValue('\0')
								)
							),
							evo::SmallVector<TypeInfo::Qualifier>{TypeInfo::Qualifier::createPtr()}
						)
					),
					sema::Expr(this->context.sema_buffer.createStringValue(std::string(literal_token.getString())))
				);
				return Result::SUCCESS;
			} break;

			case Token::Kind::LITERAL_CHAR: {
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					this->context.getTypeManager().getTypeChar(),
					sema::Expr(this->context.sema_buffer.createCharValue(literal_token.getChar()))
				);
				return Result::SUCCESS;
			} break;

			case Token::Kind::KEYWORD_NULL: {
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::NULL_VALUE,
					TermInfo::ValueStage::COMPTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					TermInfo::NullType(),
					sema::Expr(this->context.sema_buffer.createNull(instr.literal))
				);
				return Result::SUCCESS;
			} break;

			default: evo::debugFatalBreak("Not a valid literal");
		}
	}


	auto SemanticAnalyzer::instr_uninit(const Instruction::Uninit& instr) -> Result {
		this->return_term_info(instr.output,
			TermInfo::ValueCategory::INITIALIZER,
			TermInfo::ValueStage::COMPTIME,
			TermInfo::ValueState::NOT_APPLICABLE,
			TermInfo::InitializerType(),
			sema::Expr(this->context.sema_buffer.createUninit(instr.uninit_token))
		);
		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_zeroinit(const Instruction::Zeroinit& instr) -> Result {
		this->return_term_info(instr.output,
			TermInfo::ValueCategory::INITIALIZER,
			TermInfo::ValueStage::COMPTIME,
			TermInfo::ValueState::NOT_APPLICABLE,
			TermInfo::InitializerType(),
			sema::Expr(this->context.sema_buffer.createZeroinit(instr.zeroinit_token))
		);
		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_this(const Instruction::This& instr) -> Result {
		if(this->currently_in_func() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_EXPR_INVALID_OBJECT_SCOPE,
				instr.this_token,
				"[this] parameter must be in function scope"
			);
			return Result::ERROR;
		}

		const sema::Func& current_func = this->get_current_func();

		const std::optional<sema::Param::ID> this_param_id = this->scope.getThisParam();

		if(this_param_id.has_value() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_FUNC_HAS_NO_THIS_PARAM,
				instr.this_token,
				"This function doesn't have a [this] parameter",
				Diagnostic::Info("Function declared here:", this->get_location(current_func))
			);
			return Result::ERROR;
		}

		const BaseType::Function& current_func_type = 
			this->context.getTypeManager().getFunction(current_func.typeID);
		const BaseType::Function::Param& param = current_func_type.params[
			this->context.getSemaBuffer().getParam(*this_param_id).index
		];

		const TermInfo::ValueCategory value_category = [&](){
			switch(param.kind){
				case BaseType::Function::Param::Kind::READ:  return TermInfo::ValueCategory::CONCRETE_CONST;
				case BaseType::Function::Param::Kind::MUT:   return TermInfo::ValueCategory::CONCRETE_MUT;
				case BaseType::Function::Param::Kind::IN:    return TermInfo::ValueCategory::FORWARDABLE;
				case BaseType::Function::Param::Kind::C:     evo::debugFatalBreak("Cannot have a c [this] parameter");
			}

			evo::unreachable();
		}();

		this->return_term_info(instr.output,
			value_category,
			current_func.attributes.isComptime ? TermInfo::ValueStage::INTERPTIME : TermInfo::ValueStage::RUNTIME,
			TermInfo::ValueState::INIT,
			param.typeID,
			sema::Expr(*this_param_id)
		);

		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_type_deducer(const Instruction::TypeDeducer& instr) -> Result {
		const BaseType::ID new_type_deducer = this->context.type_manager.createTypeDeducer(
			BaseType::TypeDeducer(this->source.getID(), instr.type_deducer_token)
		);

		this->return_term_info(instr.output,
			TermInfo::ValueCategory::TYPE,
			TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(new_type_deducer)))
		);
		return Result::SUCCESS;
	}

	auto SemanticAnalyzer::instr_expr_deducer(const Instruction::ExprDeducer& instr) -> Result {
		this->return_term_info(instr.output,
			TermInfo::ValueCategory::EXPR_DEDUCER,
			TermInfo::ExprDeducerType{instr.expr_deducer_token}
		);
		return Result::SUCCESS;
	}



	//////////////////////////////////////////////////////////////////////
	// accessor


	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::module_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr, std::string_view rhs_ident_str, const TermInfo& lhs
	) -> Result {
		const Source& source_module = this->context.getSourceManager()[lhs.type_id.as<Source::ID>()];

		const sema::ScopeManager::Scope& source_module_sema_scope = 
			this->context.sema_buffer.scope_manager.getScope(*source_module.sema_scope_id);


		const sema::ScopeLevel& scope_level = this->context.sema_buffer.scope_manager.getLevel(
			source_module_sema_scope.getGlobalLevel()
		);

		const WaitOnSymbolProcResult wait_on_symbol_proc_result = this->wait_on_symbol_proc<NEEDS_DEF>(
			&source_module.global_symbol_procs, rhs_ident_str
		);


		switch(wait_on_symbol_proc_result){
			case WaitOnSymbolProcResult::NOT_FOUND: case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
				this->wait_on_symbol_proc_emit_error(
					wait_on_symbol_proc_result,
					instr.infix.rhs,
					std::format("Module has no symbol named \"{}\"", rhs_ident_str)
				);
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED: case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::NEED_TO_WAIT: {
				return Result::NEED_TO_WAIT;
			} break;

			case WaitOnSymbolProcResult::SEMAS_READY: {
				// do nothing...
			} break;
		}

		const evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError> expr_ident = 
			this->analyze_expr_ident_in_scope_level<NEEDS_DEF, ScopeAccessRequirement::PUB>(
				instr.rhs_ident, rhs_ident_str, scope_level, true, true, &source_module
			);


		if(expr_ident.has_value()){
			this->return_term_info(instr.output, std::move(expr_ident.value()));
			return Result::SUCCESS;
		}

		switch(expr_ident.error()){
			case AnalyzeExprIdentInScopeLevelError::DOESNT_EXIST:
				evo::debugFatalBreak("Def is done, but can't find sema of symbol");

			case AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF:
				evo::debugFatalBreak(
					"Sema doesn't have completed info for def despite SymbolProc saying it should"
				);

			case AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED: return Result::ERROR;
		}

		evo::unreachable();
	}


	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::clang_module_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr, std::string_view rhs_ident_str, const TermInfo& lhs
	) -> Result {
		const ClangSource& clang_source = this->context.getSourceManager()[lhs.type_id.as<ClangSource::ID>()];

		std::optional<ClangSource::SymbolInfo> clang_symbol = clang_source.getImportedSymbol(rhs_ident_str);

		if(clang_symbol.has_value() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_NO_SYMBOL_IN_SCOPE_WITH_THAT_IDENT,
				instr.infix.rhs,
				std::format("Module has no symbol named \"{}\"", rhs_ident_str)
			);
			return Result::ERROR;
		}

		clang_symbol->symbol.visit([&](const auto& symbol) -> void {
			using SymbolType = std::decay_t<decltype(symbol)>;

			if constexpr(std::is_same<SymbolType, BaseType::ID>()){
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::TYPE,
					TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(symbol)))
				);

			}else if constexpr(std::is_same<SymbolType, sema::Func::ID>()){
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::FUNCTION, TermInfo::FuncOverloadList{symbol}
				);

			}else if constexpr(std::is_same<SymbolType, sema::GlobalVar::ID>()){
				const sema::GlobalVar& global_var = this->context.getSemaBuffer().getGlobalVar(symbol);

				if(global_var.kind == AST::VarDef::Kind::DEF){
					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::INTERPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						*global_var.typeID,
						*global_var.expr.load(std::memory_order::relaxed)
					);

				}else{
					this->return_term_info(instr.output,
						global_var.kind == AST::VarDef::Kind::CONST 
							? TermInfo::ValueCategory::CONCRETE_CONST
							: TermInfo::ValueCategory::CONCRETE_MUT,
						TermInfo::ValueStage::RUNTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						*global_var.typeID,
						sema::Expr(symbol)
					);
				}
				
			}else{
				static_assert(false, "Unknown symbol kind");
			}
		});

		return Result::SUCCESS;
	}


	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::type_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr, std::string_view rhs_ident_str, const TermInfo& lhs
	) -> Result {
		if(lhs.type_id.as<TypeInfo::VoidableID>().isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_ACCESSOR_RHS,
				instr.infix.lhs,
				"Accessor operator of type `Void` is invalid"
			);
			return Result::ERROR;
		}

		const TypeInfo::ID decayed_lhs_type_id = this->context.type_manager.decayType<true, true>(
			lhs.type_id.as<TypeInfo::VoidableID>().asTypeID()
		);
		const TypeInfo& decayed_lhs_type = this->context.getTypeManager().getTypeInfo(decayed_lhs_type_id);

		if(decayed_lhs_type.qualifiers().empty() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_ACCESSOR_RHS,
				instr.infix.lhs,
				"Accessor operator of this LHS is unsupported",
				Diagnostic::Info("NOTE: LHS of a type accessor cannot be a type with qualifiers")
			);
			return Result::ERROR;
		}





		SymbolProcNamespace const * namespaced_members = nullptr;
		sema::ScopeLevel const * scope_level = nullptr;
		Source const * type_source = nullptr;

		switch(decayed_lhs_type.baseTypeID().kind()){
			case BaseType::Kind::STRUCT: {
				const BaseType::Struct& lhs_struct = this->context.getTypeManager().getStruct(
					decayed_lhs_type.baseTypeID().structID()
				);

				namespaced_members = lhs_struct.namespacedMembers;
				scope_level = lhs_struct.scopeLevel;

				if(lhs_struct.isClangType() == false){
					type_source = &this->context.getSourceManager()[lhs_struct.sourceID.as<Source::ID>()];
				}
			} break;

			case BaseType::Kind::UNION: {
				const BaseType::Union& lhs_union = this->context.getTypeManager().getUnion(
					decayed_lhs_type.baseTypeID().unionID()
				);

				for(uint32_t i = 0; const BaseType::Union::Field& field : lhs_union.fields){
					if(lhs_union.getFieldName(field, this->context.getSourceManager()) == rhs_ident_str){
						if(lhs_union.isUntagged){
							this->emit_error(
								Diagnostic::Code::SEMA_UNION_UNTAGGED_TYPE_FIELD_ACCESS,
								instr.infix.lhs,
								"Cannot type access a field of an untagged union"
							);
							return Result::SUCCESS;
						}

						this->return_term_info(instr.output,
							TermInfo::ValueCategory::TAGGED_UNION_FIELD_ACCESSOR,
							TermInfo::TaggedUnionFieldAccessor(decayed_lhs_type.baseTypeID().unionID(), i)
						);
						return Result::SUCCESS;
					}

					i += 1;
				}

				namespaced_members = lhs_union.namespacedMembers;
				scope_level = lhs_union.scopeLevel;

				if(lhs_union.isClangType() == false){
					type_source = &this->context.getSourceManager()[lhs_union.sourceID.as<Source::ID>()];
				}
			} break;

			case BaseType::Kind::ENUM: {
				const BaseType::Enum& lhs_enum = this->context.getTypeManager().getEnum(
					decayed_lhs_type.baseTypeID().enumID()
				);

				for(const BaseType::Enum::Enumerator& enumerator : lhs_enum.enumerators){
					if(lhs_enum.getEnumeratorName(enumerator, this->context.getSourceManager()) == rhs_ident_str){
						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							TermInfo::ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							decayed_lhs_type_id,
							sema::Expr(
								this->context.sema_buffer.createIntValue(
									enumerator.value, decayed_lhs_type.baseTypeID()
								)
							)
						);
						return Result::SUCCESS;
					}
				}

				namespaced_members = lhs_enum.namespacedMembers;
				scope_level = lhs_enum.scopeLevel;

				if(lhs_enum.isClangType() == false){
					type_source = &this->context.getSourceManager()[lhs_enum.sourceID.as<Source::ID>()];
				}
			} break;

			default: {
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_ACCESSOR_RHS,
					instr.infix.lhs,
					"Accessor operator of the type of this LHS is unsupported"
				);
				return Result::ERROR;
			} break;
		}


		const WaitOnSymbolProcResult wait_on_symbol_proc_result = this->wait_on_symbol_proc<NEEDS_DEF>(
			namespaced_members, rhs_ident_str
		);


		switch(wait_on_symbol_proc_result){
			case WaitOnSymbolProcResult::NOT_FOUND: case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
				this->wait_on_symbol_proc_emit_error(
					wait_on_symbol_proc_result,
					instr.infix.rhs,
					std::format("Type has no member named \"{}\"", rhs_ident_str)
				);
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED: case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::NEED_TO_WAIT: {
				return Result::NEED_TO_WAIT;
			} break;

			case WaitOnSymbolProcResult::SEMAS_READY: {
				// do nothing...
			} break;
		}

		const evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError> expr_ident = 
			this->analyze_expr_ident_in_scope_level<NEEDS_DEF, ScopeAccessRequirement::NOT_PRIV>(
				instr.rhs_ident, rhs_ident_str, *scope_level, true, false, type_source
			);

		if(expr_ident.has_value() == false){
			switch(expr_ident.error()){
				case AnalyzeExprIdentInScopeLevelError::DOESNT_EXIST: {
					evo::debugFatalBreak("Def is done, but can't find sema of symbol");
				} break;

				case AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF: {
					evo::debugFatalBreak(
						"Sema doesn't have completed info for def despite SymbolProc saying it should"
					);
				} break;

				case AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED: return Result::ERROR;
			}
		}

		if(
			this->currently_in_func()
			&& this->expr_in_func_is_valid_value_stage(expr_ident.value(), instr.rhs_ident) == false
		){
			return Result::ERROR;
		}

		this->return_term_info(instr.output, std::move(expr_ident.value()));
		return Result::SUCCESS;
	}


	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::builtin_module_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr, std::string_view rhs_ident_str, const TermInfo& lhs
	) -> Result {
		const BuiltinModule& builtin_module = this->context.getSourceManager()[lhs.type_id.as<BuiltinModule::ID>()];

		const std::optional<BuiltinModule::Symbol> symbol_find = builtin_module.getSymbol(rhs_ident_str);

		if(symbol_find.has_value() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_NO_SYMBOL_IN_SCOPE_WITH_THAT_IDENT,
				instr.infix.rhs,
				std::format("Builtin-module has no symbol named \"{}\"", rhs_ident_str)
			);
			return Result::ERROR;
		}

		symbol_find->visit([&](const auto& symbol) -> void {
			using SymbolType = std::decay_t<decltype(symbol)>;

			if constexpr(std::is_same<SymbolType, BaseType::ID>()){
				if(symbol.kind() == BaseType::Kind::STRUCT){
					BaseType::Struct& struct_type = this->context.type_manager.getStruct(symbol.structID());
					struct_type.shouldLower = true;
				}

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::TYPE,
					TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(symbol)))
				);

			}else if constexpr(std::is_same<SymbolType, sema::Func::ID>()){
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::FUNCTION, TermInfo::FuncOverloadList{symbol}
				);

			}else if constexpr(std::is_same<SymbolType, sema::GlobalVar::ID>()){
				const sema::GlobalVar& global_var = this->context.getSemaBuffer().getGlobalVar(symbol);

				this->return_term_info(instr.output,
					global_var.kind == AST::VarDef::Kind::CONST 
						? TermInfo::ValueCategory::CONCRETE_CONST
						: TermInfo::ValueCategory::CONCRETE_MUT,
					TermInfo::ValueStage::RUNTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					*global_var.typeID,
					sema::Expr(symbol)
				);
				
			}else{
				static_assert(false, "Unknown symbol kind");
			}
		});

		return Result::SUCCESS;
	}




	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::interface_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr,
		std::string_view rhs_ident_str,
		const TermInfo& lhs,
		TypeInfo::ID decayed_lhs_type_id,
		const TypeInfo& decayed_lhs_type,
		bool is_ref
	) -> Result {
		auto impl_instantiation_type_id = std::optional<TypeInfo::ID>();

		bool ref_is_mut = false; // only needed if `is_ref`

		const BaseType::Interface& target_interface = [&]() -> const BaseType::Interface& {
			if(is_ref){
				const BaseType::PolyInterfaceRef& poly_interface_ref = 
					this->context.getTypeManager().getPolyInterfaceRef(
						decayed_lhs_type.baseTypeID().polyInterfaceRefID()
					);

				ref_is_mut = poly_interface_ref.isMut;

				return this->context.getTypeManager().getInterface(poly_interface_ref.interfaceID);

			}else{
				const BaseType::InterfaceMap& interface_map = 
					this->context.getTypeManager().getInterfaceMap(decayed_lhs_type.baseTypeID().interfaceMapID());

				impl_instantiation_type_id = interface_map.underlyingTypeID;

				return this->context.getTypeManager().getInterface(interface_map.interfaceID);
			}
		}();


		// make sure def of target interface completed
		if(target_interface.defCompleted == false && target_interface.symbolProcID.has_value()){
			SymbolProc& target_interface_symbol_proc =
				this->context.symbol_proc_manager.getSymbolProc(*target_interface.symbolProcID);

			const SymbolProc::WaitOnResult wait_on_result = target_interface_symbol_proc.waitOnDefIfNeeded(
				this->symbol_proc_id, this->context, *target_interface.symbolProcID
			);
				
			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                 break;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*target_interface.symbolProcID);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                    return Result::NEED_TO_WAIT;
				case SymbolProc::WaitOnResult::WAS_ERRORED:                return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: evo::debugFatalBreak("Should be impossible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return Result::ERROR;
			}
		}


		if(is_ref){
			auto methods = TermInfo::FuncOverloadList();
			for(const sema::Func::ID method_id : target_interface.methods){
				const sema::Func& method = this->context.getSemaBuffer().getFunc(method_id);
				const std::string_view method_name = method.getName(this->context.getSourceManager());

				if(method_name == rhs_ident_str){
					methods.emplace_back(method_id);
				}
			}

			if(methods.empty()){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_NO_METHOD_WITH_THAT_NAME,
					instr.infix.rhs,
					"This interface has no method with that name"
				);
				return Result::ERROR;
			}


			const sema::FakeTermInfo::ValueCategory value_category = [&](){
				if(ref_is_mut){
					return sema::FakeTermInfo::ValueCategory::CONCRETE_MUT;
				}else{
					return sema::FakeTermInfo::ValueCategory::CONCRETE_CONST;
				}
			}();

			const sema::FakeTermInfo::ID created_fake_term_info = this->context.sema_buffer.createFakeTermInfo(
				value_category,
				TermInfo::convertValueStage(lhs.value_stage),
				TermInfo::convertValueState(lhs.value_state),
				lhs.type_id.as<TypeInfo::ID>(),
				lhs.getExpr()
			);


			this->return_term_info(instr.output,
				TermInfo::ValueCategory::POLY_INTERFACE_CALL,
				lhs.value_stage,
				TermInfo::ValueState::NOT_APPLICABLE,
				std::move(methods),
				sema::Expr(created_fake_term_info)
			);
			return Result::SUCCESS;

		}else{
			const BaseType::Interface::Impl& interface_impl = target_interface.impls.at(*impl_instantiation_type_id);

			{ // wait on instantiating symbol proc if needed
				const std::optional<SymbolProcID> instantiating_symbol_proc_id =
					interface_impl.instantiatingSymbolProc.load(std::memory_order::relaxed);

				if(instantiating_symbol_proc_id.has_value()){
					SymbolProc& target_impl_symbol_proc =
						this->context.symbol_proc_manager.getSymbolProc(*instantiating_symbol_proc_id);

					const SymbolProc::WaitOnResult wait_on_result = target_impl_symbol_proc.waitOnDefIfNeeded(
						this->symbol_proc_id, this->context, *instantiating_symbol_proc_id
					);
						
					switch(wait_on_result){
						case SymbolProc::WaitOnResult::NOT_NEEDED:
							break;

						case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
							this->context.symbol_proc_manager.symbol_proc_unsuspended();
							this->context.add_task_to_work_manager(*instantiating_symbol_proc_id);
							[[fallthrough]];
						}

						case SymbolProc::WaitOnResult::WAITING:
							return Result::NEED_TO_WAIT;

						case SymbolProc::WaitOnResult::WAS_ERRORED:
							return Result::ERROR;

						case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:
							evo::debugFatalBreak("Should be impossible");

						case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:
							return Result::ERROR;
					}
				}
			}


			auto func_overload_list = TermInfo::FuncOverloadList();
			for(size_t i = 0; const sema::Func::ID method_id : target_interface.methods){
				const sema::Func& method = this->context.getSemaBuffer().getFunc(method_id);
				const std::string_view method_name = method.getName(this->context.getSourceManager());

				if(method_name == rhs_ident_str){
					func_overload_list.emplace_back(interface_impl.methods[i]);
				}

				i += 1;
			}

			if(func_overload_list.empty()){
				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_NO_METHOD_WITH_THAT_NAME,
					instr.infix.rhs,
					"This interface has no method with that name"
				);
				return Result::ERROR;
			}

			const TypeInfo::ID this_type_id = [&](){
				if(decayed_lhs_type.qualifiers().empty()){
					return decayed_lhs_type_id;
				}else{
					return this->context.type_manager.getOrCreateTypeInfo(decayed_lhs_type.copyWithPoppedQualifier());
				}
			}();

			const sema::Expr this_expr = [&](){
				if(decayed_lhs_type.qualifiers().empty()){
					return lhs.getExpr();
				}else{
					return sema::Expr(this->context.sema_buffer.createDeref(lhs.getExpr(), this_type_id));
				}
			}();

			const sema::FakeTermInfo::ID method_this = this->context.sema_buffer.createFakeTermInfo(
				TermInfo::convertValueCategory(lhs.value_category),
				TermInfo::convertValueStage(lhs.value_stage),
				TermInfo::convertValueState(lhs.value_state),
				this_type_id,
				this_expr
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::INTERFACE_CALL,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				std::move(func_overload_list),
				sema::Expr(method_this)
			);
			return Result::SUCCESS;
		}
	}



	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::optional_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr,
		std::string_view rhs_ident_str,
		const TermInfo& lhs,
		TypeInfo::ID decayed_lhs_type_id,
		const TypeInfo& decayed_lhs_type,
		bool is_pointer
	) -> Result {
		const TypeInfo::ID optional_type_id = [&](){
			if(is_pointer){
				return this->context.type_manager.getOrCreateTypeInfo(decayed_lhs_type.copyWithPoppedQualifier());
			}else{
				return decayed_lhs_type_id;
			}
		}();

		const TypeInfo::ID optional_held_type_id = this->context.type_manager.getOrCreateTypeInfo(
			decayed_lhs_type.copyWithPoppedQualifier(1 + size_t(is_pointer))
		);


		const sema::Expr method_this = [&](){
			sema::Expr lhs_expr = lhs.getExpr();
			if(is_pointer){
				lhs_expr = sema::Expr(this->context.sema_buffer.createDeref(lhs_expr, decayed_lhs_type_id));
			}

			return sema::Expr(
				this->context.sema_buffer.createFakeTermInfo(
					TermInfo::convertValueCategory(lhs.value_category),
					TermInfo::convertValueStage(lhs.value_stage),
					TermInfo::convertValueState(lhs.value_state),
					optional_type_id,
					lhs_expr
				)
			);
		}();

		if(rhs_ident_str == "extract"){
			const TypeInfo::ID method_type = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(
					this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>(),
							evo::SmallVector<TypeInfo::VoidableID>{optional_held_type_id},
							evo::SmallVector<TypeInfo::VoidableID>(),
							false,
							false,
							false
						)
					)
				)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_TYPE_METHOD,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				TermInfo::BuiltinTypeMethod(
					method_type, TermInfo::BuiltinTypeMethod::Kind::OPT_EXTRACT
				),
				method_this
			);
			return Result::SUCCESS;
		}


		this->emit_error(
			Diagnostic::Code::SEMA_INVALID_ACCESSOR_RHS,
			instr.infix.lhs,
			"Accessor operator of this LHS is invalid",
			Diagnostic::Info("Did you mean to unwrap the optional?")
		);
		return Result::ERROR;
	}




	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::struct_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr,
		std::string_view rhs_ident_str,
		const TermInfo& lhs,
		TypeInfo::ID decayed_lhs_type_id,
		const TypeInfo& decayed_lhs_type,
		bool is_pointer
	) -> Result {
		const BaseType::Struct& lhs_type_struct = this->context.getTypeManager().getStruct(
			decayed_lhs_type.baseTypeID().structID()
		);

		///////////////////////////////////
		// member var

		{
			const auto lock = std::scoped_lock(lhs_type_struct.memberVarsLock);
			for(size_t i = 0; const BaseType::Struct::MemberVar* member_var : lhs_type_struct.memberVarsABI){
				const std::string_view member_ident_str = 
					lhs_type_struct.getMemberName(*member_var, this->context.getSourceManager());


				if(member_ident_str == rhs_ident_str){
					if(member_var->isPriv){
						const std::optional<EncapsulatingSymbolID> current_type_scope =
							this->scope.getCurrentTypeScopeIfExists();

						if(
							current_type_scope.has_value() == false
							|| current_type_scope->is<BaseType::Struct::ID>() == false
							|| current_type_scope->as<BaseType::Struct::ID>() !=decayed_lhs_type.baseTypeID().structID()
						){
							this->emit_error(
								Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
								instr.infix.rhs,
								std::format(
									"Struct member \"{}\" has attribute `#priv` and cannot be accessed in this scope",
									member_ident_str
								)
							);
							return Result::ERROR;
						}
					}

					const TermInfo::ValueCategory value_category = [&](){
						if(lhs.is_ephemeral() && is_pointer == false){ return lhs.value_category; }

						if(lhs.value_category == TermInfo::ValueCategory::CONCRETE_CONST){
							return TermInfo::ValueCategory::CONCRETE_CONST;
						}

						if(member_var->kind == AST::VarDef::Kind::CONST){
							return TermInfo::ValueCategory::CONCRETE_CONST;
						}else{
							return TermInfo::ValueCategory::CONCRETE_MUT;
						}
					}();

					using ValueStage = TermInfo::ValueStage;


					if(lhs.value_stage == ValueStage::COMPTIME){
						const sema::AggregateValue& lhs_aggregate_value =
							this->context.getSemaBuffer().getAggregateValue(lhs.getExpr().aggregateValueID());

						this->return_term_info(instr.output,
							TermInfo::ValueCategory::EPHEMERAL,
							ValueStage::COMPTIME,
							TermInfo::ValueState::NOT_APPLICABLE,
							member_var->typeID,
							lhs_aggregate_value.values[i]
						);
						
					}else{
						const sema::Expr sema_expr = [&](){
							if(is_pointer){
								const TypeInfo::ID resultant_type_id = this->context.type_manager.getOrCreateTypeInfo(
									TypeInfo(decayed_lhs_type.baseTypeID())
								);

								const sema::Deref::ID deref =
									this->context.sema_buffer.createDeref(lhs.getExpr(), resultant_type_id);

								return sema::Expr(
									this->context.sema_buffer.createAccessor(
										sema::Expr(deref), resultant_type_id, uint32_t(i)
									)
								);
							}else{
								return sema::Expr(
									this->context.sema_buffer.createAccessor(
										lhs.getExpr(), decayed_lhs_type_id, uint32_t(i)
									)
								);
							}
						}();


						const TermInfo::ValueState value_state = [&](){
							if(lhs.value_state == TermInfo::ValueState::INITIALIZING){
								return this->get_ident_value_state(
									sema::ReturnParamAccessorValueStateID(lhs.getExpr().returnParamID(), uint32_t(i))
								);

							}else if(
								this->source.getTokenBuffer()[this->get_current_func().name.as<Token::ID>()].kind()
									== Token::Kind::KEYWORD_DELETE
								&& lhs.getExpr().kind() == sema::Expr::Kind::PARAM
							){
								return this->get_ident_value_state(sema::OpDeleteThisAccessorValueStateID(uint32_t(i)));
							}else{
								return TermInfo::ValueState::NOT_APPLICABLE;
							}
						}();

						this->return_term_info(instr.output,
							value_category,
							this->get_current_func().attributes.isComptime
								? ValueStage::INTERPTIME
								: ValueStage::RUNTIME,
							value_state,
							member_var->typeID,
							sema_expr
						);
					}

					return Result::SUCCESS;
				}

				i += 1;
			}
		}


		///////////////////////////////////
		// get sub-symbol with ident

		const WaitOnSymbolProcResult wait_on_symbol_proc_result = this->wait_on_symbol_proc<NEEDS_DEF>(
			lhs_type_struct.namespacedMembers, rhs_ident_str
		);

		switch(wait_on_symbol_proc_result){
			case WaitOnSymbolProcResult::NOT_FOUND: case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
				this->wait_on_symbol_proc_emit_error(
					wait_on_symbol_proc_result,
					instr.infix.rhs,
					std::format("Struct has no member named \"{}\"", rhs_ident_str)
				);
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED: case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::NEED_TO_WAIT: {
				return Result::NEED_TO_WAIT;
			} break;

			case WaitOnSymbolProcResult::SEMAS_READY: {
				// do nothing...
			} break;
		}


		const Source* struct_source = [&]() -> const Source* {
			if(lhs_type_struct.isPTHRSourceType()){
				return &this->context.getSourceManager()[lhs_type_struct.sourceID.as<Source::ID>()];
			}else{
				return nullptr;
			}
		}();

		evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError> expr_ident = 
			this->analyze_expr_ident_in_scope_level<NEEDS_DEF, ScopeAccessRequirement::NOT_PRIV>(
				instr.rhs_ident, rhs_ident_str, *lhs_type_struct.scopeLevel, true, false, struct_source
			);


		if(expr_ident.has_value() == false){
			switch(expr_ident.error()){
				case AnalyzeExprIdentInScopeLevelError::DOESNT_EXIST: {
					evo::debugFatalBreak("Def is done, but can't find sema of symbol");
				} break;

				case AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF: {
					evo::debugFatalBreak(
						"Sema doesn't have completed info for def despite SymbolProc saying it should"
					);
				} break;

				case AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED: return Result::ERROR;
			}
		}



		switch(expr_ident.value().value_category){
			case TermInfo::ValueCategory::FUNCTION_NOT_PRIV_REQUIRED: {
				const sema::FakeTermInfo::ID method_this = [&](){
					if(is_pointer){
						const TypeInfo::ID resultant_type_id = this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(decayed_lhs_type.baseTypeID())
						);

						const sema::FakeTermInfo::ValueCategory value_category = 
							decayed_lhs_type.qualifiers().back().isMut
								? sema::FakeTermInfo::ValueCategory::CONCRETE_MUT
								: sema::FakeTermInfo::ValueCategory::CONCRETE_CONST;

						return this->context.sema_buffer.createFakeTermInfo(
							value_category,
							TermInfo::convertValueStage(lhs.value_stage),
							TermInfo::convertValueState(lhs.value_state),
							resultant_type_id,
							sema::Expr(this->context.sema_buffer.createDeref(lhs.getExpr(), resultant_type_id))
						);
						
					}else{
						return this->context.sema_buffer.createFakeTermInfo(
							TermInfo::convertValueCategory(lhs.value_category),
							TermInfo::convertValueStage(lhs.value_stage),
							TermInfo::convertValueState(lhs.value_state),
							decayed_lhs_type_id,
							lhs.getExpr()
						);
					}
				}();

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::METHOD_CALL,
					expr_ident.value().value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					std::move(expr_ident.value().type_id),
					sema::Expr(method_this)
				);
				return Result::SUCCESS;
			} break;

			case TermInfo::ValueCategory::TYPE: {
				if(this->get_package().warn.memberTypeByValueAccessor){
					this->emit_warning(
						Diagnostic::Code::SEMA_WARN_MEMBER_TYPE_BY_VALUE_ACCESSOR,
						instr.infix.rhs,
						"Accessing a member type by value accessor",
						Diagnostic::Info("Access the member type by type accessor instead")
					);
				}

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::TYPE, expr_ident.value().type_id
				);
				return Result::SUCCESS;
			} break;

			default: {
				evo::debugFatalBreak("Unknown RHS term kind");
			} break;
		}
	}




	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::union_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr,
		std::string_view rhs_ident_str,
		const TermInfo& lhs,
		TypeInfo::ID decayed_lhs_type_id,
		const TypeInfo& decayed_lhs_type,
		bool is_pointer
	) -> Result {
		const BaseType::Union& lhs_type_union = this->context.getTypeManager().getUnion(
			decayed_lhs_type.baseTypeID().unionID()
		);

		const Source* union_source = [&]() -> const Source* {
			if(lhs_type_union.isClangType()){
				return nullptr;
			}else{
				return &this->context.getSourceManager()[lhs_type_union.sourceID.as<Source::ID>()];
			}
		}();

		const sema::ScopeLevel::IdentID* lookup_ident = lhs_type_union.scopeLevel->lookupIdent(rhs_ident_str);

		if(lookup_ident == nullptr){
			this->emit_error(
				Diagnostic::Code::SEMA_NO_SYMBOL_IN_SCOPE_WITH_THAT_IDENT,
				instr.infix.rhs,
				std::format("Identifier \"{}\" was not defined in this scope", rhs_ident_str)
			);
			return Result::ERROR;
		}


		if(lookup_ident->is<sema::ScopeLevel::UnionField>()){
			const BaseType::Union::Field& union_field = 
				lhs_type_union.fields[lookup_ident->as<sema::ScopeLevel::UnionField>().field_index];

			if(union_field.typeID.isVoid()){
				this->emit_error(
					Diagnostic::Code::SEMA_UNION_ACCESSOR_IS_VOID,
					instr.infix.rhs,
					std::format("Cannot access union fields that are type `Void`")
				);
				return Result::ERROR;
			}



			const TermInfo::ValueCategory value_category = [&](){
				if(lhs.is_ephemeral() && is_pointer == false){ return lhs.value_category; }

				if(lhs.value_category == TermInfo::ValueCategory::CONCRETE_CONST){
					return TermInfo::ValueCategory::CONCRETE_CONST;
				}

				return TermInfo::ValueCategory::CONCRETE_MUT;
			}();



			if(lhs_type_union.isUntagged && this->currently_in_unsafe() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
					instr.infix,
					"Unsafe untagged union accessor while not in a unsafe scope"
				);
				return Result::ERROR;
			}

			using ValueStage = TermInfo::ValueStage;

			if(lhs.value_stage == ValueStage::COMPTIME){
				this->emit_error(
					Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
					instr.infix,
					"Comptime union accessor is currenlty unsupported"
				);
				return Result::ERROR;
				
			}else{
				const sema::Expr sema_expr = [&](){
					if(is_pointer){
						const TypeInfo::ID target_type_id = this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(decayed_lhs_type.baseTypeID())
						);

						const sema::Deref::ID deref =
							this->context.sema_buffer.createDeref(lhs.getExpr(), target_type_id);

						return sema::Expr(
							this->context.sema_buffer.createUnionAccessor(
								sema::Expr(deref),
								target_type_id,
								lookup_ident->as<sema::ScopeLevel::UnionField>().field_index
							)
						);
					}else{
						return sema::Expr(
							this->context.sema_buffer.createUnionAccessor(
								lhs.getExpr(),
								decayed_lhs_type_id,
								lookup_ident->as<sema::ScopeLevel::UnionField>().field_index
							)
						);
					}
				}();

				this->return_term_info(instr.output,
					value_category,
					this->get_current_func().attributes.isComptime ? ValueStage::INTERPTIME : ValueStage::RUNTIME,
					TermInfo::ValueState::NOT_APPLICABLE,
					lhs_type_union.fields[
						lookup_ident->as<sema::ScopeLevel::UnionField>().field_index
					].typeID.asTypeID(),
					sema_expr
				);
			}

			return Result::SUCCESS;
		}

		
		///////////////////////////////////
		// method / types

		const WaitOnSymbolProcResult wait_on_symbol_proc_result = this->wait_on_symbol_proc<NEEDS_DEF>(
			lhs_type_union.namespacedMembers, rhs_ident_str
		);


		switch(wait_on_symbol_proc_result){
			case WaitOnSymbolProcResult::NOT_FOUND: case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
				this->wait_on_symbol_proc_emit_error(
					wait_on_symbol_proc_result,
					instr.infix.rhs,
					std::format("Union has no member named \"{}\"", rhs_ident_str)
				);
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED: case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::NEED_TO_WAIT: {
				return Result::NEED_TO_WAIT;
			} break;

			case WaitOnSymbolProcResult::SEMAS_READY: {
				// do nothing...
			} break;
		}


		evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError> expr_ident = 
			this->analyze_expr_ident_in_scope_level<NEEDS_DEF, ScopeAccessRequirement::NONE>(
				instr.rhs_ident, rhs_ident_str, *lhs_type_union.scopeLevel, true, true, union_source
			);


		if(expr_ident.has_value() == false){
			switch(expr_ident.error()){
				case AnalyzeExprIdentInScopeLevelError::DOESNT_EXIST: {
					evo::debugFatalBreak("Def is done, but can't find sema of symbol");
				} break;

				case AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF: {
					evo::debugFatalBreak(
						"Sema doesn't have completed info for def despite SymbolProc saying it should"
					);
				} break;

				case AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED: return Result::ERROR;
			}
		}


		switch(expr_ident.value().value_category){
			case TermInfo::ValueCategory::FUNCTION_NOT_PRIV_REQUIRED: {
				const sema::FakeTermInfo::ID method_this = [&](){
					if(is_pointer){
						const TypeInfo::ID resultant_type_id = this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(decayed_lhs_type.baseTypeID())
						);

						const sema::FakeTermInfo::ValueCategory value_category = 
							decayed_lhs_type.qualifiers().back().isMut
								? sema::FakeTermInfo::ValueCategory::CONCRETE_MUT
								: sema::FakeTermInfo::ValueCategory::CONCRETE_CONST;

						return this->context.sema_buffer.createFakeTermInfo(
							value_category,
							TermInfo::convertValueStage(lhs.value_stage),
							TermInfo::convertValueState(lhs.value_state),
							resultant_type_id,
							sema::Expr(this->context.sema_buffer.createDeref(lhs.getExpr(), resultant_type_id))
						);
						
					}else{
						return this->context.sema_buffer.createFakeTermInfo(
							TermInfo::convertValueCategory(lhs.value_category),
							TermInfo::convertValueStage(lhs.value_stage),
							TermInfo::convertValueState(lhs.value_state),
							decayed_lhs_type_id,
							lhs.getExpr()
						);
					}
				}();

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::METHOD_CALL,
					expr_ident.value().value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					std::move(expr_ident.value().type_id),
					sema::Expr(method_this)
				);
				return Result::SUCCESS;
			} break;

			case TermInfo::ValueCategory::TYPE: {
				if(this->get_package().warn.memberTypeByValueAccessor){
					this->emit_warning(
						Diagnostic::Code::SEMA_WARN_MEMBER_TYPE_BY_VALUE_ACCESSOR,
						instr.infix.rhs,
						"Accessing a member type by value accessor",
						Diagnostic::Info("Access the member type by type accessor instead")
					);
				}

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::TYPE, expr_ident.value().type_id
				);
				return Result::SUCCESS;
			} break;

			default: {
				evo::debugFatalBreak("Unknown RHS term kind");
			} break;
		}

	}



	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::enum_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr,
		std::string_view rhs_ident_str,
		const TermInfo& lhs,
		TypeInfo::ID decayed_lhs_type_id,
		const TypeInfo& decayed_lhs_type,
		bool is_pointer
	) -> Result {
		const BaseType::Enum& lhs_type_enum = this->context.getTypeManager().getEnum(
			decayed_lhs_type.baseTypeID().enumID()
		);

		const Source* enum_source = [&]() -> const Source* {
			if(lhs_type_enum.isClangType()){
				return nullptr;
			}else{
				return &this->context.getSourceManager()[lhs_type_enum.sourceID.as<Source::ID>()];
			}
		}();

		const sema::ScopeLevel::IdentID* lookup_ident = lhs_type_enum.scopeLevel->lookupIdent(rhs_ident_str);

		if(lookup_ident == nullptr){
			auto infos = evo::SmallVector<Diagnostic::Info>();

			for(const BaseType::Enum::Enumerator& enumerator : lhs_type_enum.enumerators){
				if(lhs_type_enum.getEnumeratorName(enumerator, this->context.getSourceManager()) == rhs_ident_str){
					infos.emplace_back("Note: Enum enumerators should be accessed through the type");
					infos.emplace_back(
						std::format(
							"Did you mean: `{}.{}`?",
							lhs_type_enum.getName(this->context.getSourceManager()),
							rhs_ident_str
						)
					);
					break;
				}
			}

			this->emit_error(
				Diagnostic::Code::SEMA_NO_SYMBOL_IN_SCOPE_WITH_THAT_IDENT,
				instr.infix.rhs,
				std::format("Identifier \"{}\" was not defined in this scope", rhs_ident_str),
				std::move(infos)
			);
			return Result::ERROR;
		}

	
		///////////////////////////////////
		// method

		const WaitOnSymbolProcResult wait_on_symbol_proc_result = this->wait_on_symbol_proc<NEEDS_DEF>(
			lhs_type_enum.namespacedMembers, rhs_ident_str
		);


		switch(wait_on_symbol_proc_result){
			case WaitOnSymbolProcResult::NOT_FOUND: case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
				this->wait_on_symbol_proc_emit_error(
					wait_on_symbol_proc_result,
					instr.infix.rhs,
					std::format("Enum has no member named \"{}\"", rhs_ident_str)
				);
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED: case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
				return Result::ERROR;
			} break;

			case WaitOnSymbolProcResult::NEED_TO_WAIT: {
				return Result::NEED_TO_WAIT;
			} break;

			case WaitOnSymbolProcResult::SEMAS_READY: {
				// do nothing...
			} break;
		}


		evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError> expr_ident = 
			this->analyze_expr_ident_in_scope_level<NEEDS_DEF, ScopeAccessRequirement::NONE>(
				instr.rhs_ident, rhs_ident_str, *lhs_type_enum.scopeLevel, true, true, enum_source
			);


		if(expr_ident.has_value() == false){
			switch(expr_ident.error()){
				case AnalyzeExprIdentInScopeLevelError::DOESNT_EXIST: {
					evo::debugFatalBreak("Def is done, but can't find sema of symbol");
				} break;

				case AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF: {
					evo::debugFatalBreak(
						"Sema doesn't have completed info for def despite SymbolProc saying it should"
					);
				} break;

				case AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED: return Result::ERROR;
			}
		}


		switch(expr_ident.value().value_category){
			case TermInfo::ValueCategory::FUNCTION_NOT_PRIV_REQUIRED: {
				const sema::FakeTermInfo::ID method_this = [&](){
					if(is_pointer){
						const TypeInfo::ID resultant_type_id = this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(decayed_lhs_type.baseTypeID())
						);

						const sema::FakeTermInfo::ValueCategory value_category = 
							decayed_lhs_type.qualifiers().back().isMut
								? sema::FakeTermInfo::ValueCategory::CONCRETE_MUT
								: sema::FakeTermInfo::ValueCategory::CONCRETE_CONST;

						return this->context.sema_buffer.createFakeTermInfo(
							value_category,
							TermInfo::convertValueStage(lhs.value_stage),
							TermInfo::convertValueState(lhs.value_state),
							resultant_type_id,
							sema::Expr(this->context.sema_buffer.createDeref(lhs.getExpr(), resultant_type_id))
						);
						
					}else{
						return this->context.sema_buffer.createFakeTermInfo(
							TermInfo::convertValueCategory(lhs.value_category),
							TermInfo::convertValueStage(lhs.value_stage),
							TermInfo::convertValueState(lhs.value_state),
							decayed_lhs_type_id,
							lhs.getExpr()
						);
					}
				}();

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::METHOD_CALL,
					expr_ident.value().value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					std::move(expr_ident.value().type_id),
					sema::Expr(method_this)
				);
				return Result::SUCCESS;
			} break;

			case TermInfo::ValueCategory::TYPE: {
				if(this->get_package().warn.memberTypeByValueAccessor){
					this->emit_warning(
						Diagnostic::Code::SEMA_WARN_MEMBER_TYPE_BY_VALUE_ACCESSOR,
						instr.infix.rhs,
						"Accessing a member type by value accessor",
						Diagnostic::Info("Access the member type by type accessor instead")
					);
				}

				this->return_term_info(instr.output,
					TermInfo::ValueCategory::TYPE, expr_ident.value().type_id
				);
				return Result::SUCCESS;
			} break;

			default: {
				evo::debugFatalBreak("Unknown RHS term kind");
			} break;
		}
	}





	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::array_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr,
		std::string_view rhs_ident_str,
		const TermInfo& lhs,
		TypeInfo::ID decayed_lhs_type_id,
		const TypeInfo& decayed_lhs_type,
		bool is_pointer
	) -> Result {
		std::ignore = is_pointer;

		const sema::FakeTermInfo::ID method_this = this->context.sema_buffer.createFakeTermInfo(
			TermInfo::convertValueCategory(lhs.value_category),
			TermInfo::convertValueStage(lhs.value_stage),
			TermInfo::convertValueState(lhs.value_state),
			decayed_lhs_type_id,
			lhs.getExpr()
		);

		if(rhs_ident_str == "size"){
			const TypeInfo::ID method_type = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(
					this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>(),
							evo::SmallVector<TypeInfo::VoidableID>{TypeManager::getTypeUSize()},
							evo::SmallVector<TypeInfo::VoidableID>(),
							false,
							false,
							false
						)
					)
				)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_TYPE_METHOD,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				TermInfo::BuiltinTypeMethod(method_type, TermInfo::BuiltinTypeMethod::Kind::ARRAY_SIZE),
				sema::Expr(method_this)
			);
			return Result::SUCCESS;

		}else if(rhs_ident_str == "dimensions"){
			const BaseType::Array& array_type =
				this->context.getTypeManager().getArray(decayed_lhs_type.baseTypeID().arrayID());

			const BaseType::ID returned_array_base_type = this->context.type_manager.getOrCreateArray(
				BaseType::Array(
					TypeManager::getTypeUSize(),
					evo::SmallVector<uint64_t>{uint64_t(array_type.dimensions.size())},
					std::nullopt
				)
			);

			const TypeInfo::ID returned_array_type =
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(returned_array_base_type));

			const TypeInfo::ID method_type = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(
					this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>(),
							evo::SmallVector<TypeInfo::VoidableID>{returned_array_type},
							evo::SmallVector<TypeInfo::VoidableID>(),
							false,
							false,
							false
						)
					)
				)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_TYPE_METHOD,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				TermInfo::BuiltinTypeMethod(method_type, TermInfo::BuiltinTypeMethod::Kind::ARRAY_DIMENSIONS),
				sema::Expr(method_this)
			);
			return Result::SUCCESS;

		}else if(rhs_ident_str == "data"){
			const BaseType::Array& array_type =
				this->context.getTypeManager().getArray(decayed_lhs_type.baseTypeID().arrayID());

			const TypeInfo::ID return_type_id = [&]() -> TypeInfo::ID {
				const TypeInfo& arr_elem_type = this->context.getTypeManager().getTypeInfo(array_type.elementTypeID);

				if(lhs.is_mutable()){
					return this->context.type_manager.getOrCreateTypeInfo(
						arr_elem_type.copyWithPushedQualifier(TypeInfo::Qualifier::createMutPtr())
					);
				}else{
					return this->context.type_manager.getOrCreateTypeInfo(
						arr_elem_type.copyWithPushedQualifier(TypeInfo::Qualifier::createPtr())
					);
				}
			}();

			const TypeInfo::ID method_type = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(
					this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>(),
							evo::SmallVector<TypeInfo::VoidableID>{return_type_id},
							evo::SmallVector<TypeInfo::VoidableID>(),
							false,
							false,
							false
						)
					)
				)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_TYPE_METHOD,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				TermInfo::BuiltinTypeMethod(method_type, TermInfo::BuiltinTypeMethod::Kind::ARRAY_DATA),
				sema::Expr(method_this)
			);
			return Result::SUCCESS;
		}



		this->emit_error(
			Diagnostic::Code::SEMA_ARRAY_DOESNT_HAVE_MEMBER,
			instr.infix.rhs,
			std::format("Array has no member named \"{}\"", rhs_ident_str)
		);
		return Result::ERROR;
	}



	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::array_ref_accessor(
		const Instruction::Accessor<NEEDS_DEF>& instr,
		std::string_view rhs_ident_str,
		const TermInfo& lhs,
		TypeInfo::ID decayed_lhs_type_id,
		const TypeInfo& decayed_lhs_type,
		bool is_pointer
	) -> Result {
		const TypeInfo::ID array_ref_target_type = [&](){
			if(is_pointer){
				return this->context.type_manager.getOrCreateTypeInfo(decayed_lhs_type.copyWithPoppedQualifier());
			}else{
				return decayed_lhs_type_id;
			}
		}();

		const sema::Expr method_this = [&](){
			sema::Expr lhs_expr = lhs.getExpr();
			if(is_pointer){
				lhs_expr = sema::Expr(this->context.sema_buffer.createDeref(lhs_expr, decayed_lhs_type_id));
			}

			return sema::Expr(
				this->context.sema_buffer.createFakeTermInfo(
					TermInfo::convertValueCategory(lhs.value_category),
					TermInfo::convertValueStage(lhs.value_stage),
					TermInfo::convertValueState(lhs.value_state),
					array_ref_target_type,
					lhs_expr
				)
			);
		}();

		if(rhs_ident_str == "size"){
			const TypeInfo::ID method_type = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(
					this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>(),
							evo::SmallVector<TypeInfo::VoidableID>{TypeManager::getTypeUSize()},
							evo::SmallVector<TypeInfo::VoidableID>(),
							false,
							false,
							false
						)
					)
				)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_TYPE_METHOD,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				TermInfo::BuiltinTypeMethod(method_type, TermInfo::BuiltinTypeMethod::Kind::ARRAY_REF_SIZE),
				sema::Expr(method_this)
			);
			return Result::SUCCESS;

		}else if(rhs_ident_str == "dimensions"){
			const BaseType::ArrayRef& array_ref_type =
				this->context.getTypeManager().getArrayRef(decayed_lhs_type.baseTypeID().arrayRefID());

			const BaseType::ID returned_array_base_type = this->context.type_manager.getOrCreateArray(
				BaseType::Array(
					TypeManager::getTypeUSize(),
					evo::SmallVector<uint64_t>{uint64_t(array_ref_type.dimensions.size())},
					std::nullopt
				)
			);

			const TypeInfo::ID returned_array_type =
				this->context.type_manager.getOrCreateTypeInfo(TypeInfo(returned_array_base_type));

			const TypeInfo::ID method_type = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(
					this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>(),
							evo::SmallVector<TypeInfo::VoidableID>{returned_array_type},
							evo::SmallVector<TypeInfo::VoidableID>(),
							false,
							false,
							false
						)
					)
				)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_TYPE_METHOD,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				TermInfo::BuiltinTypeMethod(method_type, TermInfo::BuiltinTypeMethod::Kind::ARRAY_REF_DIMENSIONS),
				sema::Expr(method_this)
			);
			return Result::SUCCESS;

		}else if(rhs_ident_str == "data"){
			const BaseType::ArrayRef& array_ref_type =
				this->context.getTypeManager().getArrayRef(decayed_lhs_type.baseTypeID().arrayRefID());

			const TypeInfo::ID return_type_id = [&]() -> TypeInfo::ID {
				const TypeInfo& arr_elem_type =
					this->context.getTypeManager().getTypeInfo(array_ref_type.elementTypeID);

				if(array_ref_type.isMut){
					return this->context.type_manager.getOrCreateTypeInfo(
						arr_elem_type.copyWithPushedQualifier(TypeInfo::Qualifier::createMutPtr())
					);
				}else{
					return this->context.type_manager.getOrCreateTypeInfo(
						arr_elem_type.copyWithPushedQualifier(TypeInfo::Qualifier::createPtr())
					);
				}
			}();

			const TypeInfo::ID method_type = this->context.type_manager.getOrCreateTypeInfo(
				TypeInfo(
					this->context.type_manager.getOrCreateFunction(
						BaseType::Function(
							evo::SmallVector<BaseType::Function::Param>(),
							evo::SmallVector<TypeInfo::VoidableID>{return_type_id},
							evo::SmallVector<TypeInfo::VoidableID>(),
							false,
							false,
							false
						)
					)
				)
			);

			this->return_term_info(instr.output,
				TermInfo::ValueCategory::BUILTIN_TYPE_METHOD,
				TermInfo::ValueStage::COMPTIME,
				TermInfo::ValueState::NOT_APPLICABLE,
				TermInfo::BuiltinTypeMethod(method_type, TermInfo::BuiltinTypeMethod::Kind::ARRAY_REF_DATA),
				sema::Expr(method_this)
			);
			return Result::SUCCESS;
		}



		this->emit_error(
			Diagnostic::Code::SEMA_ARRAY_DOESNT_HAVE_MEMBER,
			instr.infix.rhs,
			std::format("Array reference has no member named \"{}\"", rhs_ident_str)
		);
		return Result::ERROR;
	}





	//////////////////////////////////////////////////////////////////////
	// scope

	auto SemanticAnalyzer::get_current_scope_level() const -> sema::ScopeLevel& {
		return this->context.sema_buffer.scope_manager.getLevel(this->scope.getCurrentLevel());
	}


	auto SemanticAnalyzer::push_scope_level(sema::StmtBlock* stmt_block) -> void {
		if(this->scope.inEncapsulatingSymbol()){
			this->get_current_scope_level().addSubScope();
		}
		this->scope.pushLevel(this->context.sema_buffer.scope_manager.createLevel(stmt_block));
	}

	auto SemanticAnalyzer::push_scope_level(
		sema::StmtBlock& stmt_block, Token::ID label, sema::ScopeLevel::LabelNode label_node
	) -> void {
		if(this->scope.inEncapsulatingSymbol()){
			this->get_current_scope_level().addSubScope();
		}
		this->scope.pushLevel(this->context.sema_buffer.scope_manager.createLevel(stmt_block, label, label_node));
	}

	auto SemanticAnalyzer::push_scope_level(sema::StmtBlock* stmt_block, const auto& encapsulating_symbol_id) -> void {
		this->get_current_scope_level().addSubScope();
		this->scope.pushLevel(this->context.sema_buffer.scope_manager.createLevel(stmt_block), encapsulating_symbol_id);
	}


	template<SemanticAnalyzer::PopScopeLevelKind POP_SCOPE_LEVEL_KIND>
	auto SemanticAnalyzer::pop_scope_level() -> evo::Result<> {
		if constexpr(POP_SCOPE_LEVEL_KIND == PopScopeLevelKind::SYMBOL_END){
			this->scope.popLevel();

		}else{
			sema::ScopeLevel& current_scope_level = this->get_current_scope_level();
			const bool current_scope_is_terminated = current_scope_level.isTerminated();
			const bool current_scope_is_label_terminated = current_scope_level.isLabelTerminated();

			if(
				current_scope_level.hasStmtBlock()
				&& current_scope_level.stmtBlock().isTerminated() == false
				&& current_scope_is_terminated
			){
				current_scope_level.stmtBlock().setTerminated();

			}else if(current_scope_is_terminated == false && this->scope.inEncapsulatingSymbol()){
				sema::ScopeLevel& parent_scope_level = 
					this->context.sema_buffer.scope_manager.getLevel(*std::next(this->scope.begin()));

				for(const auto& [value_state_id, value_state_info] : current_scope_level.getValueStateInfos()){
					if(value_state_info.info.is<sema::ScopeLevel::ValueStateInfo::DeclInfo>()){ continue; }

					const evo::Expected<void, sema::ScopeLevel::ValueStateID> set_value_state_res =
						parent_scope_level.setIdentValueStateFromSubScope(value_state_id, value_state_info.state);


					if(set_value_state_res.has_value() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_CANT_DETERMINE_VALUE_STATE,
							set_value_state_res.error(),
							"Can't determine value state in sub-scope"
						); // TODO(FUTURE): emit where the error comes from
						return evo::resultError;
					}
				}	
			}


			if constexpr(POP_SCOPE_LEVEL_KIND == PopScopeLevelKind::LABEL_TERMINATE){
				this->scope.popLevel(); // `current_scope_level` is now invalid

				if(
					current_scope_is_terminated
					&& this->scope.inEncapsulatingSymbol()
					&& !this->scope.inObjectMainScope()
					&& current_scope_is_label_terminated == false

				){
					this->get_current_scope_level().setSubScopeTerminated();
				}

			}else if constexpr(POP_SCOPE_LEVEL_KIND == PopScopeLevelKind::NORMAL){
				this->scope.popLevel(); // `current_scope_level` is now invalid

				if(
					current_scope_is_terminated
					&& this->scope.inEncapsulatingSymbol()
					&& !this->scope.inObjectMainScope()
				){
					this->get_current_scope_level().setSubScopeTerminated();

					if(current_scope_is_label_terminated){
						this->get_current_scope_level().setSubScopeLabelTerminated();
					}
				}
			}
		}

		return evo::Result<>();
	}



	template<SemanticAnalyzer::SpecialMemberKind SPECIAL_MEMBER_KIND, bool CHECK_VALIDITY>
	auto SemanticAnalyzer::get_special_member_call_dependents(
		TypeInfo::ID type_info_id,
		TermInfo::ValueCategory value_category,
		std::unordered_set<sema::Func::ID>& dependent_funcs,
		const auto& location
	) -> evo::Result<> {
		const TypeInfo& type_info = this->context.getTypeManager().getTypeInfo(type_info_id);

		if(type_info.qualifiers().size() > 0){
			if(type_info.qualifiers().back().isPtr == false && type_info.qualifiers().back().isOptional){
				const TypeInfo::ID optional_held_type_id = this->context.type_manager.getOrCreateTypeInfo(
					type_info.copyWithPoppedQualifier()
				);

				return this->get_special_member_call_dependents<SPECIAL_MEMBER_KIND, CHECK_VALIDITY>(
					optional_held_type_id, value_category, dependent_funcs, location
				);

			}else{
				// trivial
				return evo::Result<>();
			}
		}


		switch(type_info.baseTypeID().kind()){
			case BaseType::Kind::DUMMY: {
				evo::debugFatalBreak("Not a valid type");
			} break;

			case BaseType::Kind::PRIMITIVE: {
				// trivial
				return evo::Result<>();
			} break;

			case BaseType::Kind::FUNCTION: {
				// trivial
				return evo::Result<>();
			} break;

			case BaseType::Kind::ARRAY: {
				const BaseType::Array& array_type = 
					this->context.getTypeManager().getArray(type_info.baseTypeID().arrayID());

				return this->get_special_member_call_dependents<SPECIAL_MEMBER_KIND, CHECK_VALIDITY>(
					array_type.elementTypeID, value_category, dependent_funcs, location
				);
			} break;

			case BaseType::Kind::ARRAY_REF: {
				// trivial
				return evo::Result<>();
			} break;

			case BaseType::Kind::ALIAS: {
				const BaseType::Alias& alias_type = 
					this->context.getTypeManager().getAlias(type_info.baseTypeID().aliasID());

				return this->get_special_member_call_dependents<SPECIAL_MEMBER_KIND, CHECK_VALIDITY>(
					alias_type.aliasedType, value_category, dependent_funcs, location
				);
			} break;

			case BaseType::Kind::DISTINCT_ALIAS: {
				const BaseType::DistinctAlias& distinct_alias_type = 
					this->context.getTypeManager().getDistinctAlias(type_info.baseTypeID().distinctAliasID());

				return this->get_special_member_call_dependents<SPECIAL_MEMBER_KIND, CHECK_VALIDITY>(
					distinct_alias_type.underlyingType, value_category, dependent_funcs, location
				);
			} break;

			case BaseType::Kind::STRUCT: {
				const BaseType::Struct& struct_type = 
					this->context.getTypeManager().getStruct(type_info.baseTypeID().structID());

				if constexpr(SPECIAL_MEMBER_KIND == SpecialMemberKind::DELETE){
					const std::optional<sema::FuncID> delete_overload =
						struct_type.deleteOverload.load(std::memory_order::relaxed);

					if(delete_overload.has_value()){
						if constexpr(CHECK_VALIDITY){
							if(
								this->get_current_func().attributes.isComptime
								&& this->context.getSemaBuffer().getFunc(*delete_overload).attributes.isComptime == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
									location,
									"Cannot call a non-comptime [delete] within a comptime function",
									Diagnostic::Info(
										"Called operator [delete] was defined here:",
										this->get_location(*delete_overload)
									)
								);
								return evo::resultError;
							}
						}

						dependent_funcs.emplace(*delete_overload);
					}

				}else if constexpr(SPECIAL_MEMBER_KIND == SpecialMemberKind::COPY_INIT){
					const BaseType::Struct::DeletableOverload copy_overload =
						struct_type.copyInitOverload.load(std::memory_order::relaxed);

					if constexpr(CHECK_VALIDITY){
						if(copy_overload.wasDeleted()){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_special_member_fail<SpecialMemberFailKind::COPY>(
								type_info_id, infos
							);
							this->emit_error(
								Diagnostic::Code::SEMA_COPY_ARG_TYPE_NOT_COPYABLE,
								location,
								"Type of argument of operator [copy] is not copyable",
								std::move(infos)
							);
							return evo::resultError;
						}
					}

					if(copy_overload.funcID.has_value()){
						if constexpr(CHECK_VALIDITY){
							const sema::Func& sema_func = this->context.getSemaBuffer().getFunc(*copy_overload.funcID);
							const BaseType::Function& sema_func_type =
								this->context.getTypeManager().getFunction(sema_func.typeID);

							if(
								this->get_current_func().attributes.isComptime
								&& sema_func.attributes.isComptime == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
									location,
									"Cannot call a non-comptime [copy] initialization within a comptime function",
									Diagnostic::Info(
										"Called operator [copy] initialization was defined here:",
										this->get_location(sema_func)
									)
								);
								return evo::resultError;
							}

							if(this->currently_in_unsafe() == false && sema_func_type.isUnsafe){
								this->emit_error(
									Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
									location,
									"Call to unsafe [copy] initialization not in an unsafe scope",
									Diagnostic::Info(
										"Called operator [copy] initialization was defined here:",
										this->get_location(*copy_overload.funcID)
									)
								);
								return evo::resultError;
							}


							if(
								sema_func_type.params[0].kind == BaseType::Function::Param::Kind::MUT
								&& TermInfo::isValueCategoryMutable(value_category) == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_COPY_ARG_DOESNT_MATCH_PARAM_KIND,
									location,
									"Initialization [copy] of this type requires a mutable value"
								);
								return evo::resultError;
							}
						}

						dependent_funcs.emplace(*copy_overload.funcID);
					}

				}else if constexpr(SPECIAL_MEMBER_KIND == SpecialMemberKind::COPY_ASSIGN){
					const BaseType::Struct::DeletableOverload copy_init_overload =
						struct_type.copyInitOverload.load(std::memory_order::relaxed);

					if constexpr(CHECK_VALIDITY){
						if(copy_init_overload.wasDeleted()){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_special_member_fail<SpecialMemberFailKind::COPY>(
								type_info_id, infos
							);
							this->emit_error(
								Diagnostic::Code::SEMA_COPY_ARG_TYPE_NOT_COPYABLE,
								location,
								"Type of argument of operator [copy] is not copyable",
								std::move(infos)
							);
							return evo::resultError;
						}
					}


					const std::optional<sema::FuncID> copy_assign_overload = struct_type.copyAssignOverload.load();
					if(copy_assign_overload.has_value()){
						if constexpr(CHECK_VALIDITY){
							const sema::Func& sema_func = this->context.getSemaBuffer().getFunc(*copy_assign_overload);
							const BaseType::Function& sema_func_type =
								this->context.getTypeManager().getFunction(sema_func.typeID);

							if(
								this->get_current_func().attributes.isComptime
								&& sema_func.attributes.isComptime == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
									location,
									"Cannot call a non-comptime [copy] assignment within a comptime function",
									Diagnostic::Info(
										"Called operator [copy] assignment was defined here:",
										this->get_location(sema_func)
									)
								);
								return evo::resultError;
							}

							if(this->currently_in_unsafe() == false && sema_func_type.isUnsafe){
								this->emit_error(
									Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
									location,
									"Call to unsafe [copy] assignment not in an unsafe scope",
									Diagnostic::Info(
										"Called operator [copy] assignment was defined here:",
										this->get_location(sema_func)
									)
								);
								return evo::resultError;
							}

							if(
								sema_func_type.params[0].kind == BaseType::Function::Param::Kind::MUT
								&& TermInfo::isValueCategoryMutable(value_category) == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_COPY_ARG_DOESNT_MATCH_PARAM_KIND,
									location,
									"Assignment [copy] of this type requires a mutable value"
								);
								return evo::resultError;
							}
						}

						dependent_funcs.emplace(*copy_assign_overload);
						return evo::Result<>();
					}


					if(copy_init_overload.funcID.has_value()){
						if constexpr(CHECK_VALIDITY){
							const sema::Func& sema_func =
								this->context.getSemaBuffer().getFunc(*copy_init_overload.funcID);
							const BaseType::Function& sema_func_type =
								this->context.getTypeManager().getFunction(sema_func.typeID);

							if(
								this->get_current_func().attributes.isComptime
								&& sema_func.attributes.isComptime == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
									location,
									"Cannot call a non-comptime [copy] initialization within a comptime function",
									evo::SmallVector<Diagnostic::Info>{
										Diagnostic::Info(
											"Called operator [copy] initialization was defined here:",
											this->get_location(sema_func)
										),
										Diagnostic::Info(
											"NOTE: [copy] initialization called here as this type does not have an "
												"explicit [copy] assignment overload"
										)
									}
								);
								return evo::resultError;
							}


							if(this->currently_in_unsafe() == false && sema_func_type.isUnsafe){
								this->emit_error(
									Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
									location,
									"Call to unsafe [copy] initialization not in an unsafe scope",
									evo::SmallVector<Diagnostic::Info>{
										Diagnostic::Info(
											"Called operator [copy] initialization was defined here:",
											this->get_location(sema_func)
										),
										Diagnostic::Info(
											"NOTE: [copy] initialization called here as this type does not have an "
												"explicit [copy] assignment overload"
										)
									}
								);
								return evo::resultError;
							}

							if(
								sema_func_type.params[0].kind == BaseType::Function::Param::Kind::MUT
								&& TermInfo::isValueCategoryMutable(value_category) == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_COPY_ARG_DOESNT_MATCH_PARAM_KIND,
									location,
									"Initialization [copy] of this type requires a mutable value",
									Diagnostic::Info(
										"NOTE: [copy] initialization called here as this type does not have an "
											"explicit [copy] assignment overload"
									)
								);
								return evo::resultError;
							}
						}

						dependent_funcs.emplace(*copy_init_overload.funcID);


						const std::optional<sema::FuncID> delete_overload =
							struct_type.deleteOverload.load(std::memory_order::relaxed);
						if(delete_overload.has_value()){
							if constexpr(CHECK_VALIDITY){
								const sema::Func& sema_func =
									this->context.getSemaBuffer().getFunc(*delete_overload);
								const BaseType::Function& sema_func_type =
									this->context.getTypeManager().getFunction(sema_func.typeID);

								if(
									this->get_current_func().attributes.isComptime
									&& sema_func.attributes.isComptime == false
								){
									this->emit_error(
										Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
										location,
										"Cannot call a non-comptime [delete] within a comptime function",
										evo::SmallVector<Diagnostic::Info>{
											Diagnostic::Info(
												"Called operator [delete] was defined here:",
												this->get_location(sema_func)
											),
											Diagnostic::Info(
												"NOTE: [delete] called here as this type does not have an "
													"explicit [copy] assignment overload"
											)
										}
									);
									return evo::resultError;
								}

								if(this->currently_in_unsafe() == false && sema_func_type.isUnsafe){
									this->emit_error(
										Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
										location,
										"Call to unsafe [delete] not in an unsafe scope",
										evo::SmallVector<Diagnostic::Info>{
											Diagnostic::Info(
												"Called operator [delete] was defined here:",
												this->get_location(sema_func)
											),
											Diagnostic::Info(
												"NOTE: [delete] called here as this type does not have an "
													"explicit [copy] assignment overload"
											)
										}
									);
									return evo::resultError;
								}
							}

							dependent_funcs.emplace(*delete_overload);
						}
					}

				}else if constexpr(SPECIAL_MEMBER_KIND == SpecialMemberKind::MOVE_INIT){
					const BaseType::Struct::DeletableOverload move_overload =
						struct_type.moveInitOverload.load(std::memory_order::relaxed);

					if constexpr(CHECK_VALIDITY){
						if(move_overload.wasDeleted()){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_special_member_fail<SpecialMemberFailKind::MOVE>(
								type_info_id, infos
							);
							this->emit_error(
								Diagnostic::Code::SEMA_MOVE_ARG_TYPE_NOT_MOVABLE,
								location,
								"Type of argument of operator [move] is not movable",
								std::move(infos)
							);
							return evo::resultError;
						}
					}

					if(move_overload.funcID.has_value()){
						if constexpr(CHECK_VALIDITY){
							const sema::Func& sema_func = this->context.getSemaBuffer().getFunc(*move_overload.funcID);
							const BaseType::Function& sema_func_type =
								this->context.getTypeManager().getFunction(sema_func.typeID);

							if(
								this->get_current_func().attributes.isComptime
								&& sema_func.attributes.isComptime == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
									location,
									"Cannot call a non-comptime [move] initialization within a comptime function",
									Diagnostic::Info(
										"Called operator [move] initialization was defined here:",
										this->get_location(sema_func)
									)
								);
								return evo::resultError;
							}

							if(this->currently_in_unsafe() == false && sema_func_type.isUnsafe){
								this->emit_error(
									Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
									location,
									"Call to unsafe [move] initialization not in an unsafe scope",
									Diagnostic::Info(
										"Called operator [move] initialization was defined here:",
										this->get_location(sema_func)
									)
								);
								return evo::resultError;
							}

							if(
								sema_func_type.params[0].kind == BaseType::Function::Param::Kind::MUT
								&& TermInfo::isValueCategoryMutable(value_category) == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_COPY_ARG_DOESNT_MATCH_PARAM_KIND,
									location,
									"Initialization [move] of this type requires a mutable value"
								);
								return evo::resultError;
							}
						}

						dependent_funcs.emplace(*move_overload.funcID);
					}

				}else if constexpr(SPECIAL_MEMBER_KIND == SpecialMemberKind::MOVE_ASSIGN){
					const BaseType::Struct::DeletableOverload move_init_overload =
						struct_type.moveInitOverload.load(std::memory_order::relaxed);

					if constexpr(CHECK_VALIDITY){
						if(move_init_overload.wasDeleted()){
							auto infos = evo::SmallVector<Diagnostic::Info>();
							this->diagnostic_print_special_member_fail<SpecialMemberFailKind::MOVE>(
								type_info_id, infos
							);
							this->emit_error(
								Diagnostic::Code::SEMA_MOVE_ARG_TYPE_NOT_MOVABLE,
								location,
								"Type of argument of operator [move] is not movable",
								std::move(infos)
							);
							return evo::resultError;
						}
					}


					const std::optional<sema::FuncID> move_assign_overload =
						struct_type.moveAssignOverload.load(std::memory_order::relaxed);
					if(move_assign_overload.has_value()){
						if constexpr(CHECK_VALIDITY){
							const sema::Func& sema_func = this->context.getSemaBuffer().getFunc(*move_assign_overload);
							const BaseType::Function& sema_func_type =
								this->context.getTypeManager().getFunction(sema_func.typeID);

							if(
								this->get_current_func().attributes.isComptime
								&& sema_func.attributes.isComptime == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
									location,
									"Cannot call a non-comptime [move] assignment within a comptime function",
									Diagnostic::Info(
										"Called operator [move] assignment was defined here:",
										this->get_location(sema_func)
									)
								);
								return evo::resultError;
							}

							if(this->currently_in_unsafe() == false && sema_func_type.isUnsafe){
								this->emit_error(
									Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
									location,
									"Call to unsafe [move] assignment not in an unsafe scope",
									Diagnostic::Info(
										"Called operator [move] assignment was defined here:",
										this->get_location(sema_func)
									)
								);
								return evo::resultError;
							}

							if(
								sema_func_type.params[0].kind == BaseType::Function::Param::Kind::MUT
								&& TermInfo::isValueCategoryMutable(value_category) == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_COPY_ARG_DOESNT_MATCH_PARAM_KIND,
									location,
									"Assignment [move] of this type requires a mutable value"
								);
								return evo::resultError;
							}
						}

						dependent_funcs.emplace(*move_assign_overload);
					}


					if(move_init_overload.funcID.has_value()){
						if constexpr(CHECK_VALIDITY){
							const sema::Func& sema_func =
								this->context.getSemaBuffer().getFunc(*move_init_overload.funcID);
							const BaseType::Function& sema_func_type =
								this->context.getTypeManager().getFunction(sema_func.typeID);


							if(
								this->get_current_func().attributes.isComptime
								&& sema_func.attributes.isComptime == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
									location,
									"Cannot call a non-comptime [move] initialization within a comptime function",
									evo::SmallVector<Diagnostic::Info>{
										Diagnostic::Info(
											"Called operator [move] initialization was defined here:",
											this->get_location(sema_func)
										),
										Diagnostic::Info(
											"NOTE: [move] initialization called here as this type does not have an "
												"explicit [move] assignment overload"
										)
									}
								);
								return evo::resultError;
							}

							if(this->currently_in_unsafe() == false && sema_func_type.isUnsafe){
								this->emit_error(
									Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
									location,
									"Call to unsafe [move] initialization not in an unsafe scope",
									evo::SmallVector<Diagnostic::Info>{
										Diagnostic::Info(
											"Called operator [move] initialization was defined here:",
											this->get_location(sema_func)
										),
										Diagnostic::Info(
											"NOTE: [move] initialization called here as this type does not have an "
												"explicit [move] assignment overload"
										)
									}
								);
								return evo::resultError;
							}

							if(
								sema_func_type.params[0].kind == BaseType::Function::Param::Kind::MUT
								&& TermInfo::isValueCategoryMutable(value_category) == false
							){
								this->emit_error(
									Diagnostic::Code::SEMA_COPY_ARG_DOESNT_MATCH_PARAM_KIND,
									location,
									"Initialization [move] of this type requires a mutable value",
									Diagnostic::Info(
										"NOTE: [move] initialization called here as this type does not have an "
											"explicit [move] assignment overload"
									)
								);
								return evo::resultError;
							}
						}

						dependent_funcs.emplace(*move_init_overload.funcID);


						const std::optional<sema::FuncID> delete_overload =
							struct_type.deleteOverload.load(std::memory_order::relaxed);
						if(delete_overload.has_value()){
							if constexpr(CHECK_VALIDITY){
								const sema::Func& sema_func =
									this->context.getSemaBuffer().getFunc(*delete_overload);
								const BaseType::Function& sema_func_type =
									this->context.getTypeManager().getFunction(sema_func.typeID);

								if(
									this->get_current_func().attributes.isComptime
									&& sema_func.attributes.isComptime == false
								){
									this->emit_error(
										Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
										location,
										"Cannot call a non-comptime [delete] within a comptime function",
										evo::SmallVector<Diagnostic::Info>{
											Diagnostic::Info(
												"Called operator [delete] was defined here:",
												this->get_location(sema_func)
											),
											Diagnostic::Info(
												"NOTE: [delete] called here as this type does not have an "
													"explicit [move] assignment overload"
											)
										}
									);
									return evo::resultError;
								}

								if(this->currently_in_unsafe() == false && sema_func_type.isUnsafe){
									this->emit_error(
										Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
										location,
										"Call to unsafe [delete] not in an unsafe scope",
										evo::SmallVector<Diagnostic::Info>{
											Diagnostic::Info(
												"Called operator [delete] was defined here:",
												this->get_location(sema_func)
											),
											Diagnostic::Info(
												"NOTE: [delete] called here as this type does not have an "
													"explicit [move] assignment overload"
											)
										}
									);
									return evo::resultError;
								}
							}

							dependent_funcs.emplace(*delete_overload);
						}
					}

				}else{
					static_assert(false, "Unknown special member kind");
				}

				return evo::Result<>();
			} break;

			case BaseType::Kind::STRUCT_TEMPLATE: {
				evo::debugFatalBreak("Not a valid type to for value");
			} break;

			case BaseType::Kind::UNION: {
				const BaseType::Union& union_type = 
					this->context.getTypeManager().getUnion(type_info.baseTypeID().unionID());

				if(union_type.isUntagged == false){
					for(const BaseType::Union::Field& field : union_type.fields){
						if(field.typeID.isVoid()){ continue; }

						if(this->get_special_member_call_dependents<SPECIAL_MEMBER_KIND, CHECK_VALIDITY>(
							field.typeID.asTypeID(), value_category, dependent_funcs, location
						).isError()){
							return evo::resultError;
						}
					}
				}

				return evo::Result<>();
			} break;

			case BaseType::Kind::TYPE_DEDUCER: {
				evo::debugFatalBreak("Not a valid type to for value");
			} break;

			case BaseType::Kind::INTERFACE: {
				evo::debugFatalBreak("Not a valid type to for value");
			} break;

			case BaseType::Kind::POLY_INTERFACE_REF: {
				// trivial
				return evo::Result<>();
			} break;

			case BaseType::Kind::INTERFACE_MAP: {
				const BaseType::InterfaceMap& interface_map = 
					this->context.getTypeManager().getInterfaceMap(type_info.baseTypeID().interfaceMapID());

				return this->get_special_member_call_dependents<SPECIAL_MEMBER_KIND, CHECK_VALIDITY>(
					interface_map.underlyingTypeID, value_category, dependent_funcs, location
				);
			} break;
		}

		evo::debugFatalBreak("Unknown base type");
	}



	auto SemanticAnalyzer::currently_in_unsafe() const -> bool {
		for(const sema::ScopeLevel::ID scope_level_id : this->scope | std::views::reverse){
			if(this->context.sema_buffer.scope_manager.getLevel(scope_level_id).isUnsafe()){ return true; }
		}

		return false;
	}



	auto SemanticAnalyzer::currently_in_func() const -> bool {
		return this->scope.inEncapsulatingSymbol() && this->scope.getCurrentEncapsulatingSymbol().is<sema::Func::ID>();
	}

	auto SemanticAnalyzer::get_current_func() -> sema::Func& {
		return this->context.sema_buffer.funcs[this->scope.getCurrentEncapsulatingSymbol().as<sema::Func::ID>()];
	}

	auto SemanticAnalyzer::get_current_func() const -> const sema::Func& {
		return this->context.getSemaBuffer().getFunc(this->scope.getCurrentEncapsulatingSymbol().as<sema::Func::ID>());
	}




	//////////////////////////////////////////////////////////////////////
	// misc

	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::lookup_ident_impl(Token::ID ident) -> evo::Expected<TermInfo, Result> {
		const std::string_view ident_str = this->source.getTokenBuffer()[ident].getString();

		///////////////////////////////////
		// find symbol procs

		auto symbol_proc_namespaces = evo::SmallVector<const SymbolProc::Namespace*>();

		SymbolProc* parent_symbol = this->symbol_proc.parent;
		while(parent_symbol != nullptr){
			if(parent_symbol->extra_info.is<SymbolProc::StructInfo>()){
				symbol_proc_namespaces.emplace_back(
					&parent_symbol->extra_info.as<SymbolProc::StructInfo>().member_symbols
				);
			}
			
			parent_symbol = parent_symbol->parent;
		}
		symbol_proc_namespaces.emplace_back(&this->source.global_symbol_procs);


		const WaitOnSymbolProcResult wait_on_symbol_proc_result = this->wait_on_symbol_proc<NEEDS_DEF>(
			symbol_proc_namespaces, ident_str
		);

		switch(wait_on_symbol_proc_result){
			case WaitOnSymbolProcResult::NOT_FOUND: {
				// Do nothing as it may be an ident might not have a symbol proc (such as template param)
			} break;

			case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
				this->wait_on_symbol_proc_emit_error(
					wait_on_symbol_proc_result,
					ident,
					std::format("Identifier \"{}\" was not defined in this scope", ident_str)
				);
				return evo::Unexpected(Result::ERROR);
			} break;

			case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED: case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
				return evo::Unexpected(Result::ERROR);
			} break;

			case WaitOnSymbolProcResult::NEED_TO_WAIT: {
				return evo::Unexpected(Result::NEED_TO_WAIT);
			} break;

			case WaitOnSymbolProcResult::SEMAS_READY: {
				// do nothing...
			} break;
		}



		///////////////////////////////////
		// find sema

		for(size_t i = this->scope.size() - 1; sema::ScopeLevel::ID scope_level_id : this->scope){
			const evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError> scope_level_lookup = 
				this->analyze_expr_ident_in_scope_level<NEEDS_DEF, ScopeAccessRequirement::NONE>(
					ident,
					ident_str,
					this->context.sema_buffer.scope_manager.getLevel(scope_level_id),
					i >= this->scope.getCurrentEncapsulatingSymbolIndex() || i == 0,
					i == 0,
					nullptr
				);

			if(scope_level_lookup.has_value()){ return scope_level_lookup.value(); }

			switch(scope_level_lookup.error()){
				case AnalyzeExprIdentInScopeLevelError::DOESNT_EXIST: {
					// continue...
				} break;

				case AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF: {
					evo::debugFatalBreak("SymbolProc said done, sema disagreed");
				} break;

				case AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED: {
					return evo::Unexpected(Result::ERROR);
				} break;
			}

			i -= 1;
		}


		///////////////////////////////////
		// look in template decl instantiation types

		const evo::Result<std::optional<TypeInfo::VoidableID>> template_decl_instantiation = 
			this->scope.lookupTemplateDeclInstantiationType(ident_str);
		if(template_decl_instantiation.isSuccess()){
			if(template_decl_instantiation.value().has_value()){
				return TermInfo(TermInfo::ValueCategory::TYPE, template_decl_instantiation.value().value());
			}else{
				return TermInfo(
					TermInfo::ValueCategory::TEMPLATE_DECL_INSTANTIATION_TYPE, TermInfo::TemplateDeclInstantiationType()
				);
			}
		}


		///////////////////////////////////
		// didn't find identifier

		this->wait_on_symbol_proc_emit_error(
			wait_on_symbol_proc_result, ident, std::format("Identifier \"{}\" was not defined in this scope", ident_str)
		);
		return evo::Unexpected(Result::ERROR);
	}




	template<bool NEEDS_DEF, SemanticAnalyzer::ScopeAccessRequirement SCOPE_ACCESS_REQUIREMENT>
	auto SemanticAnalyzer::analyze_expr_ident_in_scope_level(
		const Token::ID& ident,
		std::string_view ident_str,
		const sema::ScopeLevel& scope_level,
		bool variables_in_scope, // TODO(FUTURE): make this template argument?
		bool is_global_scope, // TODO(FUTURE): make this template argumnet?
		const Source* source_module
	) -> evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError> {
		if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
			evo::debugAssert(
				variables_in_scope, "If `ScopeAccessRequirement::PUB`, `variables_in_scope` should be true"
			);
			evo::debugAssert(
				is_global_scope, "If `ScopeAccessRequirement::PUB`, `is_global_scope` should be true"
			);

		}else if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
			evo::debugAssert(
				variables_in_scope, "If `ScopeAccessRequirement::NOT_PRIV`, `variables_in_scope` should be true"
			);
			evo::debugAssert(
				is_global_scope == false, "If `ScopeAccessRequirement::NOT_PRIV`, `is_global_scope` should be fale"
			);
		}

		const sema::ScopeLevel::IdentID* ident_id_lookup = scope_level.lookupIdent(ident_str);
		if(ident_id_lookup == nullptr){
			return evo::Unexpected(AnalyzeExprIdentInScopeLevelError::DOESNT_EXIST);
		}


		using ReturnType = evo::Expected<TermInfo, AnalyzeExprIdentInScopeLevelError>;

		return ident_id_lookup->visit([&](const auto& ident_id) -> ReturnType {
			using IdentIDType = std::decay_t<decltype(ident_id)>;


			if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::FuncOverloadList>()){
				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					return ReturnType(TermInfo(TermInfo::ValueCategory::FUNCTION_PUB_REQUIRED, ident_id.funcs));
				}else{
					return ReturnType(TermInfo(TermInfo::ValueCategory::FUNCTION, ident_id.funcs));
				}

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::MethodOverloadList>()){
				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					return ReturnType(TermInfo(TermInfo::ValueCategory::FUNCTION_NOT_PRIV_REQUIRED, ident_id.funcs));
				}else{
					return ReturnType(TermInfo(TermInfo::ValueCategory::FUNCTION, ident_id.funcs));
				}

			}else if constexpr(std::is_same<IdentIDType, sema::FuncAlias::ID>()){
				const sema::FuncAlias& func_alias = this->context.getSemaBuffer().getFuncAlias(ident_id);

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(func_alias.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format(
								"Function alias \"{}\" does not have the `#pub` attribute, "
									"and is not accessable in this scope",
								ident_str
							),
							Diagnostic::Info("Function alias defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}

					return ReturnType(
						TermInfo(TermInfo::ValueCategory::FUNCTION_PUB_REQUIRED, func_alias.aliasedOverloads)
					);

				}else{
					if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
						if(func_alias.isPriv && func_alias.parent != this->scope.getCurrentTypeScopeIfExists()){
							this->emit_error(
								Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
								ident,
								std::format(
									"Function alias \"{}\" has the #priv attribute, "
										"and is not accessable from this scope",
									ident_str
								),
								Diagnostic::Info("Function alias defined here:", this->get_location(ident_id))
							);
							return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
						}
					}


					return ReturnType(TermInfo(TermInfo::ValueCategory::FUNCTION, func_alias.aliasedOverloads));
				}

			}else if constexpr(std::is_same<IdentIDType, sema::Var::ID>()){
				if(!variables_in_scope){
					// TODO(FUTURE): better messaging
					this->emit_error(
						Diagnostic::Code::SEMA_IDENT_NOT_IN_SCOPE,
						ident,
						std::format("Variable \"{}\" is not accessable in this scope", ident_str),
						Diagnostic::Info(
							"Local variables, parameters, and members cannot be accessed inside a sub-object scope. "
								"Defined here:",
							this->get_location(ident_id)
						)
					);
					return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
				}

				const sema::Var& sema_var = this->context.getSemaBuffer().getVar(ident_id);


				using ValueCategory = TermInfo::ValueCategory;
				using ValueStage = TermInfo::ValueStage;
				using ValueState = TermInfo::ValueState;

				switch(sema_var.kind){
					case AST::VarDef::Kind::VAR: {
						return ReturnType(TermInfo(
							ValueCategory::CONCRETE_MUT,
							this->get_current_func().attributes.isComptime ? ValueStage::INTERPTIME : ValueStage::RUNTIME,
							this->get_ident_value_state(ident_id),
							*sema_var.typeID,
							sema::Expr(ident_id)
						));
					} break;

					case AST::VarDef::Kind::CONST: {
						return ReturnType(TermInfo(
							ValueCategory::CONCRETE_CONST,
							this->get_current_func().attributes.isComptime ? ValueStage::INTERPTIME : ValueStage::RUNTIME,
							this->get_ident_value_state(ident_id),
							*sema_var.typeID,
							sema::Expr(ident_id)
						));
					} break;

					case AST::VarDef::Kind::DEF: {
						if(sema_var.typeID.has_value()){
							return ReturnType(TermInfo(
								ValueCategory::EPHEMERAL,
								ValueStage::COMPTIME,
								ValueState::NOT_APPLICABLE,
								*sema_var.typeID,
								sema_var.expr
							));
						}else{
							return ReturnType(TermInfo(
								ValueCategory::EPHEMERAL_FLUID,
								ValueStage::COMPTIME,
								ValueState::NOT_APPLICABLE,
								TermInfo::FluidType{},
								sema_var.expr
							));
						}
					} break;
				}

				evo::debugFatalBreak("Unknown or unsupported AST::VarDef::Kind");

			}else if constexpr(std::is_same<IdentIDType, sema::GlobalVar::ID>()){
				const sema::GlobalVar& sema_var = this->context.getSemaBuffer().getGlobalVar(ident_id);

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(sema_var.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format("Global variable \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info("Global variable defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}

				}else if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(sema_var.isPriv && sema_var.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Global variable \"{}\" has the #priv attribute, and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Global variable defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}



				using ValueCategory = TermInfo::ValueCategory;
				using ValueStage = TermInfo::ValueStage;
				using ValueState = TermInfo::ValueState;

				switch(sema_var.kind){
					case AST::VarDef::Kind::VAR: {
						if constexpr(NEEDS_DEF){
							if(sema_var.expr.load(std::memory_order::relaxed).has_value() == false){
								return ReturnType(
									evo::Unexpected(AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF)
								);
							}
						}

						const ValueStage value_stage = [&](){
							if(is_global_scope){ return ValueStage::RUNTIME; }

							evo::debugAssert(sema_var.parent.has_value(), "Not in global scope, should have parent");
							if(sema_var.parent->is<sema::Func::ID>() == false){ return ValueStage::RUNTIME; }

							const sema::Func& parent_sema_func =
								this->context.getSemaBuffer().getFunc(sema_var.parent->as<sema::Func::ID>());
							if(parent_sema_func.attributes.isComptime){
								return ValueStage::INTERPTIME;
							}else{
								return ValueStage::RUNTIME;
							}
						}();
						
						return ReturnType(TermInfo(
							ValueCategory::CONCRETE_MUT,
							value_stage,
							ValueState::NOT_APPLICABLE, 
							*sema_var.typeID,
							sema::Expr(ident_id)
						));
					} break;

					case AST::VarDef::Kind::CONST: {
						if constexpr(NEEDS_DEF){
							if(sema_var.expr.load(std::memory_order::relaxed).has_value() == false){
								return ReturnType(
									evo::Unexpected(AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF)
								);
							}
						}

						const ValueStage value_stage = [&](){
							if(is_global_scope){ return ValueStage::INTERPTIME; }

							if(this->currently_in_func() == false){
								return ValueStage::INTERPTIME;
							}

							if(this->get_current_func().attributes.isComptime){
								return ValueStage::INTERPTIME;
							}else{
								return ValueStage::RUNTIME;
							}
						}();



						if(this->currently_in_func() && this->get_current_func().attributes.isComptime){
							this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_vars.emplace(ident_id);
						}

						return ReturnType(TermInfo(
							ValueCategory::CONCRETE_CONST,
							value_stage,
							ValueState::NOT_APPLICABLE,
							*sema_var.typeID,
							sema::Expr(ident_id)
						));
					} break;

					case AST::VarDef::Kind::DEF: {
						if(sema_var.typeID.has_value()){
							return ReturnType(TermInfo(
								ValueCategory::EPHEMERAL,
								ValueStage::COMPTIME,
								ValueState::NOT_APPLICABLE,
								*sema_var.typeID,
								*sema_var.expr.load(std::memory_order::relaxed)
							));
						}else{
							return ReturnType(TermInfo(
								ValueCategory::EPHEMERAL_FLUID,
								ValueStage::COMPTIME,
								ValueState::NOT_APPLICABLE,
								TermInfo::FluidType{},
								*sema_var.expr.load(std::memory_order::relaxed)
							));
						}
					};
				}

				evo::debugFatalBreak("Unknown or unsupported AST::VarDef::Kind");

			}else if constexpr(std::is_same<IdentIDType, sema::Param::ID>()){
				const sema::Func& current_func = this->get_current_func();
				const BaseType::Function& current_func_type = 
					this->context.getTypeManager().getFunction(current_func.typeID);

				const size_t param_index = size_t(this->context.getSemaBuffer().getParam(ident_id).index);
				const BaseType::Function::Param& param = current_func_type.params[param_index];

				const TermInfo::ValueCategory value_category = [&](){
					switch(param.kind){
						case BaseType::Function::Param::Kind::READ: return TermInfo::ValueCategory::CONCRETE_CONST;
						case BaseType::Function::Param::Kind::MUT:  return TermInfo::ValueCategory::CONCRETE_MUT;
						case BaseType::Function::Param::Kind::IN:   return TermInfo::ValueCategory::FORWARDABLE;
						case BaseType::Function::Param::Kind::C:    evo::debugFatalBreak("invalid here");
					}

					evo::unreachable();
				}();


				const TypeInfo::ID param_type = [&](){
					const SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();

					if(func_info.instantiation == nullptr){
						return param.typeID;

					}else{
						if(this->context.getTypeManager().isTypeDeducer(param.typeID)){
							return *func_info.instantiation_param_arg_types[param_index];
						}else{
							return param.typeID;	
						}
					}
				}();


				return ReturnType(
					TermInfo(
						value_category,
						current_func.attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						this->get_ident_value_state(ident_id),
						param.typeID,
						sema::Expr(ident_id)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::VariadicParam::ID>()){
				const sema::VariadicParam& variadic_param = this->context.getSemaBuffer().getVariadicParam(ident_id);

				const sema::Func& current_func = this->get_current_func();
				const BaseType::Function& current_func_type = 
					this->context.getTypeManager().getFunction(current_func.typeID);

				auto variadic_param_types = evo::SmallVector<TypeInfo::ID>();
				variadic_param_types.reserve(variadic_param.numParams);
				for(
					size_t i = variadic_param.startIndex;
					i < variadic_param.startIndex + variadic_param.numParams;
					i+=1
				){
					variadic_param_types.emplace_back(current_func_type.params[i].typeID);
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::VARIADIC_PARAM,
						current_func.attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						TermInfo::VariadicParamTypes(std::move(variadic_param_types)),
						sema::Expr(ident_id)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::ExtractedVariadicParam>()){
				const sema::Func& current_func = this->get_current_func();

				const TermInfo::ValueCategory value_category = [&]() -> TermInfo::ValueCategory {
					if(ident_id.is_mut){
						const BaseType::Function& current_func_type = 
							this->context.getTypeManager().getFunction(current_func.typeID);

						const size_t param_index =
							size_t(this->context.getSemaBuffer().getParam(ident_id.param_id).index);
						const BaseType::Function::Param& param = current_func_type.params[param_index];

						switch(param.kind){
							case BaseType::Function::Param::Kind::READ: evo::debugFatalBreak("Not mutable");
							case BaseType::Function::Param::Kind::MUT:  return TermInfo::ValueCategory::CONCRETE_MUT;
							case BaseType::Function::Param::Kind::IN:   return TermInfo::ValueCategory::FORWARDABLE;
							case BaseType::Function::Param::Kind::C:    evo::debugFatalBreak("invalid here");
						}

						evo::unreachable();

					}else{
						return TermInfo::ValueCategory::CONCRETE_CONST;
					}
				}();

				return ReturnType(
					TermInfo(
						value_category,
						current_func.attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						this->get_ident_value_state(ident_id.param_id),
						ident_id.type_id,
						sema::Expr(ident_id.param_id)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ReturnParam::ID>()){
				const sema::Func& current_func = this->get_current_func();
				const BaseType::Function& current_func_type = 
					this->context.getTypeManager().getFunction(current_func.typeID);
				TypeInfo::VoidableID return_type = current_func_type.returnTypes[
					this->context.getSemaBuffer().getReturnParam(ident_id).index
				];


				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::CONCRETE_MUT,
						current_func.attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						this->get_ident_value_state(ident_id),
						return_type.asTypeID(),
						sema::Expr(ident_id)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ErrorReturnParam::ID>()){
				const sema::Func& current_func = this->get_current_func();
				const BaseType::Function& current_func_type = 
					this->context.getTypeManager().getFunction(current_func.typeID);
				TypeInfo::VoidableID error_param = current_func_type.errorTypes[
					this->context.getSemaBuffer().getErrorReturnParam(ident_id).index
				];

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::CONCRETE_MUT,
						current_func.attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						this->get_ident_value_state(ident_id),
						error_param.asTypeID(),
						sema::Expr(ident_id)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::BlockExprOutput::ID>()){
				const sema::Func& current_func = this->get_current_func();

				const sema::BlockExprOutput& sema_block_expr_output =
					this->context.getSemaBuffer().getBlockExprOutput(ident_id);

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::CONCRETE_MUT,
						current_func.attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						this->get_ident_value_state(ident_id),
						sema_block_expr_output.typeID,
						sema::Expr(ident_id)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ExceptParam::ID>()){
				const sema::Func& current_func = this->get_current_func();

				const sema::ExceptParam& except_param = this->context.getSemaBuffer().getExceptParam(ident_id);
				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::CONCRETE_MUT,
						current_func.attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						this->get_ident_value_state(ident_id),
						except_param.typeID,
						sema::Expr(ident_id)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ForParam::ID>()){
				const sema::Func& current_func = this->get_current_func();

				const sema::ForParam& for_param = this->context.getSemaBuffer().getForParam(ident_id);
				return ReturnType(
					TermInfo(
						for_param.isMut
							? TermInfo::ValueCategory::CONCRETE_MUT
							: TermInfo::ValueCategory::CONCRETE_CONST,
						current_func.attributes.isComptime
							? TermInfo::ValueStage::INTERPTIME
							: TermInfo::ValueStage::RUNTIME,
						this->get_ident_value_state(ident_id),
						for_param.typeID,
						sema::Expr(ident_id)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::ModuleInfo>()){
				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(ident_id.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident_id,
							std::format("Module \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Defined here:",
								Diagnostic::Location::get(ident_id.tokenID, *source_module)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(ident_id.isPriv && ident_id.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Module \"{}\" has the #priv attribute, "
									"and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Module defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::MODULE,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						ident_id.sourceID,
						sema::Expr::createModuleIdent(ident_id.tokenID)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::ClangModuleInfo>()){
				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(ident_id.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident_id,
							std::format("Module \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Defined here:",
								Diagnostic::Location::get(ident_id.tokenID, *source_module)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(ident_id.isPriv && ident_id.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Module \"{}\" has the #priv attribute, "
									"and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Module defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::CLANG_MODULE,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						ident_id.clangSourceID,
						sema::Expr::createModuleIdent(ident_id.tokenID)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, BaseType::Alias::ID>()){
				const BaseType::Alias& alias = this->context.getTypeManager().getAlias(ident_id);

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(alias.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format("Type alias \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Type alias declared here:",
								Diagnostic::Location::get(ident_id, this->context)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(alias.isPriv && alias.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Type alias \"{}\" has the #priv attribute, "
									"and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Type alias defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::TYPE,
						TypeInfo::VoidableID(
							this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(ident_id)))
						)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, BaseType::DistinctAlias::ID>()){
				const BaseType::DistinctAlias& alias = this->context.getTypeManager().getDistinctAlias(ident_id);

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(alias.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format("Distinct type alias \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Distinct type alias declared here:",
								Diagnostic::Location::get(ident_id, this->context)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(alias.isPriv && alias.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Distinct type alias \"{}\" has the #priv attribute, "
									"and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Distinct type alias defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::TYPE,
						TypeInfo::VoidableID(
							this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(ident_id)))
						)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, BaseType::Struct::ID>()){
				const BaseType::Struct& struct_info = this->context.getTypeManager().getStruct(ident_id);

				if constexpr(NEEDS_DEF){
					if(struct_info.defCompleted == false){
						return ReturnType(
							evo::Unexpected(AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF)
						);
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(struct_info.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format("Struct \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Struct declared here:",
								Diagnostic::Location::get(ident_id, this->context)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(struct_info.isPriv && struct_info.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Struct \"{}\" has the #priv attribute, and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Struct defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::TYPE,
						TypeInfo::VoidableID(
							this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(ident_id)))
						)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, BaseType::Union::ID>()){
				const BaseType::Union& union_info = this->context.getTypeManager().getUnion(ident_id);

				if constexpr(NEEDS_DEF){
					if(union_info.defCompleted == false){
						return ReturnType(
							evo::Unexpected(AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF)
						);
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(union_info.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format("Union \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Union declared here:",
								Diagnostic::Location::get(ident_id, this->context)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(union_info.isPriv && union_info.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Union \"{}\" has the #priv attribute, and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Union defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::TYPE,
						TypeInfo::VoidableID(
							this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(ident_id)))
						)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, BaseType::Enum::ID>()){
				const BaseType::Enum& enum_info = this->context.getTypeManager().getEnum(ident_id);

				if constexpr(NEEDS_DEF){
					if(enum_info.defCompleted == false){
						return ReturnType(
							evo::Unexpected(AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF)
						);
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(enum_info.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format("Enum \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Enum declared here:",
								Diagnostic::Location::get(ident_id, this->context)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(enum_info.isPriv && enum_info.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Enum \"{}\" has the #priv attribute, and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Enum defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::TYPE,
						TypeInfo::VoidableID(
							this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(ident_id)))
						)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, BaseType::Interface::ID>()){
				const BaseType::Interface& interface_info = this->context.getTypeManager().getInterface(ident_id);

				if constexpr(NEEDS_DEF){
					if(interface_info.defCompleted == false){
						return ReturnType(
							evo::Unexpected(AnalyzeExprIdentInScopeLevelError::NEEDS_TO_WAIT_ON_DEF)
						);
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(interface_info.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format("Interface \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Interface declared here:",
								Diagnostic::Location::get(ident_id, this->context)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(interface_info.isPriv && interface_info.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Interface \"{}\" has the #priv attribute, and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Interface defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::TYPE,
						TypeInfo::VoidableID(
							this->context.type_manager.getOrCreateTypeInfo(TypeInfo(BaseType::ID(ident_id)))
						)
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::TemplatedStruct::ID>()){
				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					return ReturnType(TermInfo(TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED, ident_id));
				}else{
					return ReturnType(TermInfo(TermInfo::ValueCategory::TEMPLATE_TYPE, ident_id));
				}

			}else if constexpr(std::is_same<IdentIDType, sema::StructTemplateAlias::ID>()){
				const sema::StructTemplateAlias& struct_template_alias = 
					this->context.getSemaBuffer().getStructTemplateAlias(ident_id);

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::PUB){
					if(struct_template_alias.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							ident,
							std::format("Alias \"{}\" does not have the #pub attribute", ident_str),
							Diagnostic::Info(
								"Alias declared here:",
								this->get_location(ident_id)
							)
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if constexpr(SCOPE_ACCESS_REQUIREMENT == ScopeAccessRequirement::NOT_PRIV){
					if(
						struct_template_alias.isPriv
						&& struct_template_alias.parent != this->scope.getCurrentTypeScopeIfExists()
					){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							ident,
							std::format(
								"Struct template alias \"{}\" has the #priv attribute, "
									"and is not accessable from this scope",
								ident_str
							),
							Diagnostic::Info("Struct template alias defined here:", this->get_location(ident_id))
						);
						return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));
					}
				}

				if(struct_template_alias.requiresPub){
					return ReturnType(TermInfo(TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED, ident_id));
				}else{
					return ReturnType(TermInfo(TermInfo::ValueCategory::TEMPLATE_TYPE, ident_id));
				}

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::TemplateTypeParam>()){
				return ReturnType(TermInfo(TermInfo::ValueCategory::TYPE, ident_id.typeID));

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::TemplateExprParam>()){
				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						ident_id.typeID,
						ident_id.value
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::DeducedType>()){
				return ReturnType(TermInfo(TermInfo::ValueCategory::TYPE, ident_id.typeID));

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::DeducedExpr>()){
				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						ident_id.typeID,
						ident_id.value
					)
				);

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::MemberVar>()){
				auto infos = evo::SmallVector<Diagnostic::Info>();

				const sema::Func& current_func = this->get_current_func();
				const Token::Kind func_name_kind = 
					this->source.getTokenBuffer()[current_func.name.as<Token::ID>()].kind();

				if(
					func_name_kind == Token::Kind::KEYWORD_NEW || func_name_kind == Token::Kind::KEYWORD_DELETE
					|| func_name_kind == Token::Kind::KEYWORD_COPY || func_name_kind == Token::Kind::KEYWORD_MOVE
				){
					infos.emplace_back(
						std::format(
							"Did you mean `{}.{}`?",
							this->source.getTokenBuffer()[current_func.returnParamIdents[0]].getString(),
							ident_str
						)
					);
				}else{
					infos.emplace_back(std::format("Did you mean `this.{}`?", ident_str));
					infos.emplace_back("Note: implicit `this` is not allowed");
				}

				this->emit_error(
					Diagnostic::Code::SEMA_IDENT_NOT_IN_SCOPE,
					ident,
					std::format("Member variables must be accessed through an accessor", ident_str),
					std::move(infos)
				);
				return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::UnionField>()){
				this->emit_error(
					Diagnostic::Code::SEMA_IDENT_NOT_IN_SCOPE,
					ident,
					std::format("Union fields are not accessable except through an accessor", ident_str),
					Diagnostic::Info(std::format("Did you mean `this.{}`?", ident_str))
				);
				return ReturnType(evo::Unexpected(AnalyzeExprIdentInScopeLevelError::ERROR_EMITTED));

			}else if constexpr(std::is_same<IdentIDType, sema::ScopeLevel::ForUnrollIndex>()){
				return ReturnType(
					TermInfo(
						TermInfo::ValueCategory::EPHEMERAL,
						TermInfo::ValueStage::COMPTIME,
						TermInfo::ValueState::NOT_APPLICABLE,
						ident_id.typeID,
						ident_id.value
					)
				);

			}else{
				static_assert(false, "Unsupported IdentID");
			}
		});
	}



	auto SemanticAnalyzer::end_sub_scopes(Diagnostic::Location&& location) -> evo::Result<> {
		sema::ScopeLevel& current_scope_level = this->get_current_scope_level();

		if(current_scope_level.isTerminated() && current_scope_level.stmtBlock().isTerminated() == false){
			if(current_scope_level.allTerminatedSubScopesAreLabelTerminated()){
				current_scope_level.stmtBlock().setLabelTerminated();
			}else{
				current_scope_level.stmtBlock().setTerminated();
			}
		}

		for(auto& [value_state_id, value_state_info] : current_scope_level.getValueStateInfos()){
			if(value_state_info.info.is<sema::ScopeLevel::ValueStateInfo::DeclInfo>()){
				sema::ScopeLevel::ValueStateInfo::DeclInfo& decl_info = 
					value_state_info.info.as<sema::ScopeLevel::ValueStateInfo::DeclInfo>();

				if(decl_info.potential_state_change.has_value() == false){ continue; }

				if(decl_info.num_sub_scopes != current_scope_level.numUnterminatedSubScopes()){
					this->emit_error(
						Diagnostic::Code::SEMA_CANT_DETERMINE_VALUE_STATE,
						value_state_id,
						"Cannot determine value state from sub-scopes",
						Diagnostic::Info("Sub-scopes end here:", std::move(location))
					);
					return evo::resultError;
				}

				value_state_info.state = *decl_info.potential_state_change;
				decl_info.potential_state_change.reset();
				decl_info.num_sub_scopes = 0;

			}else{
				evo::debugAssert(
					value_state_info.info.is<sema::ScopeLevel::ValueStateInfo::ModifyInfo>(),
					"Unknown value state info kind"
				);

				sema::ScopeLevel::ValueStateInfo::ModifyInfo& modify_info = 
					value_state_info.info.as<sema::ScopeLevel::ValueStateInfo::ModifyInfo>();

				if(modify_info.num_sub_scopes == 0){ continue; }

				if(modify_info.num_sub_scopes != current_scope_level.numUnterminatedSubScopes()){
					this->emit_error(
						Diagnostic::Code::SEMA_CANT_DETERMINE_VALUE_STATE,
						value_state_id,
						"Cannot determine value state from sub-scopes",
						Diagnostic::Info("Sub-scopes end here:", std::move(location))
					);
					return evo::resultError;
				}

				modify_info.num_sub_scopes = 0;
			}
		}


		current_scope_level.resetSubScopes();
		return evo::Result<>();
	}



	auto SemanticAnalyzer::get_ident_value_state(sema::ScopeLevel::ValueStateID value_state_id) -> TermInfo::ValueState{
		for(const sema::ScopeLevel::ID scope_id : this->scope){
			const sema::ScopeLevel& scope_level = this->context.sema_buffer.scope_manager.getLevel(scope_id);

			const std::optional<sema::ScopeLevel::ValueState> value_state =
				scope_level.getIdentValueState(value_state_id);

			if(value_state.has_value()){
				switch(*value_state){
					case sema::ScopeLevel::ValueState::INIT:         return TermInfo::ValueState::INIT;
					case sema::ScopeLevel::ValueState::INITIALIZING: return TermInfo::ValueState::INITIALIZING;
					case sema::ScopeLevel::ValueState::UNINIT:       return TermInfo::ValueState::UNINIT;
					case sema::ScopeLevel::ValueState::MOVED_FROM:   return TermInfo::ValueState::MOVED_FROM;
				}
				evo::debugFatalBreak("unknown value state");
			}
		}

		return TermInfo::ValueState::NOT_APPLICABLE;
	}



	auto SemanticAnalyzer::add_ident_value_state(
		sema::ScopeLevel::ValueStateID value_state_id, sema::ScopeLevel::ValueState value_state
	) -> void {
		sema::ScopeLevel& current_scope_level = this->get_current_scope_level();

		current_scope_level.addIdentValueState(value_state_id, value_state);

		value_state_id.visit([&](const auto& id) -> void {
			using IDType = std::decay_t<decltype(id)>;

			if constexpr(
				std::is_same<IDType, sema::Var::ID>()
				|| std::is_same<IDType, sema::ReturnParam::ID>()
				|| std::is_same<IDType, sema::ErrorReturnParam::ID>()
				|| std::is_same<IDType, sema::BlockExprOutput::ID>()
				|| std::is_same<IDType, sema::OpDeleteThisAccessorValueStateID>()
			){
				auto type_id = std::optional<TypeInfo::ID>();
				auto expr = std::optional<evo::Variant<sema::Expr, sema::OpDeleteThisAccessor>>();

				if constexpr(std::is_same<IDType, sema::Var::ID>()){
					type_id = *this->context.getSemaBuffer().getVar(id).typeID;
					expr = sema::Expr(id);

				}else if constexpr(std::is_same<IDType, sema::ReturnParam::ID>()){
					const sema::ReturnParam& sema_return_param = this->context.getSemaBuffer().getReturnParam(id);

					const BaseType::Function& current_func_type =
						this->context.getTypeManager().getFunction(this->get_current_func().typeID);

					type_id = current_func_type.returnTypes[sema_return_param.index].asTypeID();;
					expr = sema::Expr(id);

				}else if constexpr(std::is_same<IDType, sema::ErrorReturnParam::ID>()){
					const sema::ErrorReturnParam& sema_error_return_param =
						this->context.getSemaBuffer().getErrorReturnParam(id);

					const BaseType::Function& current_func_type =
						this->context.getTypeManager().getFunction(this->get_current_func().typeID);

					type_id = current_func_type.errorTypes[sema_error_return_param.index].asTypeID();
					expr = sema::Expr(id);

				}else if constexpr(std::is_same<IDType, sema::BlockExprOutput::ID>()){
					type_id = this->context.getSemaBuffer().getBlockExprOutput(id).typeID;
					expr = sema::Expr(id);

				}else if constexpr(std::is_same<IDType, sema::OpDeleteThisAccessorValueStateID>()){
					const BaseType::Function& current_func_type =
						this->context.getTypeManager().getFunction(this->get_current_func().typeID);
					const TypeInfo& this_type =
						this->context.getTypeManager().getTypeInfo(current_func_type.params[0].typeID);
					const BaseType::Struct& this_struct_type =
						this->context.getTypeManager().getStruct(this_type.baseTypeID().structID());

					type_id = this_struct_type.memberVars[id.abiIndex].typeID;
					expr = sema::OpDeleteThisAccessor(id.abiIndex);

				}else{
					static_assert(false, "need to get type of this type");
				}


				switch(value_state){
					case sema::ScopeLevel::ValueState::UNINIT: {
						// do nothing...
					} break;

					case sema::ScopeLevel::ValueState::INIT: {
						current_scope_level.stmtBlock().emplace_back(
							this->context.sema_buffer.createLifetimeStart(*expr, *type_id)
						);
					} break;

					case sema::ScopeLevel::ValueState::INITIALIZING: {
						current_scope_level.stmtBlock().emplace_back(
							this->context.sema_buffer.createLifetimeStart(*expr, *type_id)
						);
					} break;

					case sema::ScopeLevel::ValueState::MOVED_FROM: {
						evo::debugAssert("Should never start life as moved from");
					} break;
				}
			}
		});
	}

	auto SemanticAnalyzer::set_ident_value_state(
		sema::ScopeLevel::ValueStateID value_state_id, sema::ScopeLevel::ValueState value_state
	) -> void {
		sema::ScopeLevel& current_scope_level = this->get_current_scope_level();

		current_scope_level.setIdentValueState(value_state_id, value_state);

		value_state_id.visit([&](const auto& id) -> void {
			using IDType = std::decay_t<decltype(id)>;

			if constexpr(
				std::is_same<IDType, sema::Var::ID>()
				|| std::is_same<IDType, sema::ReturnParam::ID>()
				|| std::is_same<IDType, sema::ErrorReturnParam::ID>()
				|| std::is_same<IDType, sema::BlockExprOutput::ID>()
				|| std::is_same<IDType, sema::OpDeleteThisAccessorValueStateID>()
			){
				auto type_id = std::optional<TypeInfo::ID>();
				auto expr = std::optional<evo::Variant<sema::Expr, sema::OpDeleteThisAccessor>>();

				if constexpr(std::is_same<IDType, sema::Var::ID>()){
					type_id = *this->context.getSemaBuffer().getVar(id).typeID;
					expr = sema::Expr(id);

				}else if constexpr(std::is_same<IDType, sema::ReturnParam::ID>()){
					const sema::ReturnParam& sema_return_param = this->context.getSemaBuffer().getReturnParam(id);

					const BaseType::Function& current_func_type =
						this->context.getTypeManager().getFunction(this->get_current_func().typeID);

					type_id = current_func_type.returnTypes[sema_return_param.index].asTypeID();;
					expr = sema::Expr(id);

				}else if constexpr(std::is_same<IDType, sema::ErrorReturnParam::ID>()){
					const sema::ErrorReturnParam& sema_error_return_param =
						this->context.getSemaBuffer().getErrorReturnParam(id);

					const BaseType::Function& current_func_type =
						this->context.getTypeManager().getFunction(this->get_current_func().typeID);

					type_id = current_func_type.errorTypes[sema_error_return_param.index].asTypeID();
					expr = sema::Expr(id);

				}else if constexpr(std::is_same<IDType, sema::BlockExprOutput::ID>()){
					type_id = this->context.getSemaBuffer().getBlockExprOutput(id).typeID;
					expr = sema::Expr(id);

				}else if constexpr(std::is_same<IDType, sema::OpDeleteThisAccessorValueStateID>()){
					const BaseType::Function& current_func_type =
						this->context.getTypeManager().getFunction(this->get_current_func().typeID);
					const TypeInfo& this_type =
						this->context.getTypeManager().getTypeInfo(current_func_type.params[0].typeID);
					const BaseType::Struct& this_struct_type =
						this->context.getTypeManager().getStruct(this_type.baseTypeID().structID());

					type_id = this_struct_type.memberVars[id.abiIndex].typeID;
					expr = sema::OpDeleteThisAccessor(id.abiIndex);

				}else{
					static_assert(false, "need to get type of this type");
				}


				switch(value_state){
					case sema::ScopeLevel::ValueState::UNINIT: {
						current_scope_level.stmtBlock().emplace_back(
							this->context.sema_buffer.createLifetimeEnd(*expr, *type_id)
						);
					} break;

					case sema::ScopeLevel::ValueState::INIT: {
						current_scope_level.stmtBlock().emplace_back(
							this->context.sema_buffer.createLifetimeStart(*expr, *type_id)
						);
					} break;

					case sema::ScopeLevel::ValueState::INITIALIZING: {
						current_scope_level.stmtBlock().emplace_back(
							this->context.sema_buffer.createLifetimeStart(*expr, *type_id)
						);
					} break;

					case sema::ScopeLevel::ValueState::MOVED_FROM: {
						current_scope_level.stmtBlock().emplace_back(
							this->context.sema_buffer.createLifetimeEnd(*expr, *type_id)
						);
					} break;
				}
			}
		});
	}


	auto SemanticAnalyzer::set_ident_value_state_if_needed(
		sema::Expr target, sema::ScopeLevel::ValueState value_state, Diagnostic::Location location
	) -> evo::Result<> {
		switch(target.kind()){
			case sema::Expr::Kind::PARAM: {
				this->set_ident_value_state(target.paramID(), value_state);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::RETURN_PARAM: {
				const sema::Func& current_func = this->get_current_func();
				const Token::ID current_func_name_token_id = current_func.name.as<Token::ID>();
				const Token& current_func_name_token =
					this->source.getTokenBuffer()[current_func_name_token_id];

				if(
					current_func_name_token.kind() == Token::Kind::KEYWORD_NEW
					|| current_func_name_token.kind() == Token::Kind::KEYWORD_COPY
					|| current_func_name_token.kind() == Token::Kind::KEYWORD_MOVE
				){
					const BaseType::Function& current_func_type =
						this->context.getTypeManager().getFunction(current_func.typeID);

					const TypeInfo& output_type =
						this->context.getTypeManager().getTypeInfo(current_func_type.returnTypes[0].asTypeID());
					const BaseType::Struct& output_struct_type = 
						this->context.getTypeManager().getStruct(output_type.baseTypeID().structID());

					for(int32_t i = int32_t(output_struct_type.memberVars.size() - 1); i >= 0; i-=1){
						const auto accessor_id =
							sema::ReturnParamAccessorValueStateID(target.returnParamID(), uint32_t(i));

						switch(this->get_ident_value_state(accessor_id)){
							case TermInfo::ValueState::UNINIT: case TermInfo::ValueState::MOVED_FROM: {
								this->set_ident_value_state(accessor_id, value_state);
							} break;

							case TermInfo::ValueState::INIT: {
								this->emit_error(
									Diagnostic::Code::SEMA_SPECIAL_MEMBER_OUTPUT_MEMBER_INIT_ON_DIRECT,
									location,
									"Cannot direct initialize output of special member function when one (or more) of "
										"its members was already initialized"
								);
								return evo::resultError;
							} break;

							case TermInfo::ValueState::INITIALIZING: case TermInfo::ValueState::NOT_APPLICABLE: {
								evo::debugFatalBreak("Special func output member should never be in this value state");
							} break;
						}
					}

					SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();
					func_info.num_members_of_initializing_are_uninit = 0;
				}

				this->set_ident_value_state(target.returnParamID(), value_state);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::ERROR_RETURN_PARAM: {
				this->set_ident_value_state(target.errorReturnParamID(), value_state);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::BLOCK_EXPR_OUTPUT: {
				this->set_ident_value_state(target.blockExprOutputID(), value_state);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::EXCEPT_PARAM: {
				this->set_ident_value_state(target.exceptParamID(), value_state);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::FOR_PARAM: {
				this->set_ident_value_state(target.forParamID(), value_state);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::VAR: {
				this->set_ident_value_state(target.varID(), value_state);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::ADDR_OF: {
				const sema::Expr& addr_of_target = this->context.getSemaBuffer().getAddrOf(target.addrOfID());
				this->set_ident_value_state_if_needed(addr_of_target, value_state, location);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::DEREF: {
				const sema::Deref& deref = this->context.getSemaBuffer().getDeref(target.derefID());
				this->set_ident_value_state_if_needed(deref.expr, value_state, location);
				return evo::Result<>();
			} break;

			case sema::Expr::Kind::ACCESSOR: {
				const sema::Accessor& accessor = this->context.getSemaBuffer().getAccessor(target.accessorID());

				switch(accessor.target.kind()){
					case sema::Expr::Kind::PARAM: {
						const Token::ID current_func_name_token_id = this->get_current_func().name.as<Token::ID>();
						const Token& current_func_name_token =
							this->source.getTokenBuffer()[current_func_name_token_id];

						if(current_func_name_token.kind() != Token::Kind::KEYWORD_DELETE){ return evo::Result<>(); }

						this->set_ident_value_state(
							sema::OpDeleteThisAccessorValueStateID(accessor.memberABIIndex), value_state
						);

						return evo::Result<>();
					} break;

					case sema::Expr::Kind::RETURN_PARAM: {
						if(accessor.target.kind() != sema::Expr::Kind::RETURN_PARAM){ return evo::Result<>(); }

						this->set_ident_value_state(
							sema::ReturnParamAccessorValueStateID(
								accessor.target.returnParamID(), accessor.memberABIIndex
							),
							value_state
						);

						SymbolProc::FuncInfo& func_info = this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>();
						func_info.num_members_of_initializing_are_uninit -= 1;

						if(func_info.num_members_of_initializing_are_uninit == 0){
							this->set_ident_value_state(
								accessor.target.returnParamID(), sema::ScopeLevel::ValueState::INIT
							);
						}

						return evo::Result<>();
					} break;

					default: return evo::Result<>();
				}
			} break;

			case sema::Expr::Kind::NONE: evo::debugFatalBreak("Invalid expr");

			case sema::Expr::Kind::MODULE_IDENT:                  case sema::Expr::Kind::NULL_VALUE:
			case sema::Expr::Kind::UNINIT:                        case sema::Expr::Kind::ZEROINIT:
			case sema::Expr::Kind::INT_VALUE:                     case sema::Expr::Kind::FLOAT_VALUE:
			case sema::Expr::Kind::BOOL_VALUE:                    case sema::Expr::Kind::STRING_VALUE:
			case sema::Expr::Kind::AGGREGATE_VALUE:               case sema::Expr::Kind::CHAR_VALUE:
			case sema::Expr::Kind::INTRINSIC_FUNC: case sema::Expr::Kind::TEMPLATED_INTRINSIC_FUNC_INSTANTIATION:
			case sema::Expr::Kind::COPY:                          case sema::Expr::Kind::MOVE:
			case sema::Expr::Kind::FORWARD:                       case sema::Expr::Kind::FUNC_CALL:
			case sema::Expr::Kind::CONVERSION_TO_OPTIONAL:        case sema::Expr::Kind::OPTIONAL_NULL_CHECK:
			case sema::Expr::Kind::OPTIONAL_EXTRACT:              case sema::Expr::Kind::UNWRAP:
			case sema::Expr::Kind::UNION_ACCESSOR:                case sema::Expr::Kind::LOGICAL_AND:
			case sema::Expr::Kind::LOGICAL_OR:                    case sema::Expr::Kind::TRY_ELSE_EXPR:
			case sema::Expr::Kind::TRY_ELSE_INTERFACE_EXPR:       case sema::Expr::Kind::BLOCK_EXPR:
			case sema::Expr::Kind::FAKE_TERM_INFO:                case sema::Expr::Kind::MAKE_INTERFACE_PTR:
			case sema::Expr::Kind::INTERFACE_PTR_EXTRACT_THIS:    case sema::Expr::Kind::INTERFACE_CALL:
			case sema::Expr::Kind::INDEXER:                       case sema::Expr::Kind::DEFAULT_NEW:
			case sema::Expr::Kind::INIT_ARRAY_REF:                case sema::Expr::Kind::ARRAY_REF_INDEXER:
			case sema::Expr::Kind::ARRAY_REF_SIZE:                case sema::Expr::Kind::ARRAY_REF_DIMENSIONS:
			case sema::Expr::Kind::ARRAY_REF_DATA:                case sema::Expr::Kind::UNION_DESIGNATED_INIT_NEW:
			case sema::Expr::Kind::UNION_TAG_CMP:                 case sema::Expr::Kind::SAME_TYPE_CMP:
			case sema::Expr::Kind::VARIADIC_PARAM:                case sema::Expr::Kind::GLOBAL_VAR:
			case sema::Expr::Kind::FUNC: {
				return evo::Result<>();
			} break;
		}

		evo::debugFatalBreak("Unknown sema expr kind");
	}




	template<bool NEEDS_DEF>
	auto SemanticAnalyzer::wait_on_symbol_proc(
		evo::ArrayProxy<const SymbolProc::Namespace*> symbol_proc_namespaces, std::string_view ident_str
	) -> WaitOnSymbolProcResult {
		auto found_range = std::optional<evo::IterRange<SymbolProc::Namespace::const_iterator>>();
		for(const SymbolProc::Namespace* symbol_proc_namespace : symbol_proc_namespaces){
			const auto find = symbol_proc_namespace->equal_range(ident_str);

			if(find.first != symbol_proc_namespace->end()){
				found_range.emplace(find.first, find.second);
				break;
			}			
		}
		if(found_range.has_value() == false){
			return WaitOnSymbolProcResult::NOT_FOUND;
		}


		bool any_waiting = false;
		bool any_ready = false;
		for(auto& pair : *found_range){
			const SymbolProc::ID& found_symbol_proc_id = pair.second;
			SymbolProc& found_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(found_symbol_proc_id);

			const SymbolProc::WaitOnResult wait_on_result = [&](){
				if constexpr(NEEDS_DEF){
					return found_symbol_proc.waitOnDefIfNeeded(
						this->symbol_proc_id, this->context, found_symbol_proc_id
					);
				}else{
					return found_symbol_proc.waitOnDeclIfNeeded(
						this->symbol_proc_id, this->context, found_symbol_proc_id
					);
				}
			}();

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED: {
					any_ready = true;
				} break;

				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(found_symbol_proc_id);
					[[fallthrough]];
				}

				case SymbolProc::WaitOnResult::WAITING: {
					any_waiting = true;
				} break;

				case SymbolProc::WaitOnResult::WAS_ERRORED: {
					return WaitOnSymbolProcResult::EXISTS_BUT_ERRORED;
				} break;

				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: {
					// do nothing...
				} break;

				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED: {
					return WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED;
				} break;
			}
		}

		if(any_waiting){
			if(this->symbol_proc.shouldContinueRunning()){
				return WaitOnSymbolProcResult::SEMAS_READY;
			}else{
				return WaitOnSymbolProcResult::NEED_TO_WAIT;
			}
		}

		if(any_ready){ return WaitOnSymbolProcResult::SEMAS_READY; }

		return WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND;
	}



	auto SemanticAnalyzer::wait_on_symbol_proc_emit_error(
		WaitOnSymbolProcResult result, const auto& ident, std::string&& msg
	) -> void {
		switch(result){
			case WaitOnSymbolProcResult::NOT_FOUND: {
				this->emit_error(Diagnostic::Code::SEMA_NO_SYMBOL_IN_SCOPE_WITH_THAT_IDENT, ident, std::move(msg));
			} break;

			case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED: case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
				// do nothing...
			} break;

			case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
				this->emit_error(
					Diagnostic::Code::SEMA_NO_SYMBOL_IN_SCOPE_WITH_THAT_IDENT,
					ident,
					std::move(msg),
					Diagnostic::Info("The identifier was declared in a when conditional block that wasn't taken")
				);
			} break;

			case WaitOnSymbolProcResult::NEED_TO_WAIT: {
				evo::debugFatalBreak("WaitOnSymbolProcResult::NEED_TO_WAIT is not an error");
			} break;

			case WaitOnSymbolProcResult::SEMAS_READY: {
				evo::debugFatalBreak("WaitOnSymbolProcResult::SEMAS_READY is not an error");
			} break;
		}
	}







	auto SemanticAnalyzer::set_waiting_for_is_done(SymbolProc::ID target_id, SymbolProc::ID done_id) -> void {
		SymbolProc& target = this->context.symbol_proc_manager.getSymbolProc(target_id);

		const auto lock = std::scoped_lock(target.waiting_for_lock);


		evo::debugAssert(target.waiting_for.empty() == false, "Should never have empty list");

		for(size_t i = 0; i < target.waiting_for.size() - 1; i+=1){
			if(target.waiting_for[i] == done_id){
				target.waiting_for[i] = target.waiting_for.back();
				break;
			}
		}

		target.waiting_for.pop_back();

		if(
			target.waiting_for.empty()
			&& target.isTemplateSubSymbol() == false
			&& target.status == SymbolProc::Status::WAITING
		){
			target.setStatusInQueue();
			this->context.add_task_to_work_manager(target_id);
		}
	}




	auto SemanticAnalyzer::select_func_overload(
		evo::ArrayProxy<SelectFuncOverloadFuncInfo> func_infos,
		std::span<SelectFuncOverloadArgInfo> arg_infos,
		const auto& call_node,
		bool is_member_call,
		evo::SmallVector<Diagnostic::Info>&& instantiation_error_infos
	) -> evo::Result<size_t> {
		evo::debugAssert(func_infos.empty() == false, "need at least 1 function");

		struct OverloadScore{
			using Success = std::monostate;
			struct TooFewArgs{ size_t min_num; size_t got_num; bool accepts_different_nums; };
			struct TooManyArgs{ size_t max_num; size_t got_num; bool accepts_different_nums; };
			struct IntrinsicWrongNumArgs{ size_t required_num; size_t got_num; };
			struct TypeMismatch{ size_t arg_index; };
			struct ValueKindMismatch{ size_t arg_index; };
			struct InArgNotMovable{ size_t arg_index; };
			struct IncorrectLabel{ size_t arg_index; };
			struct IntrinsicArgWithLabel{ size_t arg_index; };

			using Reason = evo::Variant<
				Success,
				TooFewArgs,
				TooManyArgs,
				IntrinsicWrongNumArgs,
				TypeMismatch,
				ValueKindMismatch,
				InArgNotMovable,
				IncorrectLabel,
				IntrinsicArgWithLabel
			>;
			
			unsigned score;
			Reason reason;

			OverloadScore(unsigned _score) : score(_score), reason(std::monostate()) {};
			OverloadScore(Reason _reason) : score(0), reason(_reason) {};
		};
		auto scores = evo::SmallVector<OverloadScore>();
		scores.reserve(func_infos.size());

		unsigned best_score = 0;
		size_t best_score_index = 0;
		bool found_matching_best_score = false;

		
		for(size_t func_i = 0; const SelectFuncOverloadFuncInfo& func_info : func_infos){
			EVO_DEFER([&](){ func_i += 1; });

			unsigned current_score = 0;

			bool need_to_skip_this_arg = false; 
			

			if(
				func_info.func_id.is<SelectFuncOverloadFuncInfo::IntrinsicFlag>()
				|| func_info.func_id.is<SelectFuncOverloadFuncInfo::BuiltinTypeMethodFlag>()
			){
				if(arg_infos.size() != func_info.func_type.params.size()){
					scores.emplace_back(
						OverloadScore::IntrinsicWrongNumArgs(func_info.func_type.params.size(), arg_infos.size())
					);
					continue;
				}

			}else{
				const sema::Func& sema_func = [&]() -> const sema::Func& {
					if(func_info.func_id.is<sema::Func::ID>()){
						return this->context.getSemaBuffer().getFunc(func_info.func_id.as<sema::Func::ID>());
					}else{
						return this->context.getSemaBuffer().getFunc(
							*func_info.func_id.as<sema::TemplatedFunc::InstantiationInfo>().instantiation.funcID
						);
					}
				}();

				need_to_skip_this_arg = is_member_call && sema_func.isMethod(this->context) == false;

				const size_t num_args = arg_infos.size() - size_t(need_to_skip_this_arg);

				if(num_args < sema_func.minNumArgs){
					scores.emplace_back(OverloadScore::TooFewArgs(
						sema_func.minNumArgs, num_args, sema_func.minNumArgs != func_info.func_type.params.size()
					));
					continue;
				}

				if(num_args > func_info.func_type.params.size()){
					scores.emplace_back(OverloadScore::TooManyArgs(
						func_info.func_type.params.size(),
						num_args,
						sema_func.minNumArgs != func_info.func_type.params.size()
					));
					continue;
				}
			}


			bool arg_checking_failed = false;
			for(size_t arg_i = 0; SelectFuncOverloadArgInfo& arg_info : arg_infos){
				EVO_DEFER([&](){ arg_i += 1; });

				if(need_to_skip_this_arg){
					arg_i -= 1;
					continue;
				}


				///////////////////////////////////
				// check type mismatch

				const TypeCheckInfo& type_check_info = this->type_check<false, false>(
					this->context.type_manager.decayType<false, false>(func_info.func_type.params[arg_i].typeID),
					arg_info.term_info,
					"",
					arg_info.ast_node
				);

				if(type_check_info.ok == false){
					scores.emplace_back(OverloadScore::TypeMismatch(arg_i));
					arg_checking_failed = true;
					break;
				}

				if(type_check_info.requires_implicit_conversion == false){ current_score += 1; }


				///////////////////////////////////
				// value kind

				switch(func_info.func_type.params[arg_i].kind){
					case BaseType::Function::Param::Kind::READ: {
						// accepts any value kind
					} break;

					case BaseType::Function::Param::Kind::MUT: {
						if(arg_info.term_info.is_const()){
							scores.emplace_back(OverloadScore::ValueKindMismatch(arg_i));
							arg_checking_failed = true;
							break;
						}


						if(arg_info.term_info.is_concrete() == false){
							const bool param_is_not_this = [&](){
								if(arg_i > 0){ return true; }

								if(
									func_info.func_id.is<SelectFuncOverloadFuncInfo::IntrinsicFlag>()
									|| func_info.func_id.is<SelectFuncOverloadFuncInfo::BuiltinTypeMethodFlag>()
								){
									return true;

								}else{
									const sema::Func& sema_func = [&]() -> const sema::Func& {
										if(func_info.func_id.is<sema::Func::ID>()){
											return this->context.getSemaBuffer().getFunc(
												func_info.func_id.as<sema::Func::ID>()
											);
										}else{
											return this->context.getSemaBuffer().getFunc(
												*func_info.func_id.as<sema::TemplatedFunc::InstantiationInfo>()
													.instantiation.funcID
											);
										}
									}();

									return sema_func.isMethod(this->context) == false;
								}
							}();

							if(param_is_not_this){
								scores.emplace_back(OverloadScore::ValueKindMismatch(arg_i));
								arg_checking_failed = true;
								break;
							}
						}

						current_score += 1; // add 1 to prefer mut over read
					} break;

					case BaseType::Function::Param::Kind::IN: {
						if(arg_info.term_info.is_ephemeral() == false){
							scores.emplace_back(OverloadScore::ValueKindMismatch(arg_i));
							arg_checking_failed = true;
							break;
						}

						if(arg_info.term_info.getExpr().kind() != sema::Expr::Kind::COPY){
							if(arg_info.term_info.type_id.is<TypeInfo::ID>()){
								const TypeInfo::ID arg_type_info_id = arg_info.term_info.type_id.as<TypeInfo::ID>();
								if(this->context.getTypeManager().isMovable(arg_type_info_id) == false){
									scores.emplace_back(OverloadScore::InArgNotMovable(arg_i));
									arg_checking_failed = true;
									break;
								}
							}else{
								evo::debugAssert(
									arg_info.term_info.value_category == TermInfo::ValueCategory::EPHEMERAL_FLUID,
									"Unknown value category for argument"
								);
							}
						}
					} break;

					case BaseType::Function::Param::Kind::C: {
						if(arg_info.term_info.is_ephemeral() == false){
							scores.emplace_back(OverloadScore::ValueKindMismatch(arg_i));
							arg_checking_failed = true;
							break;
						}
					} break;
				}


				///////////////////////////////////
				// check label

				if(arg_info.label.has_value()){
					if(
						func_info.func_id.is<SelectFuncOverloadFuncInfo::IntrinsicFlag>()
						|| func_info.func_id.is<SelectFuncOverloadFuncInfo::BuiltinTypeMethodFlag>()
					){
						scores.emplace_back(OverloadScore::IntrinsicArgWithLabel(arg_i));
						arg_checking_failed = true;
						break;

					}else{
						const sema::Func& sema_func = [&]() -> const sema::Func& {
							if(func_info.func_id.is<sema::Func::ID>()){
								return this->context.getSemaBuffer().getFunc(func_info.func_id.as<sema::Func::ID>());
							}else{
								return this->context.getSemaBuffer().getFunc(
									*func_info.func_id.as<sema::TemplatedFunc::InstantiationInfo>().instantiation.funcID
								);
							}
						}();

						const std::string_view arg_label = 
							this->source.getTokenBuffer()[*arg_info.label].getString();

						const std::string_view param_name = 
							sema_func.getParamName(sema_func.params[arg_i], this->context.getSourceManager());

						if(arg_label != param_name){
							scores.emplace_back(OverloadScore::IncorrectLabel(arg_i));
							arg_checking_failed = true;
							break;
						}
					}
				}


				///////////////////////////////////
				// done checking arg

				current_score += 1;
			}
			if(arg_checking_failed){ continue; }

			current_score += 1;
			scores.emplace_back(current_score);
			if(best_score < current_score){
				best_score = current_score;
				best_score_index = func_i;
				found_matching_best_score = false;
			}else if(best_score == current_score){
				found_matching_best_score = true;
			}
		}

		if(best_score == 0){ // found no matches
			auto infos = evo::SmallVector<Diagnostic::Info>();

			for(size_t i = 0; const OverloadScore& score : scores){
				EVO_DEFER([&](){ i += 1; });

				const auto get_func_location = [&]() -> Diagnostic::Location {
					if(func_infos[i].func_id.is<sema::Func::ID>()){
						return this->get_location(func_infos[i].func_id.as<sema::Func::ID>());

					}else if(func_infos[i].func_id.is<sema::TemplatedFunc::InstantiationInfo>()){
						return this->get_location(
							*func_infos[i].func_id.as<sema::TemplatedFunc::InstantiationInfo>().instantiation.funcID
						);

					}else{
						return Diagnostic::Location::NONE;
					}
				};

			
				score.reason.visit([&](const auto& reason) -> void {
					using ReasonT = std::decay_t<decltype(reason)>;
					
					if constexpr(std::is_same<ReasonT, OverloadScore::Success>()){
						evo::fatalBreak("Success should not have a score of 0");

					}else if constexpr(std::is_same<ReasonT, OverloadScore::TooFewArgs>()){
						if(reason.accepts_different_nums){
							infos.emplace_back(
								std::format(
									"Failed to match: too few arguments (requires at least {}, got {})",
									is_member_call ? reason.min_num - 1 : reason.min_num,
									is_member_call ? reason.got_num - 1 : reason.got_num
								),
								get_func_location()
							);
							
						}else{
							infos.emplace_back(
								std::format(
									"Failed to match: too few arguments (requires {}, got {})",
									is_member_call ? reason.min_num - 1 : reason.min_num,
									is_member_call ? reason.got_num - 1 : reason.got_num
								),
								get_func_location()
							);
						}

					}else if constexpr(std::is_same<ReasonT, OverloadScore::TooManyArgs>()){
						if(reason.accepts_different_nums){
							infos.emplace_back(
								std::format(
									"Failed to match: too many arguments (requires at most {}, got {})",
									is_member_call ? reason.max_num - 1 : reason.max_num,
									is_member_call ? reason.got_num - 1 : reason.got_num
								),
								get_func_location()
							);
							
						}else{
							infos.emplace_back(
								std::format(
									"Failed to match: too many arguments (requires {}, got {})",
									is_member_call ? reason.max_num - 1 : reason.max_num,
									is_member_call ? reason.got_num - 1 : reason.got_num
								),
								get_func_location()
							);
						}

					}else if constexpr(std::is_same<ReasonT, OverloadScore::IntrinsicWrongNumArgs>()){
						infos.emplace_back(
							std::format(
								"Failed to match: wrong number of arguments (requires {}, got {})",
								reason.required_num,
								reason.got_num
							),
							get_func_location()
						);

					}else if constexpr(std::is_same<ReasonT, OverloadScore::TypeMismatch>()){
						const TypeInfo::ID expected_type_id = func_infos[i].func_type.params[reason.arg_index].typeID;
						const TermInfo& got_arg = arg_infos[reason.arg_index].term_info;

						const bool func_is_method = [&](){
							if(is_member_call == false){ return false; }

							if(func_infos[i].func_id.is<sema::Func::ID>()){
								return this->context.getSemaBuffer()
									.getFunc(func_infos[i].func_id.as<sema::Func::ID>())
									.isMethod(this->context);
							}else if(func_infos[i].func_id.is<sema::TemplatedFunc::InstantiationInfo>()){
								return this->context.getSemaBuffer()
									.getFunc(
										*func_infos[i].func_id.as<sema::TemplatedFunc::InstantiationInfo>()
											.instantiation.funcID
									).isMethod(this->context);
							}else{
								return false;
							}
						}();

						infos.emplace_back(
							std::format(
								"Failed to match: argument (index: {}) type mismatch, "
									"and cannot be implicitly converted",
								reason.arg_index - size_t(func_is_method)
							),
							get_func_location(),
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info(
									"This argument:", this->get_location(arg_infos[reason.arg_index].ast_node)
								),
								Diagnostic::Info(std::format("Argument type:  {}", this->print_term_type(got_arg))),
								Diagnostic::Info(
									std::format(
										"Parameter type: {}",
										this->context.getTypeManager().printType(expected_type_id, this->context)
									)
								),
							}
						);

					}else if constexpr(std::is_same<ReasonT, OverloadScore::ValueKindMismatch>()){
						// This is done this way beause the IILE version causes an internal compiler error in MSVC
						// 	I didn't report because I didn't want to spend the time figuring out more info
						// TODO(FUTURE): Is this still a problem?
						bool is_method_this_param = false;
						do{
							if(reason.arg_index != 0){ break; }

							if(func_infos[i].func_id.is<sema::Func::ID>()){
								is_method_this_param = this->context.getSemaBuffer()
									.getFunc(func_infos[i].func_id.as<sema::Func::ID>())
									.isMethod(this->context);
							}else if(func_infos[i].func_id.is<sema::TemplatedFunc::InstantiationInfo>()){
								is_method_this_param = this->context.getSemaBuffer()
									.getFunc(
										*func_infos[i].func_id.as<sema::TemplatedFunc::InstantiationInfo>()
											.instantiation.funcID
									).isMethod(this->context);
							}
						}while(false);

						if(is_method_this_param){
							auto sub_infos = evo::SmallVector<Diagnostic::Info>();

							switch(func_infos[i].func_type.params[reason.arg_index].kind){
								case BaseType::Function::Param::Kind::READ: {
									evo::debugFatalBreak("Read parameters should never fail to accept value kind");
								} break;

								case BaseType::Function::Param::Kind::MUT: {
									sub_infos.emplace_back(
										"[this] parameters that are [mut] can only accept values that are mutable"
									);
								} break;

								case BaseType::Function::Param::Kind::IN: {
									sub_infos.emplace_back(
										"[this] parameters that are [in] can only accept values that are ephemeral"
									);
								} break;

								case BaseType::Function::Param::Kind::C: {
									evo::debugFatalBreak("Unexpected result (assumed impossible to have a C [this])");
								} break;
							}

							infos.emplace_back(
								std::format(
									"Failed to match: method target value kind mismatch", reason.arg_index
								),
								get_func_location(),
								std::move(sub_infos)
							);

						}else{
							auto sub_infos = evo::SmallVector<Diagnostic::Info>();
							sub_infos.emplace_back(
								"This argument:", this->get_location(arg_infos[reason.arg_index].ast_node)
							);

							switch(func_infos[i].func_type.params[reason.arg_index].kind){
								case BaseType::Function::Param::Kind::READ: {
									evo::debugFatalBreak("Read parameters should never fail to accept value kind");
								} break;

								case BaseType::Function::Param::Kind::MUT: {
									sub_infos.emplace_back(
										"[mut] parameters can only accept values that are concrete and mutable"
									);
								} break;

								case BaseType::Function::Param::Kind::IN: {
									sub_infos.emplace_back("[in] parameters can only accept ephemeral values");
								} break;

								case BaseType::Function::Param::Kind::C: {
									sub_infos.emplace_back("[c] parameters can only accept ephemeral values");
								} break;
							}

							infos.emplace_back(
								std::format(
									"Failed to match: argument (index: {}) value kind mismatch", reason.arg_index
								),
								get_func_location(),
								std::move(sub_infos)
							);
						}


					}else if constexpr(std::is_same<ReasonT, OverloadScore::InArgNotMovable>()){
						infos.emplace_back(
							std::format("Failed to match: argument (index: {}) is not movable", reason.arg_index),
							get_func_location(),
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info(
									"This argument:", this->get_location(arg_infos[reason.arg_index].ast_node)
								),
							}
						);


					}else if constexpr(std::is_same<ReasonT, OverloadScore::IncorrectLabel>()){
						const sema::Func& sema_func =
							this->context.getSemaBuffer().getFunc(func_infos[i].func_id.as<sema::Func::ID>());

						infos.emplace_back(
							std::format("Failed to match: argument (index: {}) has incorrect label", reason.arg_index),
							get_func_location(),
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info("This label:", this->get_location(*arg_infos[reason.arg_index].label)),
								Diagnostic::Info(
									std::format(
										"Expected label: \"{}\"", 
										sema_func.getParamName(
											sema_func.params[reason.arg_index], this->context.getSourceManager()
										)
									)
								),
							}
						);


					}else if constexpr(std::is_same<ReasonT, OverloadScore::IntrinsicArgWithLabel>()){
						infos.emplace_back(
							std::format("Failed to match: argument (index: {}) has a label", reason.arg_index),
							this->get_location(*arg_infos[reason.arg_index].label),
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info("Arguments to intrinsic functions cannot have labels"),
							}
						);

					}else{
						static_assert(false, "Unsupported overload score reason");
					}
				});
			}

			for(Diagnostic::Info& instantiation_error_info : instantiation_error_infos){
				infos.emplace_back(std::move(instantiation_error_info));
			}

			this->emit_error(
				Diagnostic::Code::SEMA_NO_MATCHING_FUNCTION,
				call_node,
				"No matching function overload found",
				std::move(infos)
			);
			return evo::resultError;


		}else if(found_matching_best_score){ // found multiple matches
			auto infos = evo::SmallVector<Diagnostic::Info>();
			for(size_t i = 0; const OverloadScore& score : scores){
				EVO_DEFER([&](){ i += 1; });

				if(score.score == best_score){
					if(func_infos[i].func_id.is<sema::Func::ID>()){
						infos.emplace_back(
							"Could be this one:", this->get_location(func_infos[i].func_id.as<sema::Func::ID>())
						);

					}else if(func_infos[i].func_id.is<sema::TemplatedFunc::InstantiationInfo>()){
						infos.emplace_back(
							"Could be this one:",
							this->get_location(
								*func_infos[i].func_id.as<sema::TemplatedFunc::InstantiationInfo>().instantiation.funcID
							)
						);

					}else{
						// infos.emplace_back("Could be this one:", Diagnostic::Location::NONE);
					}
				}
			}

			this->emit_error(
				Diagnostic::Code::SEMA_MULTIPLE_MATCHING_FUNCTION_OVERLOADS,
				call_node,
				"Multiple matching function overloads found",
				std::move(infos)
			);
			return evo::resultError;
		}


		const SelectFuncOverloadFuncInfo& selected_func = func_infos[best_score_index];

		bool is_first = true;
		for(size_t i = 0; SelectFuncOverloadArgInfo& arg_info : arg_infos){
			if(is_first && is_member_call){
				is_first = false;

				const sema::Func& selected_sema_func = [&]() -> const sema::Func& {
					if(selected_func.func_id.is<sema::Func::ID>()){
						return this->context.getSemaBuffer().getFunc(selected_func.func_id.as<sema::Func::ID>());
					}else{
						return this->context.getSemaBuffer().getFunc(
							*selected_func.func_id.as<sema::TemplatedFunc::InstantiationInfo>().instantiation.funcID
						);
					}
				}();

				if(selected_sema_func.isMethod(this->context) == false){ continue; }
			}

			is_first = false;

			// implicitly convert all the required args
			const TypeInfo& param_id_type_info =
				this->context.getTypeManager().getTypeInfo(selected_func.func_type.params[i].typeID);
			if(param_id_type_info.baseTypeID().kind() != BaseType::Kind::INTERFACE){
				if(this->type_check<true, true>(
					this->context.type_manager.decayType<false, false>(selected_func.func_type.params[i].typeID),
					arg_info.term_info,
					"Function call argument",
					arg_info.ast_node
				).ok == false){
					evo::debugFatalBreak("This should not be able to fail");
				}
			}

			i += 1;
		}

		return best_score_index;
	}


	template<bool IS_COMPTIME, bool ERRORS>
	auto SemanticAnalyzer::func_call_impl(
		const AST::FuncCall& func_call,
		const TermInfo& target_term_info,
		evo::ArrayProxy<SymbolProc::TermInfoID> args,
		evo::ArrayProxy<SymbolProc::TermInfoID> template_args
	) -> evo::Expected<FuncCallImplData, bool> {
		TypeManager& type_manager = this->context.type_manager;

		auto func_infos = evo::SmallVector<SelectFuncOverloadFuncInfo>();
		auto instantiation_infos = evo::SmallVector<sema::TemplatedFunc::InstantiationInfo>();

		auto method_this_term_info = std::optional<TermInfo>();

		auto template_overload_match_infos = evo::SmallVector<std::optional<TemplateOverloadMatchFail>>();

		switch(target_term_info.value_category){
			case TermInfo::ValueCategory::FUNCTION: case TermInfo::ValueCategory::FUNCTION_PUB_REQUIRED:
			case TermInfo::ValueCategory::FUNCTION_NOT_PRIV_REQUIRED: {
				using FuncOverload = evo::Variant<sema::Func::ID, sema::TemplatedFunc::ID>;
				for(const FuncOverload& func_overload : target_term_info.type_id.as<TermInfo::FuncOverloadList>()){
					if(func_overload.is<sema::Func::ID>()){
						const sema::Func& sema_func =
							this->context.getSemaBuffer().getFunc(func_overload.as<sema::Func::ID>());
						const BaseType::Function& func_type = type_manager.getFunction(sema_func.typeID);
						func_infos.emplace_back(func_overload.as<sema::Func::ID>(), func_type);

					}else{
						evo::debugAssert(func_overload.is<sema::TemplatedFunc::ID>(), "Unknown overload id");
						
						evo::Expected<sema::TemplatedFunc::InstantiationInfo, TemplateOverloadMatchFail> template_res =
							this->get_select_func_overload_func_info_for_template(
								func_call, func_overload.as<sema::TemplatedFunc::ID>(), args, template_args, false
							);

						if(template_res.has_value() == false){
							template_overload_match_infos.emplace_back(template_res.error());
							continue;
						}
						template_overload_match_infos.emplace_back(std::nullopt);
						instantiation_infos.emplace_back(std::move(template_res.value()));
					}
				}
			} break;

			case TermInfo::ValueCategory::METHOD_CALL: case TermInfo::ValueCategory::INTERFACE_CALL: {
				using FuncOverload = evo::Variant<sema::Func::ID, sema::TemplatedFunc::ID>;

				for(const FuncOverload& func_overload : target_term_info.type_id.as<TermInfo::FuncOverloadList>()){
					if(func_overload.is<sema::Func::ID>()){
						const sema::Func& sema_func =
							this->context.getSemaBuffer().getFunc(func_overload.as<sema::Func::ID>());
						const BaseType::Function& func_type = type_manager.getFunction(sema_func.typeID);
						func_infos.emplace_back(func_overload.as<sema::Func::ID>(), func_type);

					}else{
						evo::debugAssert(func_overload.is<sema::TemplatedFunc::ID>(), "Unknown overload id");
						
						evo::Expected<sema::TemplatedFunc::InstantiationInfo, TemplateOverloadMatchFail> template_res =
							this->get_select_func_overload_func_info_for_template(
								func_call, func_overload.as<sema::TemplatedFunc::ID>(), args, template_args, true
							);

						if(template_res.has_value() == false){
							template_overload_match_infos.emplace_back(template_res.error());
							continue;
						}
						template_overload_match_infos.emplace_back(std::nullopt);
						instantiation_infos.emplace_back(std::move(template_res.value()));
					}
				}

				const sema::FakeTermInfo& fake_term_info =
					this->context.getSemaBuffer().getFakeTermInfo(target_term_info.getExpr().fakeTermInfoID());

				method_this_term_info.emplace(TermInfo::fromFakeTermInfo(fake_term_info));
			} break;

			case TermInfo::ValueCategory::POLY_INTERFACE_CALL: {
				using FuncOverload = evo::Variant<sema::Func::ID, sema::TemplatedFunc::ID>;
				for(const FuncOverload& func_overload : target_term_info.type_id.as<TermInfo::FuncOverloadList>()){
					const sema::Func& sema_func =
						this->context.getSemaBuffer().getFunc(func_overload.as<sema::Func::ID>());
					const BaseType::Function& func_type = type_manager.getFunction(sema_func.typeID);
					func_infos.emplace_back(func_overload.as<sema::Func::ID>(), func_type);
				}

				const sema::FakeTermInfo& fake_term_info =
					this->context.getSemaBuffer().getFakeTermInfo(target_term_info.getExpr().fakeTermInfoID());

				method_this_term_info.emplace(TermInfo::fromFakeTermInfo(fake_term_info));


				const TypeInfo& method_this_type_info = 
					this->context.getTypeManager().getTypeInfo(method_this_term_info->type_id.as<TypeInfo::ID>());

				const BaseType::PolyInterfaceRef& poly_interface_ref =
					this->context.getTypeManager().getPolyInterfaceRef(
						method_this_type_info.baseTypeID().polyInterfaceRefID()
					);

				method_this_term_info->type_id = this->context.type_manager.getOrCreateTypeInfo(
					TypeInfo(BaseType::ID(poly_interface_ref.interfaceID))
				);
			} break;

			case TermInfo::ValueCategory::INTRINSIC_FUNC: {
				const TypeInfo::ID type_info_id = target_term_info.type_id.as<TypeInfo::ID>();
				const TypeInfo& type_info = type_manager.getTypeInfo(type_info_id);
				const BaseType::Function& func_type = type_manager.getFunction(type_info.baseTypeID().funcID());
				func_infos.emplace_back(SelectFuncOverloadFuncInfo::IntrinsicFlag{}, func_type);
			} break;

			case TermInfo::ValueCategory::TEMPLATE_INTRINSIC_FUNC: {
				auto instantiation_args = evo::SmallVector<std::optional<TypeInfo::VoidableID>>();
				for(const SymbolProc::TermInfoID& arg : template_args){
					const TermInfo& arg_term_info = this->get_term_info(arg);

					if(arg_term_info.value_category != TermInfo::ValueCategory::TYPE){
						instantiation_args.emplace_back();
					}else{
						instantiation_args.emplace_back(arg_term_info.type_id.as<TypeInfo::VoidableID>());
					}
				}
				const Context::TemplateIntrinsicFuncInfo& func_info = this->context.getTemplateIntrinsicFuncInfo(
					target_term_info.type_id.as<TemplateIntrinsicFunc::Kind>()
				);

				const BaseType::ID instantiated_type = this->context.type_manager.getOrCreateFunction(
					func_info.getTypeInstantiation(instantiation_args)
				);

				func_infos.emplace_back(
					SelectFuncOverloadFuncInfo::IntrinsicFlag{},
					this->context.getTypeManager().getFunction(instantiated_type.funcID())
				);
			} break;

			case TermInfo::ValueCategory::BUILTIN_TYPE_METHOD: {
				const TypeInfo::ID type_info_id = target_term_info.type_id.as<TermInfo::BuiltinTypeMethod>().typeID;
				const TypeInfo& type_info = type_manager.getTypeInfo(type_info_id);
				const BaseType::Function& func_type = type_manager.getFunction(type_info.baseTypeID().funcID());
				func_infos.emplace_back(SelectFuncOverloadFuncInfo::BuiltinTypeMethodFlag{}, func_type);
			} break;

			default: {
				this->emit_error(
					Diagnostic::Code::SEMA_CANNOT_CALL_LIKE_FUNCTION,
					func_call.target,
					"Cannot call expression like a function"
				);
				return evo::Unexpected(true);
			} break;
		}


		auto instantiation_error_infos = evo::SmallVector<Diagnostic::Info>();

		if(instantiation_infos.empty()){
			if(template_overload_match_infos.empty() == false){
				const TermInfo::FuncOverloadList& func_overload_list =
					target_term_info.type_id.as<TermInfo::FuncOverloadList>();

				for(size_t i = 0; const std::optional<TemplateOverloadMatchFail>& info : template_overload_match_infos){
					EVO_DEFER([&](){ i += 1; });

					const auto get_func_location = [&]() -> Diagnostic::Location {
						if(func_overload_list[i].is<sema::Func::ID>()){
							return this->get_location(func_overload_list[i].as<sema::Func::ID>());
						}else{
							return this->get_location(func_overload_list[i].as<sema::TemplatedFunc::ID>());
						}
					};

					if(info.has_value() == false){ continue; }
					
					info->reason.visit([&](const auto& reason) -> void {
						using ReasonT = std::decay_t<decltype(reason)>;

						if constexpr(std::is_same<ReasonT, TemplateOverloadMatchFail::Handled>()){
							return;

						}else if constexpr(std::is_same<ReasonT, TemplateOverloadMatchFail::TooFewTemplateArgs>()){
							if(reason.accepts_different_nums){
								instantiation_error_infos.emplace_back(
									std::format(
										"Failed to match: too few template arguments (requires at least {}, got {})",
										reason.min_num,
										reason.got_num
									),
									get_func_location()
								);
								
							}else{
								instantiation_error_infos.emplace_back(
									std::format(
										"Failed to match: too few template arguments (requires {}, got {})",
										reason.min_num,
										reason.got_num
									),
									get_func_location()
								);
							}

						}else if constexpr(std::is_same<ReasonT, TemplateOverloadMatchFail::TooManyTemplateArgs>()){
							if(reason.accepts_different_nums){
								instantiation_error_infos.emplace_back(
									std::format(
										"Failed to match: too many template arguments (requires at most {}, got {})",
										reason.max_num,
										reason.got_num
									),
									get_func_location()
								);
								
							}else{
								instantiation_error_infos.emplace_back(
									std::format(
										"Failed to match: too many template arguments (requires {}, got {})",
										reason.max_num,
										reason.got_num
									),
									get_func_location()
								);
							}

						}else if constexpr(std::is_same<ReasonT, TemplateOverloadMatchFail::TemplateArgWrongKind>()){
							const AST::TemplatedExpr& templated_expr =
								this->source.getASTBuffer().getTemplatedExpr(func_call.target);

							if(reason.supposed_to_be_expr){
								instantiation_error_infos.emplace_back(
									std::format(
										"Failed to match: template parameter (index: {}) expects an expression, "
											"got a type",
										reason.arg_index
									),
									get_func_location(),
									evo::SmallVector<Diagnostic::Info>{
										Diagnostic::Info(
											"This argument:", this->get_location(templated_expr.args[reason.arg_index])
										),
									}
								);
							}else{
								instantiation_error_infos.emplace_back(
									std::format(
										"Failed to match: template parameter (index: {}) expects a type, "
											"got an expression",
										reason.arg_index
									),
									get_func_location(),
									evo::SmallVector<Diagnostic::Info>{
										Diagnostic::Info(
											"This argument:", this->get_location(templated_expr.args[reason.arg_index])
										),
									}
								);
							}

						}else if constexpr(std::is_same<ReasonT, TemplateOverloadMatchFail::WrongNumArgs>()){
							instantiation_error_infos.emplace_back(
								std::format(
									"Failed to match: wrong number of arguments (requires {}, got {})",
									reason.expected_num,
									reason.got_num
								),
								get_func_location()
							);

						}else if constexpr(std::is_same<ReasonT, TemplateOverloadMatchFail::CantDeduceArgType>()){
							instantiation_error_infos.emplace_back(
								std::format(
									"Failed to match: can't deduce type from argument (index: {})",
									reason.arg_index
								),
								get_func_location(),
								evo::SmallVector<Diagnostic::Info>{
									Diagnostic::Info(
										"This argument:", this->get_location(func_call.args[reason.arg_index].value)
									),
									Diagnostic::Info(
										std::format(
											"Argument type: {}",
											this->print_term_type(this->get_term_info(args[reason.arg_index]))
										)
									)
								}
							);
							
						}else{
							static_assert(false, "Unsupported TemplateOverloadMatchFail");
						}
					});
				}

				if(func_infos.empty()){
					this->emit_error(
						Diagnostic::Code::SEMA_NO_MATCHING_FUNCTION,
						func_call.target,
						"No matching function overload found",
						std::move(instantiation_error_infos)
					);
					return evo::Unexpected(true);
				}
			}

		}else{
			bool any_waiting_or_ready = false;
			
			for(const sema::TemplatedFunc::InstantiationInfo& instantiation_info : instantiation_infos){
				std::optional<SymbolProc::ID> loaded_instantiation_symbol_proc_id =
					instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed);

				while(loaded_instantiation_symbol_proc_id.has_value() == false){ // wait for it to be ready
					std::this_thread::yield();
					loaded_instantiation_symbol_proc_id =
						instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed);
				}

				SymbolProc& instantiation_symbol_proc =
					this->context.symbol_proc_manager.getSymbolProc(*loaded_instantiation_symbol_proc_id);

				SymbolProc::WaitOnResult wait_on_result = instantiation_symbol_proc.waitOnDeclIfNeeded(
					this->symbol_proc_id, this->context, *loaded_instantiation_symbol_proc_id
				);


				switch(wait_on_result){
					case SymbolProc::WaitOnResult::NOT_NEEDED:                 any_waiting_or_ready = true; break;
					case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
						this->context.symbol_proc_manager.symbol_proc_unsuspended();
						this->context.add_task_to_work_manager(*loaded_instantiation_symbol_proc_id);
						[[fallthrough]];
					}
					case SymbolProc::WaitOnResult::WAITING:                    any_waiting_or_ready = true; break;
					case SymbolProc::WaitOnResult::WAS_ERRORED:                return evo::Unexpected(true);
					case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: break;
					case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return evo::Unexpected(true);
				}
			}

			if(any_waiting_or_ready == false){
				this->emit_error(
					Diagnostic::Code::SEMA_NO_MATCHING_FUNCTION,
					func_call.target,
					"No function overload found",
					Diagnostic::Info("All were passed by when conditionals")
				);
				return evo::Unexpected(true);
			}


			if(this->symbol_proc.shouldContinueRunning() == false){
				return evo::Unexpected(false);
			}

			using ErroredReason = sema::TemplatedFunc::Instantiation::ErroredReason;

			auto instantiation_errors = evo::SmallVector<ErroredReason>();

			for(const sema::TemplatedFunc::InstantiationInfo& instantiation_info : instantiation_infos){
				if(instantiation_info.instantiation.errored()){
					const SymbolProc& instantiation_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(
						*instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed)
					);

					const SymbolProc::FuncInfo& func_info =
						instantiation_symbol_proc.extra_info.as<SymbolProc::FuncInfo>();

					if(
						func_info.instantiation->errored() 
						&& func_info.instantiation->errored_reason
							.is<sema::TemplatedFunc::Instantiation::ErroredReasonErroredAfterDecl>() == false
					){
						instantiation_errors.emplace_back(func_info.instantiation->errored_reason);
					}else{
						return evo::Unexpected(true);
					}
					continue;
				}

				const sema::Func& instantiated_func = this->context.getSemaBuffer().getFunc(
					*instantiation_info.instantiation.funcID
				);

				func_infos.emplace_back(
					instantiation_info, this->context.getTypeManager().getFunction(instantiated_func.typeID)
				);
			}

			for(size_t i = 0; const ErroredReason& instantiation_error : instantiation_errors){
				const auto get_func_location = [&]() -> Diagnostic::Location {
					const SymbolProc& symbol_proc = this->context.symbol_proc_manager.getSymbolProc(
						*instantiation_infos[i].instantiation.symbolProcID.load(std::memory_order::relaxed)
					);

					return Diagnostic::Location::get(
						symbol_proc.ast_node, this->context.getSourceManager()[symbol_proc.source_id]
					);
				};


				instantiation_error.visit([&](const auto& reason) -> void {
					using ReasonT = std::decay_t<decltype(reason)>;

					using Instantiation = sema::TemplatedFunc::Instantiation;

					if constexpr(std::is_same<ReasonT, std::monostate>()){
						evo::debugAssert("Template instantiation didn't error");

					}else if constexpr(
						std::is_same<ReasonT, Instantiation::ErroredReasonParamDeductionFailed>()
					){
						instantiation_error_infos.emplace_back(
							std::format(
								"Failed to match: failed to deduce type of parameter (index: {}) ", reason.arg_index
							),
							get_func_location(),
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info(
									"This argument:", this->get_location(func_call.args[reason.arg_index].value)
								),
								Diagnostic::Info(
									std::format(
										"Argument type: {}",
										this->print_term_type(this->get_term_info(args[reason.arg_index]))
									)
								)
							}
						);


					}else if constexpr(
						std::is_same<ReasonT, Instantiation::ErroredReasonArgTypeMismatch>()
					){
						instantiation_error_infos.emplace_back(
							std::format(
								"Failed to match: argument (index: {}) type mismatch, "
									"and cannot be implicitly converted",
								reason.arg_index
							),
							get_func_location(),
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info(
									"This argument:", this->get_location(func_call.args[reason.arg_index].value)
								),
								Diagnostic::Info(
									std::format(
										"Argument type:  {}",
										this->context.getTypeManager().printType(reason.got_type_id, this->context)
									)
								),
								Diagnostic::Info(
									std::format(
										"Parameter type: {}",
										this->context.getTypeManager().printType(reason.expected_type_id, this->context)
									)
								),
							}
						);

					}else if constexpr(
						std::is_same<ReasonT, Instantiation::ErroredReasonTypeDoesntImplInterface>()
					){
						instantiation_error_infos.emplace_back(
							std::format(
								"Failed to match: type of argument (index: {}) doesn't implement the interface",
								reason.arg_index
							),
							get_func_location(),
							evo::SmallVector<Diagnostic::Info>{
								Diagnostic::Info(
									"This argument:", this->get_location(func_call.args[reason.arg_index].value)
								),
								Diagnostic::Info(
									std::format(
										"Argument type:  {}",
										this->context.getTypeManager().printType(reason.got_type_id, this->context)
									)
								),
								Diagnostic::Info(
									std::format(
										"Interface type: {}",
										this->context.getTypeManager().printType(
											reason.interface_type_id, this->context
										)
									)
								),
							}
						);
					}else if constexpr(
						std::is_same<ReasonT, Instantiation::ErroredReasonErroredAfterDecl>()
					){
						evo::debugAssert("Errored after decl, shouldn't get here");

					}else{
						static_assert(false, "Unknown errored reason");
					}
				});

				i += 1;
			}

			if(func_infos.empty()){ // if all instantiations errored
				this->emit_error(
					Diagnostic::Code::SEMA_NO_MATCHING_FUNCTION,
					func_call.target,
					"No function overload found",
					std::move(instantiation_error_infos)
				);
				return evo::Unexpected(true);
			}
		}



		auto arg_infos = evo::SmallVector<SelectFuncOverloadArgInfo>();
		arg_infos.reserve(arg_infos.size() + size_t(method_this_term_info.has_value()));
		if(method_this_term_info.has_value()){
			if(func_call.target.kind() == AST::Kind::INFIX){
				const AST::Infix& target_infix = this->source.getASTBuffer().getInfix(func_call.target);
				arg_infos.emplace_back(*method_this_term_info, target_infix.lhs, std::nullopt);
			}else{
				const AST::TemplatedExpr& template_expr =
					this->source.getASTBuffer().getTemplatedExpr(func_call.target);
				const AST::Infix& target_infix = this->source.getASTBuffer().getInfix(template_expr.base);
				arg_infos.emplace_back(*method_this_term_info, target_infix.lhs, std::nullopt);
			}
		}
		for(size_t i = 0; const SymbolProc::TermInfoID& arg : args){
			TermInfo& arg_term_info = this->get_term_info(arg);

			if constexpr(IS_COMPTIME){
				if(arg_term_info.value_stage != TermInfo::ValueStage::COMPTIME){
					this->emit_error(
						Diagnostic::Code::SEMA_EXPR_NOT_COMPTIME,
						func_call.args[i].value,
						"Arguments in a comptime function call must have a value stage of comptime",
						Diagnostic::Info(
							std::format(
								"Value stage of the argument is {}",
								arg_term_info.value_stage == TermInfo::ValueStage::INTERPTIME ? "interptime" : "runtime"
							)
						)
					);
					return evo::Unexpected(true);
				}
			}else{
				if(this->expr_in_func_is_valid_value_stage(arg_term_info, func_call.args[i].value) == false){
					return evo::Unexpected(true);
				}

				if(
					arg_term_info.value_state != TermInfo::ValueState::INIT
					&& arg_term_info.value_state != TermInfo::ValueState::NOT_APPLICABLE
				){
					this->emit_error(
						Diagnostic::Code::SEMA_EXPR_WRONG_STATE,
						func_call.args[i].value,
						"Arguments to functions must be initialized"
					);
					return evo::Unexpected(true);
				}
			}

			arg_infos.emplace_back(arg_term_info, func_call.args[i].value, func_call.args[i].label);
			i += 1;
		}


		const evo::Result<size_t> selected_func_overload_index = this->select_func_overload(
			func_infos,
			arg_infos,
			func_call.target,
			method_this_term_info.has_value(),
			std::move(instantiation_error_infos)
		);
		if(selected_func_overload_index.isError()){ return evo::Unexpected(true); }


		if constexpr(ERRORS){
			if(func_infos[selected_func_overload_index.value()].func_type.hasErrorReturn() == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_DOESNT_ERROR,
					func_call,
					"Function doesn't error"
				);
				return evo::Unexpected(true);
			}
		}else{
			if(func_infos[selected_func_overload_index.value()].func_type.hasErrorReturn()){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ERRORS,
					func_call,
					"Function error not handled"
				);
				return evo::Unexpected(true);
			}
		}

		if(func_infos[selected_func_overload_index.value()].func_type.isUnsafe && this->currently_in_unsafe() == false){
			this->emit_error(
				Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
				func_call,
				"Call to unsafe function while not in an unsafe scope"
			);
			return evo::Unexpected(true);
		}


		switch(target_term_info.value_category){
			case TermInfo::ValueCategory::FUNCTION: case TermInfo::ValueCategory::INTERFACE_CALL: {
				const SelectFuncOverloadFuncInfo::FuncID& selected_func_id = 
					func_infos[selected_func_overload_index.value()].func_id;

				if(selected_func_id.is<sema::Func::ID>()){
					return FuncCallImplData(
						selected_func_id.as<sema::Func::ID>(),
						&this->context.sema_buffer.getFunc(selected_func_id.as<sema::Func::ID>()),
						func_infos[selected_func_overload_index.value()].func_type
					);

				}else{
					evo::debugAssert(
						selected_func_id.is<sema::TemplatedFunc::InstantiationInfo>(),
						"Unsupported func id type for this value category"
					);

					const sema::TemplatedFunc::InstantiationInfo& instantiation_info =
						selected_func_id.as<sema::TemplatedFunc::InstantiationInfo>();

					const SymbolProc::ID instantiation_symbol_proc_id = 
						*instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed);
					SymbolProc& instantiation_symbol_proc =
						this->context.symbol_proc_manager.getSymbolProc(instantiation_symbol_proc_id);

					if(instantiation_symbol_proc.unsuspendIfNeeded()){
						this->context.symbol_proc_manager.symbol_proc_unsuspended();

						sema::Func& sema_func = this->context.sema_buffer.funcs[
							*instantiation_info.instantiation.funcID
						];
						sema_func.status = sema::Func::Status::NOT_DONE;

						this->context.add_task_to_work_manager(instantiation_symbol_proc_id);
					}

					return FuncCallImplData(
						*instantiation_info.instantiation.funcID,
						&this->context.sema_buffer.getFunc(*instantiation_info.instantiation.funcID),
						func_infos[selected_func_overload_index.value()].func_type
					);
				}
			} break;

			case TermInfo::ValueCategory::FUNCTION_PUB_REQUIRED: {
				const SelectFuncOverloadFuncInfo::FuncID& selected_func_id = 
					func_infos[selected_func_overload_index.value()].func_id;

				if(selected_func_id.is<sema::Func::ID>()){
					const sema::Func& selected_func =
						this->context.sema_buffer.getFunc(selected_func_id.as<sema::Func::ID>());

					if(selected_func.attributes.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							func_call.target,
							"Selected function overload does not have the `#pub` attribute, "
								"and is not accessable in this scope",
							Diagnostic::Info(
								"Function defined here:", this->get_location(selected_func_id.as<sema::Func::ID>())
							)
						);
						return evo::Unexpected(true);
					}

					return FuncCallImplData(
						selected_func_id.as<sema::Func::ID>(),
						&selected_func,
						func_infos[selected_func_overload_index.value()].func_type
					);

				}else{
					evo::debugAssert(
						selected_func_id.is<sema::TemplatedFunc::InstantiationInfo>(),
						"Unsupported func id type for this value category"
					);

					const sema::TemplatedFunc::InstantiationInfo& instantiation_info =
						selected_func_id.as<sema::TemplatedFunc::InstantiationInfo>();

					const SymbolProc::ID instantiation_symbol_proc_id = 
						*instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed);
					SymbolProc& instantiation_symbol_proc =
						this->context.symbol_proc_manager.getSymbolProc(instantiation_symbol_proc_id);

					sema::Func& sema_func = this->context.sema_buffer.funcs[*instantiation_info.instantiation.funcID];

					if(sema_func.attributes.isPub == false){
						this->emit_error(
							Diagnostic::Code::SEMA_SYMBOL_NOT_PUB,
							func_call.target,
							"Selected function overload does not have the `#pub` attribute, "
								"and is not accessable in this scope",
							Diagnostic::Info(
								"Function defined here:", this->get_location(*instantiation_info.instantiation.funcID)
							)
						);
						return evo::Unexpected(true);
					}

					if(instantiation_symbol_proc.unsuspendIfNeeded()){
						this->context.symbol_proc_manager.symbol_proc_unsuspended();

						sema_func.status = sema::Func::Status::NOT_DONE;

						this->context.add_task_to_work_manager(instantiation_symbol_proc_id);
					}

					return FuncCallImplData(
						*instantiation_info.instantiation.funcID,
						&sema_func,
						func_infos[selected_func_overload_index.value()].func_type
					);
				}
			} break;

			case TermInfo::ValueCategory::FUNCTION_NOT_PRIV_REQUIRED: case TermInfo::ValueCategory::METHOD_CALL: {
				const SelectFuncOverloadFuncInfo::FuncID& selected_func_id = 
					func_infos[selected_func_overload_index.value()].func_id;

				if(selected_func_id.is<sema::Func::ID>()){
					const sema::Func& sema_func =
						this->context.sema_buffer.getFunc(selected_func_id.as<sema::Func::ID>());

					if(sema_func.attributes.isPriv && sema_func.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							func_call.target,
							"Selected function overload has the `#priv` attribute, and is not accessable in this scope",
							Diagnostic::Info(
								"Function defined here:", this->get_location(selected_func_id.as<sema::Func::ID>())
							)
						);
						return evo::Unexpected(true);
					}

					return FuncCallImplData(
						selected_func_id.as<sema::Func::ID>(),
						&this->context.sema_buffer.getFunc(selected_func_id.as<sema::Func::ID>()),
						func_infos[selected_func_overload_index.value()].func_type
					);

				}else{
					evo::debugAssert(
						selected_func_id.is<sema::TemplatedFunc::InstantiationInfo>(),
						"Unsupported func id type for this value category"
					);

					const sema::TemplatedFunc::InstantiationInfo& instantiation_info =
						selected_func_id.as<sema::TemplatedFunc::InstantiationInfo>();

					const SymbolProc::ID instantiation_symbol_proc_id = 
						*instantiation_info.instantiation.symbolProcID.load(std::memory_order::relaxed);
					SymbolProc& instantiation_symbol_proc =
						this->context.symbol_proc_manager.getSymbolProc(instantiation_symbol_proc_id);

					sema::Func& sema_func = this->context.sema_buffer.funcs[*instantiation_info.instantiation.funcID];

					if(sema_func.attributes.isPriv && sema_func.parent != this->scope.getCurrentTypeScopeIfExists()){
						this->emit_error(
							Diagnostic::Code::SEMA_ACCESSOR_MEMBER_IS_PRIV,
							func_call.target,
							"Selected function overload has the `#priv` attribute, and is not accessable in this scope",
							Diagnostic::Info(
								"Function defined here:", this->get_location(*instantiation_info.instantiation.funcID)
							)
						);
						return evo::Unexpected(true);
					}

					if(instantiation_symbol_proc.unsuspendIfNeeded()){
						this->context.symbol_proc_manager.symbol_proc_unsuspended();

						sema_func.status = sema::Func::Status::NOT_DONE;

						this->context.add_task_to_work_manager(instantiation_symbol_proc_id);
					}

					return FuncCallImplData(
						*instantiation_info.instantiation.funcID,
						&sema_func,
						func_infos[selected_func_overload_index.value()].func_type
					);
				}
			} break;

			case TermInfo::ValueCategory::POLY_INTERFACE_CALL: {
				const sema::Func::ID selected_func_id = 
					func_infos[selected_func_overload_index.value()].func_id.as<sema::Func::ID>();

				return FuncCallImplData(
					selected_func_id,
					&this->context.sema_buffer.getFunc(selected_func_id),
					func_infos[selected_func_overload_index.value()].func_type
				);
			} break;

			case TermInfo::ValueCategory::INTRINSIC_FUNC: case TermInfo::ValueCategory::TEMPLATE_INTRINSIC_FUNC: {
				const BaseType::Function& selected_func_type = 
					func_infos[selected_func_overload_index.value()].func_type;

				return FuncCallImplData(std::nullopt, nullptr, selected_func_type);
			} break;

			case TermInfo::ValueCategory::BUILTIN_TYPE_METHOD: {
				const BaseType::Function& selected_func_type = 
					func_infos[selected_func_overload_index.value()].func_type;

				return FuncCallImplData(std::nullopt, nullptr, selected_func_type);
			} break;

			default: evo::debugFatalBreak("Should have already been caught that value category is not callable func");
		}
	}



	auto SemanticAnalyzer::get_select_func_overload_func_info_for_template(
		const AST::FuncCall& func_call,
		sema::TemplatedFunc::ID func_id,
		evo::ArrayProxy<SymbolProc::TermInfoID> args,
		evo::ArrayProxy<SymbolProc::TermInfoID> template_args,
		bool is_member_call
	) -> evo::Expected<sema::TemplatedFunc::InstantiationInfo, TemplateOverloadMatchFail> {
		sema::TemplatedFunc& templated_func = this->context.sema_buffer.templated_funcs[func_id];

		const Source& template_source = this->context.getSourceManager()[templated_func.symbolProc.source_id];
		const AST::FuncDef& ast_func = template_source.getASTBuffer().getFuncDef(templated_func.symbolProc.ast_node);


		auto instantiation_lookup_args = evo::SmallVector<sema::TemplatedFunc::Arg>();
		auto instantiation_args = evo::SmallVector<evo::Variant<TypeInfo::VoidableID, sema::Expr>>();

		if(template_args.size() < templated_func.minNumTemplateArgs){
			return evo::Unexpected<TemplateOverloadMatchFail>(
				TemplateOverloadMatchFail(TemplateOverloadMatchFail::TooFewTemplateArgs(
					templated_func.minNumTemplateArgs,
					template_args.size(),
					templated_func.minNumTemplateArgs != templated_func.templateParams.size()
				))
			);
		}

		if(template_args.size() > templated_func.templateParams.size()){
			return evo::Unexpected<TemplateOverloadMatchFail>(
				TemplateOverloadMatchFail(TemplateOverloadMatchFail::TooManyTemplateArgs(
					templated_func.templateParams.size(),
					template_args.size(),
					templated_func.minNumTemplateArgs != templated_func.templateParams.size()
				))
			);
		}

		this->scope.pushTemplateDeclInstantiationTypesScope();
		EVO_DEFER([&](){ this->scope.popTemplateDeclInstantiationTypesScope(); });


		for(size_t i = 0; const SymbolProc::TermInfoID template_arg_id : template_args){
			EVO_DEFER([&](){ i += 1; });

			const AST::TemplatePack& ast_template_pack =
				template_source.getASTBuffer().getTemplatePack(*ast_func.templatePack);

			TermInfo& template_arg = this->get_term_info(template_arg_id);

			if(template_arg.value_category == TermInfo::ValueCategory::TYPE){ // arg is type
				if(templated_func.templateParams[i].typeID.has_value()){
					return evo::Unexpected<TemplateOverloadMatchFail>(
						TemplateOverloadMatchFail(TemplateOverloadMatchFail::TemplateArgWrongKind(i, true))
					);
				}

				const TypeInfo::VoidableID arg_type_id = template_arg.type_id.as<TypeInfo::VoidableID>();

				instantiation_lookup_args.emplace_back(arg_type_id);
				instantiation_args.emplace_back(arg_type_id);


				this->scope.addTemplateDeclInstantiationType(
					template_source.getTokenBuffer()[ast_template_pack.params[i].ident].getString(), arg_type_id
				);

			}else{ // arg is expr
				if(templated_func.templateParams[i].typeID.has_value() == false){
					return evo::Unexpected<TemplateOverloadMatchFail>(
						TemplateOverloadMatchFail(TemplateOverloadMatchFail::TemplateArgWrongKind(i, false))
					);
				}

				const evo::Result<TypeInfo::ID> expr_type_id = [&]() -> evo::Result<TypeInfo::ID> {
					if(templated_func.templateParams[i].typeID->isTemplateDeclInstantiation()){
						const evo::Result<TypeInfo::VoidableID> resolved_type = this->resolve_type(
							template_source.getASTBuffer().getType(ast_template_pack.params[i].type)
						);
						if(resolved_type.isError()){
							return evo::resultError;
						}

						if(resolved_type.value().isVoid()){
							this->emit_error(
								Diagnostic::Code::SEMA_TEMPLATE_PARAM_CANNOT_BE_TYPE_VOID,
								ast_template_pack.params[i].type,
								"Template expression parameter cannot be type `Void`"
							);
							return evo::resultError;
						}

						return resolved_type.value().asTypeID();
					}else{
						return *templated_func.templateParams[i].typeID;
					}
				}();
				if(expr_type_id.isError()){
					return evo::Unexpected<TemplateOverloadMatchFail>(
						TemplateOverloadMatchFail(TemplateOverloadMatchFail::Handled())
					);
				}


				if(this->type_check<true, false>(
					expr_type_id.value(), template_arg, "", Diagnostic::Location::NONE
				).ok == false){
					return evo::Unexpected<TemplateOverloadMatchFail>(
						TemplateOverloadMatchFail(TemplateOverloadMatchFail::Handled())
					);
				}
				

				const sema::Expr& arg_expr = template_arg.getExpr();
				instantiation_args.emplace_back(arg_expr);
				instantiation_lookup_args.emplace_back(this->sema_expr_to_generic_value(arg_expr));
			}
		}


		// default template args
		for(size_t i = template_args.size(); i < templated_func.templateParams.size(); i+=1){
			templated_func.templateParams[i].defaultValue.visit([&](const auto& default_value) -> void {
				using DefaultValue = std::decay_t<decltype(default_value)>;

				if constexpr(std::is_same<DefaultValue, std::monostate>()){
					evo::debugFatalBreak("Expected template default value, found none");

				}else if constexpr(std::is_same<DefaultValue, sema::Expr>()){
					instantiation_lookup_args.emplace_back(this->sema_expr_to_generic_value(default_value));
					instantiation_args.emplace_back(default_value);

				}else if constexpr(std::is_same<DefaultValue, TypeInfo::VoidableID>()){
					instantiation_lookup_args.emplace_back(default_value);
					instantiation_args.emplace_back(default_value);

				}else{
					static_assert(false, "Unsupported template default value type");
				}
			});
		}


		const bool is_method = templated_func.isMethod(this->context);

		{
			const size_t expected_num_args = ast_func.params.size() - size_t(is_member_call && is_method);
			const size_t got_num_args = args.size();

			if(expected_num_args != got_num_args){
				if(templated_func.isVariadic == false || expected_num_args > got_num_args){
					return evo::Unexpected<TemplateOverloadMatchFail>(
						TemplateOverloadMatchFail(
							TemplateOverloadMatchFail::WrongNumArgs(expected_num_args, got_num_args)
						)
					);
				}
			}
		}

		auto arg_types = evo::SmallVector<std::optional<TypeInfo::ID>>();
		arg_types.reserve(args.size());
		{
			size_t param_i = size_t(is_method);
			size_t arg_i = 0;
			for(const SymbolProc::TermInfoID arg_id : args){
				const TermInfo& arg = this->get_term_info(arg_id);
				if(arg.type_id.is<TypeInfo::ID>()){
					if(templated_func.paramIsDeducer[param_i]){
						instantiation_lookup_args.emplace_back(arg.type_id.as<TypeInfo::ID>());
					}
					arg_types.emplace_back(arg.type_id.as<TypeInfo::ID>());

				}else{
					if(templated_func.paramIsDeducer[param_i]){
						return evo::Unexpected<TemplateOverloadMatchFail>(
							TemplateOverloadMatchFail(TemplateOverloadMatchFail::CantDeduceArgType(arg_i))
						);
					}
					arg_types.emplace_back(std::nullopt);
				}

				if(param_i + 1 < templated_func.paramIsDeducer.size()){ param_i += 1; }
				arg_i += 1;
			}
		}



		const sema::TemplatedFunc::InstantiationInfo instantiation_info = 
			templated_func.createOrLookupInstantiation(std::move(instantiation_lookup_args));

		if(instantiation_info.needsToBeCompiled()){
			auto symbol_proc_builder = SymbolProcBuilder(
				this->context, this->context.source_manager[templated_func.symbolProc.source_id]
			);

			sema::ScopeManager& scope_manager = this->context.sema_buffer.scope_manager;

			const sema::ScopeManager::Scope::ID instantiation_sema_scope_id = 
				scope_manager.copyScope(*templated_func.symbolProc.sema_scope_id);

			
			///////////////////////////////////
			// build instantiation

			auto instantiation_locations =
				evo::SmallVector<Diagnostic::Location>(this->symbol_proc.instantiation_locations);
			instantiation_locations.emplace_back(this->get_location(func_call));

			const evo::Result<SymbolProc::ID> instantiation_symbol_proc_id = symbol_proc_builder.buildTemplateInstance(
				templated_func.symbolProc,
				instantiation_info.instantiation,
				instantiation_sema_scope_id,
				*instantiation_info.instantiationID,
				std::move(arg_types),
				std::move(instantiation_locations)
			);
			if(instantiation_symbol_proc_id.isError()){
				return evo::Unexpected<TemplateOverloadMatchFail>(
					TemplateOverloadMatchFail(TemplateOverloadMatchFail::Handled())
				);
			}

			instantiation_info.instantiation.symbolProcID = instantiation_symbol_proc_id.value();


			///////////////////////////////////
			// add instantiation args to scope

			sema::ScopeManager::Scope& instantiation_sema_scope = scope_manager.getScope(instantiation_sema_scope_id);
			instantiation_sema_scope.pushLevel(scope_manager.createLevel());

			auto template_param_names = evo::SmallVector<Token::ID>();

			if(ast_func.templatePack.has_value()){
				const AST::TemplatePack& ast_template_pack =
					template_source.getASTBuffer().getTemplatePack(*ast_func.templatePack);

				for(const AST::TemplatePack::Param& template_param : ast_template_pack.params){
					template_param_names.emplace_back(template_param.ident);
				}
			}

			for(
				size_t i = 0;
				const evo::Variant<TypeInfo::VoidableID, sema::Expr>& instantiation_arg : instantiation_args
			){
				EVO_DEFER([&](){ i += 1; });

				const evo::Result<> add_ident_result = [&](){
					if(instantiation_arg.is<TypeInfo::VoidableID>()){
						return this->add_ident_to_scope(
							instantiation_sema_scope,
							template_source.getTokenBuffer()[template_param_names[i]].getString(),
							template_param_names[i],
							true,
							sema::ScopeLevel::TemplateTypeParamFlag{},
							instantiation_arg.as<TypeInfo::VoidableID>(),
							template_param_names[i]
						);
					}else{
						const AST::TemplatePack& ast_template_pack =
							template_source.getASTBuffer().getTemplatePack(*ast_func.templatePack);

						const TypeInfo::ID expr_type_id = [&]() -> TypeInfo::ID {
							if(templated_func.templateParams[i].typeID->isTemplateDeclInstantiation()){
								const evo::Result<TypeInfo::VoidableID> resolved_type = this->resolve_type(
									template_source.getASTBuffer().getType(ast_template_pack.params[i].type)
								);

								evo::debugAssert(resolved_type.isSuccess(), "Should have already checked not an error");

								evo::debugAssert(
									resolved_type.value().isVoid() == false, "Should have already checked not Void"
								);

								return resolved_type.value().asTypeID();
							}else{
								return *templated_func.templateParams[i].typeID;
							}
						}();

						return this->add_ident_to_scope(
							instantiation_sema_scope,
							template_source.getTokenBuffer()[ast_template_pack.params[i].ident].getString(),
							ast_template_pack.params[i].ident,
							true,
							sema::ScopeLevel::TemplateExprParamFlag{},
							expr_type_id,
							instantiation_arg.as<sema::Expr>(),
							ast_template_pack.params[i].ident	
						);
					}
				}();

				if(add_ident_result.isError()){
					return evo::Unexpected<TemplateOverloadMatchFail>(
						TemplateOverloadMatchFail(TemplateOverloadMatchFail::Handled())
					);
				}
			}


			///////////////////////////////////
			// done

			SymbolProc& created_symbol_proc =
				this->context.symbol_proc_manager.getSymbolProc(instantiation_symbol_proc_id.value());
			created_symbol_proc.setStatusInQueue();
			this->context.add_task_to_work_manager(instantiation_symbol_proc_id.value());

			return instantiation_info;

		}else{
			return instantiation_info;
		}
	}




	auto SemanticAnalyzer::expr_in_func_is_valid_value_stage(const TermInfo& term_info, const auto& node_location)
	-> bool {
		if(this->get_current_func().attributes.isComptime == false){ return true; }

		if(term_info.value_stage != TermInfo::ValueStage::RUNTIME){ return true; }

		this->emit_error(
			Diagnostic::Code::SEMA_EXPR_NOT_INTERPTIME,
			node_location,
			"Expressions in a comptime function cannot have a value stage of runtime"
		);

		return false;
	}





	auto SemanticAnalyzer::resolve_type(const AST::Type& type) -> evo::Result<TypeInfo::VoidableID> {
		auto base_type_id = std::optional<BaseType::ID>();
		switch(type.base.kind()){
			case AST::Kind::PRIMITIVE_TYPE: {
				evo::unimplemented("Resolve Type (PRIMITIVE_TYPE)");
			} break;

			case AST::Kind::IDENT: {
				const evo::Expected<TermInfo, Result> lookup_ident_result = this->lookup_ident_impl<true>(
					this->source.getASTBuffer().getIdent(type.base)
				);

				const TypeInfo::VoidableID looked_up_ident = 
					lookup_ident_result.value().type_id.as<TypeInfo::VoidableID>();

				if(looked_up_ident.isVoid()){
					if(type.qualifiers.empty() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_VOID_WITH_QUALIFIERS,
							type.base,
							"Type \"Void\" cannot have qualifiers"
						);
						return evo::resultError;
					}

					return TypeInfo::VoidableID::Void();
				}

				base_type_id = this->context.getTypeManager().getTypeInfo(looked_up_ident.asTypeID()).baseTypeID();
			} break;

			case AST::Kind::DEDUCER: {
				evo::unimplemented("Resolve Type (DEDUCER)");
			} break;

			case AST::Kind::TEMPLATED_EXPR: {
				evo::unimplemented("Resolve Type (TEMPLATED_EXPR)");
			} break;

			case AST::Kind::INFIX: {
				evo::unimplemented("Resolve Type (INFIX)");
			} break;

			case AST::Kind::TYPEID_CONVERTER: {
				evo::unimplemented("Resolve Type (TYPEID_CONVERTER)");
			} break;

			default: evo::debugFatalBreak("Should not ever be invalid type");
		}


		return TypeInfo::VoidableID(this->context.type_manager.getOrCreateTypeInfo(TypeInfo(*base_type_id)));
	}




	auto SemanticAnalyzer::generic_value_to_sema_expr(const core::GenericValue& value, const TypeInfo& target_type)
	-> sema::Expr {
		switch(target_type.baseTypeID().kind()){
			case BaseType::Kind::DUMMY: evo::debugFatalBreak("Invalid type");

			case BaseType::Kind::PRIMITIVE: {
				const BaseType::Primitive& primitive_type = this->context.getTypeManager().getPrimitive(
					target_type.baseTypeID().primitiveID()
				);

				switch(primitive_type.kind()){
					case Token::Kind::TYPE_INT:      case Token::Kind::TYPE_ISIZE:
					case Token::Kind::TYPE_I_N:      case Token::Kind::TYPE_UINT:
					case Token::Kind::TYPE_USIZE:    case Token::Kind::TYPE_UI_N:
					case Token::Kind::TYPE_BYTE:     case Token::Kind::TYPE_TYPEID:
					case Token::Kind::TYPE_C_WCHAR:  case Token::Kind::TYPE_C_SHORT:
					case Token::Kind::TYPE_C_USHORT: case Token::Kind::TYPE_C_INT:
					case Token::Kind::TYPE_C_UINT:   case Token::Kind::TYPE_C_LONG:
					case Token::Kind::TYPE_C_ULONG:  case Token::Kind::TYPE_C_LONG_LONG:
					case Token::Kind::TYPE_C_ULONG_LONG: {
						return sema::Expr(
							this->context.sema_buffer.createIntValue(
								value.getInt(
									unsigned(this->context.getTypeManager().numBits(target_type.baseTypeID()))
								),
								target_type.baseTypeID()
							)
						);
					} break;

					case Token::Kind::TYPE_F16: {
						return sema::Expr(
							this->context.sema_buffer.createFloatValue(value.getF16(), target_type.baseTypeID())
						);
					} break;

					case Token::Kind::TYPE_BF16: {
						return sema::Expr(
							this->context.sema_buffer.createFloatValue(value.getBF16(), target_type.baseTypeID())
						);
					} break;

					case Token::Kind::TYPE_F32: {
						return sema::Expr(
							this->context.sema_buffer.createFloatValue(value.getF32(), target_type.baseTypeID())
						);
					} break;

					case Token::Kind::TYPE_F64: {
						return sema::Expr(
							this->context.sema_buffer.createFloatValue(value.getF64(), target_type.baseTypeID())
						);
					} break;

					case Token::Kind::TYPE_F80: {
						return sema::Expr(
							this->context.sema_buffer.createFloatValue(value.getF80(), target_type.baseTypeID())
						);
					} break;

					case Token::Kind::TYPE_F128: {
					 	return sema::Expr(
					 		this->context.sema_buffer.createFloatValue(value.getF128(), target_type.baseTypeID())
					 	);
				 	} break;

					case Token::Kind::TYPE_C_LONG_DOUBLE: {
						if(this->context.getTypeManager().numBits(target_type.baseTypeID()) == 64){
							return sema::Expr(
								this->context.sema_buffer.createFloatValue(value.getF64(), target_type.baseTypeID())
							);
						}else{
							return sema::Expr(
								this->context.sema_buffer.createFloatValue(value.getF80(), target_type.baseTypeID())
							);
						}
					} break;

					case Token::Kind::TYPE_BOOL: {
						return sema::Expr(this->context.sema_buffer.createBoolValue(value.getBool()));
					} break;

					case Token::Kind::TYPE_CHAR: {
						return sema::Expr(this->context.sema_buffer.createCharValue(value.getChar()));
					} break;

					case Token::Kind::TYPE_RAWPTR: evo::unimplemented("Token::Kind::TYPE_RAWPTR");

					default: evo::debugFatalBreak("Invalid type");
				}
			} break;

			case BaseType::Kind::FUNCTION: {
				evo::unimplemented("generic_value_to_sema_expr - BaseType::Kind::FUNCTION");
			} break;

			case BaseType::Kind::ARRAY: {
				const BaseType::Array& array_type = this->context.getTypeManager().getArray(
					target_type.baseTypeID().arrayID()
				);

				const uint64_t num_elems = [&](){
					uint64_t total_num_elems = 1;
					for(uint64_t dimension : array_type.dimensions){
						total_num_elems *= dimension;
					}
					if(array_type.terminator.has_value()){
						total_num_elems += 1;
					}
					return total_num_elems;
				}();

				const uint64_t elem_size = this->context.getTypeManager().numBytes(array_type.elementTypeID);
				const TypeInfo& elem_type_info = this->context.getTypeManager().getTypeInfo(array_type.elementTypeID);

				auto member_vals = evo::SmallVector<sema::Expr>();
				member_vals.reserve(size_t(num_elems));


				for(size_t i = 0; i < num_elems; i+=1){
					const auto elem_range = evo::ArrayProxy<std::byte>(&value.dataRange()[i * elem_size], elem_size);

					member_vals.emplace_back(
						this->generic_value_to_sema_expr(core::GenericValue::fromData(elem_range), elem_type_info)
					);
				}

				return sema::Expr(
					this->context.sema_buffer.createAggregateValue(std::move(member_vals), target_type.baseTypeID())
				);
			} break;

			case BaseType::Kind::ARRAY_DEDUCER: {
				evo::debugFatalBreak("Function cannot return an array deducer");
			} break;

			case BaseType::Kind::ARRAY_REF: {
				evo::unimplemented("BaseType::Kind::ARRAY_REF"); // TODO(FUTURE): handling underlying data???
			} break;

			case BaseType::Kind::ARRAY_REF_DEDUCER: {
				evo::debugFatalBreak("Function cannot return an array ref deducer");
			} break;

			case BaseType::Kind::ALIAS: {
				const BaseType::Alias& alias_type = this->context.getTypeManager().getAlias(
					target_type.baseTypeID().aliasID()
				);

				return this->generic_value_to_sema_expr(
					value, this->context.getTypeManager().getTypeInfo(alias_type.aliasedType)
				);
			} break;

			case BaseType::Kind::DISTINCT_ALIAS: {
				const BaseType::DistinctAlias& distinct_alias_type = this->context.getTypeManager().getDistinctAlias(
					target_type.baseTypeID().distinctAliasID()
				);

				return this->generic_value_to_sema_expr(
					value, this->context.getTypeManager().getTypeInfo(distinct_alias_type.underlyingType)
				);
			} break;

			case BaseType::Kind::STRUCT: {
				const BaseType::Struct& struct_type = this->context.getTypeManager().getStruct(
					target_type.baseTypeID().structID()
				);

				size_t offset = 0;

				auto member_vals = evo::SmallVector<sema::Expr>();
				member_vals.reserve(struct_type.memberVarsABI.size());

				for(const BaseType::Struct::MemberVar* member_var : struct_type.memberVarsABI){
					const size_t member_size = this->context.getTypeManager().numBytes(member_var->typeID);

					const auto member_range = evo::ArrayProxy<std::byte>(&value.dataRange()[offset], member_size);
					member_vals.emplace_back(
						this->generic_value_to_sema_expr(
							core::GenericValue::fromData(member_range),
							this->context.getTypeManager().getTypeInfo(member_var->typeID)
						)
					);

					offset += member_size;
				}

				return sema::Expr(
					this->context.sema_buffer.createAggregateValue(std::move(member_vals), target_type.baseTypeID())
				);
			} break;

			case BaseType::Kind::STRUCT_TEMPLATE: {
				evo::debugFatalBreak("Function cannot return a struct template");
			} break;

			case BaseType::Kind::STRUCT_TEMPLATE_DEDUCER: {
				evo::debugFatalBreak("Function cannot return a struct template deducer");
			} break;

			case BaseType::Kind::UNION: {
				// const BaseType::Union& union_type = this->context.getTypeManager().getUnion(
				// 	target_type.baseTypeID().unionID()
				// );

				const uint64_t num_elems = this->context.getTypeManager().numBytes(target_type.baseTypeID());

				auto member_vals = evo::SmallVector<sema::Expr>();
				member_vals.reserve(size_t(num_elems));


				for(size_t i = 0; i < num_elems; i+=1){
					const auto elem_range = evo::ArrayProxy<std::byte>(&value.dataRange()[i], 1);

					member_vals.emplace_back(
						this->generic_value_to_sema_expr(
							core::GenericValue::fromData(elem_range),
							this->context.getTypeManager().getTypeInfo(TypeManager::getTypeByte())
						)
					);
				}

				return sema::Expr(
					this->context.sema_buffer.createAggregateValue(std::move(member_vals), target_type.baseTypeID())
				);
			} break;

			case BaseType::Kind::ENUM: {
				const BaseType::Enum& enum_type =
					this->context.getTypeManager().getEnum(target_type.baseTypeID().enumID());

				return this->generic_value_to_sema_expr(value, TypeInfo(BaseType::ID(enum_type.underlyingTypeID)));
			} break;

			case BaseType::Kind::TYPE_DEDUCER: {
				evo::debugFatalBreak("Function cannot return a type deducer");
			} break;

			case BaseType::Kind::INTERFACE: {
				evo::debugFatalBreak("Function cannot return an interface");
			} break;

			case BaseType::Kind::POLY_INTERFACE_REF: {
				evo::unimplemented("BaseType::Kind::POLY_INTERFACE_REF"); // TODO(FUTURE): handling underlying data???
			} break;

			case BaseType::Kind::INTERFACE_MAP: {
				const BaseType::InterfaceMap& interface_map_info =
					this->context.getTypeManager().getInterfaceMap(target_type.baseTypeID().interfaceMapID());

				return this->generic_value_to_sema_expr(
					value,
					this->context.getTypeManager().getTypeInfo(
						interface_map_info.underlyingTypeID
					)
				);
			} break;
		}

		evo::unreachable();
	}




	auto SemanticAnalyzer::sema_expr_to_generic_value(const sema::Expr& expr) -> core::GenericValue {
		switch(expr.kind()){
			case sema::Expr::Kind::INT_VALUE: {
				return core::GenericValue(this->context.getSemaBuffer().getIntValue(expr.intValueID()).value);
			} break;

			case sema::Expr::Kind::FLOAT_VALUE: {
				return core::GenericValue(this->context.getSemaBuffer().getFloatValue(expr.floatValueID()).value);
			} break;

			case sema::Expr::Kind::BOOL_VALUE: {
				return core::GenericValue(this->context.getSemaBuffer().getBoolValue(expr.boolValueID()).value);
			} break;

			case sema::Expr::Kind::STRING_VALUE: {
				return core::GenericValue(
					std::string_view(this->context.getSemaBuffer().getStringValue(expr.stringValueID()).value)
				);
			} break;

			case sema::Expr::Kind::AGGREGATE_VALUE: {
				const sema::AggregateValue& aggregate_value =
					this->context.getSemaBuffer().getAggregateValue(expr.aggregateValueID());

				const size_t output_size = this->context.getTypeManager().numBytes(aggregate_value.typeID);
				core::GenericValue output = core::GenericValue::createUninit(output_size);

				if(aggregate_value.typeID.kind() == BaseType::Kind::STRUCT){
					const BaseType::Struct& struct_type = 
						this->context.getTypeManager().getStruct(aggregate_value.typeID.structID());

					size_t offset = 0;

					for(size_t i = 0; const BaseType::Struct::MemberVar* member : struct_type.memberVarsABI){
						const core::GenericValue member_val =
							this->sema_expr_to_generic_value(aggregate_value.values[i]);

						const size_t member_size = this->context.getTypeManager().numBytes(member->typeID);

						std::memcpy(&output.writableDataRange()[offset], member_val.dataRange().data(), member_size);

						offset += member_size;

						i += 1;
					}

				}else if(aggregate_value.typeID.kind() == BaseType::Kind::ARRAY){
					const BaseType::Array& array_type = 
						this->context.getTypeManager().getArray(aggregate_value.typeID.arrayID());

					const size_t elem_size = this->context.getTypeManager().numBytes(array_type.elementTypeID);

					const size_t num_elems = output_size / elem_size;
					for(size_t i = 0; i < num_elems; i+=1){
						const core::GenericValue elem_val = this->sema_expr_to_generic_value(aggregate_value.values[i]);

						std::memcpy(&output.writableDataRange()[i * elem_size], elem_val.dataRange().data(), elem_size);
					}

				}else{
					evo::debugAssert(aggregate_value.typeID.kind() == BaseType::Kind::UNION, "Unknown aggregate type");

					const size_t num_elems = this->context.getTypeManager().numBytes(aggregate_value.typeID);
					for(size_t i = 0; i < num_elems; i+=1){
						const core::GenericValue elem_val = this->sema_expr_to_generic_value(aggregate_value.values[i]);

						output.writableDataRange()[i] = *elem_val.dataRange().data();
					}
				}

				return output;
			} break;

			case sema::Expr::Kind::CHAR_VALUE: {
				return core::GenericValue(this->context.getSemaBuffer().getCharValue(expr.charValueID()).value);
			} break;

			default: evo::debugFatalBreak("Invalid comptime value");
		}
	}



	auto SemanticAnalyzer::extract_string_from_sema_expr(sema::Expr expr) -> std::string_view {
		switch(expr.kind()){
			case sema::Expr::Kind::STRING_VALUE: {
				return this->context.getSemaBuffer().getStringValue(expr.stringValueID()).value;
			} break;

			case sema::Expr::Kind::INIT_ARRAY_REF: {
				const sema::InitArrayRef& init_array_ref = 
					this->context.getSemaBuffer().getInitArrayRef(expr.initArrayRefID());

				return this->extract_string_from_sema_expr(init_array_ref.expr);
			} break;

			case sema::Expr::Kind::GLOBAL_VAR: {
				const sema::GlobalVar& global_var = this->context.getSemaBuffer().getGlobalVar(expr.globalVarID());

				return this->extract_string_from_sema_expr(*global_var.expr.load(std::memory_order::relaxed));
			} break;

			default: {
				evo::debugFatalBreak("Not a string value");
			} break;
		}
	}




	auto SemanticAnalyzer::get_package() const -> const Source::Package& {
		return this->context.getSourceManager().getPackage(this->source.getPackageID());
	}





	auto SemanticAnalyzer::type_implements_interface(
		BaseType::Interface& interface_type, TypeInfo::ID target_type_id, Diagnostic::Location location
	) -> evo::Expected<bool, Result> {
		//////////////////
		// wait for definition of interface

		if(interface_type.symbolProcID.has_value()){
			SymbolProc& interface_symbol_proc =
				this->context.symbol_proc_manager.getSymbolProc(*interface_type.symbolProcID);

			const SymbolProc::WaitOnResult wait_on_result = interface_symbol_proc.waitOnDefIfNeeded(
				this->symbol_proc_id, this->context, *interface_type.symbolProcID
			);

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                 break;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*interface_type.symbolProcID);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                    return evo::Unexpected(Result::NEED_TO_WAIT);
				case SymbolProc::WaitOnResult::WAS_ERRORED:                return evo::Unexpected(Result::ERROR);
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND: evo::debugFatalBreak("Not possible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:      return evo::Unexpected(Result::ERROR);
			}
		}


		//////////////////
		// check if the type impl exists yet
		{
			const auto lock = std::scoped_lock(interface_type.implsLock);
			if(interface_type.impls.contains(target_type_id)){ return true; }
		}


		//////////////////
		// check if the type impl exists as a deducer

		auto deducer_matches = evo::SmallVector<const BaseType::Interface::DeducerImpl*>();

		for(const BaseType::Interface::DeducerImpl* deducer_impl : interface_type.deducerImpls){
			const DeducerMatchOutput deducer_match_output =
				this->deducer_matches_and_extract(deducer_impl->deducerTypeID, target_type_id);

			switch(deducer_match_output.outcome()){
				break; case DeducerMatchOutput::Outcome::MATCH:   deducer_matches.emplace_back(deducer_impl);
				break; case DeducerMatchOutput::Outcome::NO_MATCH:// do nothing...
				break; case DeducerMatchOutput::Outcome::RESULT:  return evo::Unexpected(deducer_match_output.result());
			}
		}


		if(deducer_matches.empty() == false){
			if(deducer_matches.size() == 1){
				const BaseType::Interface::DeducerImpl& deducer_match = *deducer_matches[0];

				BaseType::Interface::DeducerImpl::NeedsToBeCompiledResult needs_to_be_compiled_result =
					deducer_match.instantiationNeedsToBeCompiled(target_type_id);


				if(needs_to_be_compiled_result.needsToBeCompiled){
					SymbolProc* parent_interface_symbol_proc = [&]() -> SymbolProc* {
						if(interface_type.symbolProcID.has_value()){
							return &this->context.symbol_proc_manager.getSymbolProc(*interface_type.symbolProcID);
						}else{
							return nullptr;
						}
					}();


					const SymbolProc& deducer_match_symbol_proc =
						this->context.symbol_proc_manager.getSymbolProc(deducer_match.symbolProcID);

					const auto copy_scope_id = this->context.sema_buffer.scope_manager.copyScope(
						*deducer_match_symbol_proc.sema_scope_id
					);


					Source& deducer_match_source =
						this->context.source_manager[deducer_match_symbol_proc.getSourceID()];

					BaseType::Interface::Impl& created_impl = this->context.type_manager.createInterfaceImpl(
						deducer_match_source.getASTBuffer().getInterfaceImpl(deducer_match.astInterfaceImpl)
					);


					auto instantiation_locations =
						evo::SmallVector<Diagnostic::Location>(this->symbol_proc.instantiation_locations);
					instantiation_locations.emplace_back(location);

					auto symbol_proc_builder = SymbolProcBuilder(this->context, deducer_match_source);
					const SymbolProc::ID created_symbol_proc_id = symbol_proc_builder.buildInterfaceImplDeducer(
						deducer_match,
						created_impl,
						parent_interface_symbol_proc,
						copy_scope_id,
						target_type_id,
						std::move(instantiation_locations)
					);
					SymbolProc& created_symbol_proc =
						this->context.symbol_proc_manager.getSymbolProc(created_symbol_proc_id);


					created_impl.instantiatingSymbolProc = std::optional<SymbolProc::ID>(created_symbol_proc_id);

					{
						const auto lock = std::scoped_lock(interface_type.implsLock);
						interface_type.impls.emplace(target_type_id, created_impl);
					}

					needs_to_be_compiled_result.setAddedToImpl();

					created_symbol_proc.setStatusInQueue();
					this->context.add_task_to_work_manager(created_symbol_proc_id);

				}else{
					needs_to_be_compiled_result.waitForAddedToImpl();
				}

				return true;

			}else{
				auto infos = evo::SmallVector<Diagnostic::Info>();

				this->diagnostic_print_type_info(target_type_id, infos, "This target type: ");

				infos.emplace_back("This interface:", this->get_location(interface_type));

				for(const BaseType::Interface::DeducerImpl* deducer_match : deducer_matches){
					infos.emplace_back("Matches with this impl:", this->get_location(deducer_match->astInterfaceImpl));
				}

				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_MULTIPLE_DEDUCER_IMPLS_MATCH,
					location,
					"Interface has multiple deducer multiple impls that match this type",
					std::move(infos)
				);
				return evo::Unexpected(Result::ERROR);
			}
		}


		//////////////////
		// check specific base types

		const TypeInfo& target_type = this->context.getTypeManager().getTypeInfo(target_type_id);

		if(target_type.qualifiers().empty() == false){ return false; }


		switch(target_type.baseTypeID().kind()){
			case BaseType::Kind::ARRAY: {
				const BaseType::Array& array_type =
					this->context.getTypeManager().getArray(target_type.baseTypeID().arrayID());


				if(interface_type.sourceID.is<BuiltinModule::ID>() == false){ return false; }

				const std::string_view interface_name = this->context.getSourceManager()
					[interface_type.sourceID.as<BuiltinModule::ID>()]
					.getString(interface_type.name.as<BuiltinModule::StringID>());


				if(interface_name == "Iterable"){
					if(array_type.dimensions.size() != 1){
						this->emit_error(
							Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
							location,
							"Iteration of multi-dimension arrays is currently unimplemented"
						);
						return evo::Unexpected(Result::ERROR);
					}

					if(array_type.terminator.has_value()){
						this->emit_error(
							Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
							location,
							"Iteration of arrays with terminators is currently unimplemented"
						);
						return evo::Unexpected(Result::ERROR);
					}

					const bool need_to_wait = this->context.symbol_proc_manager.waitOnSymbolProcOfBuiltinSymbolIfNeeded(
						SymbolProcManager::constevalLookupBuiltinSymbolKind("array.Iterable"),
						this->symbol_proc_id,
						this->context
					);
					if(need_to_wait){ return evo::Unexpected(Result::NEED_TO_WAIT); }
					return true;

				}else if(interface_name == "IterableRT"){
					if(array_type.dimensions.size() != 1){
						this->emit_error(
							Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
							location,
							"Iteration of multi-dimension arrays is currently unimplemented"
						);
						return evo::Unexpected(Result::ERROR);
					}

					if(array_type.terminator.has_value()){
						this->emit_error(
							Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
							location,
							"Iteration of arrays with terminators is currently unimplemented"
						);
						return evo::Unexpected(Result::ERROR);
					}

					const bool need_to_wait = this->context.symbol_proc_manager.waitOnSymbolProcOfBuiltinSymbolIfNeeded(
						SymbolProcManager::constevalLookupBuiltinSymbolKind("array.IterableRT"),
						this->symbol_proc_id,
						this->context
					);
					if(need_to_wait){ return evo::Unexpected(Result::NEED_TO_WAIT); }
					return true;

				}else{
					return false;
				}
			} break;

			case BaseType::Kind::ARRAY_REF: {
				const BaseType::ArrayRef& array_ref_type =
					this->context.getTypeManager().getArrayRef(target_type.baseTypeID().arrayRefID());

				if(interface_type.sourceID.is<BuiltinModule::ID>() == false){ return false; }

				const std::string_view interface_name = this->context.getSourceManager()
					[interface_type.sourceID.as<BuiltinModule::ID>()]
					.getString(interface_type.name.as<BuiltinModule::StringID>());

				if(array_ref_type.isMut){
					if(interface_name == "IterableMutRef"){
						if(array_ref_type.dimensions.size() != 1){
							this->emit_error(
								Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
								location,
								"Iteration of multi-dimension array references is currently unimplemented"
							);
							return evo::Unexpected(Result::ERROR);
						}
						
						if(array_ref_type.terminator.has_value()){
							this->emit_error(
								Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
								location,
								"Iteration of array references with terminators is currently unimplemented"
							);
							return evo::Unexpected(Result::ERROR);
						}

						const bool need_to_wait =
							this->context.symbol_proc_manager.waitOnSymbolProcOfBuiltinSymbolIfNeeded(
								SymbolProcManager::constevalLookupBuiltinSymbolKind("arrayMutRef.IterableMutRef"),
								this->symbol_proc_id,
								this->context
							);
						if(need_to_wait){ return evo::Unexpected(Result::NEED_TO_WAIT); }
						return true;

					}else if(interface_name == "IterableMutRefRT"){
						if(array_ref_type.dimensions.size() != 1){
							this->emit_error(
								Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
								location,
								"Iteration of multi-dimension array references is currently unimplemented"
							);
							return evo::Unexpected(Result::ERROR);
						}
						
						if(array_ref_type.terminator.has_value()){
							this->emit_error(
								Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
								location,
								"Iteration of array references with terminators is currently unimplemented"
							);
							return evo::Unexpected(Result::ERROR);
						}


						const bool need_to_wait =
							this->context.symbol_proc_manager.waitOnSymbolProcOfBuiltinSymbolIfNeeded(
								SymbolProcManager::constevalLookupBuiltinSymbolKind("arrayMutRef.IterableMutRefRT"),
								this->symbol_proc_id,
								this->context
							);
						if(need_to_wait){ return evo::Unexpected(Result::NEED_TO_WAIT); }
						return true;

					}else{
						return false;
					}
				}else{
					if(interface_name == "IterableRef"){
						if(array_ref_type.dimensions.size() != 1){
							this->emit_error(
								Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
								location,
								"Iteration of multi-dimension array references is currently unimplemented"
							);
							return evo::Unexpected(Result::ERROR);
						}
						
						if(array_ref_type.terminator.has_value()){
							this->emit_error(
								Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
								location,
								"Iteration of array references with terminators is currently unimplemented"
							);
							return evo::Unexpected(Result::ERROR);
						}

						const bool need_to_wait =
							this->context.symbol_proc_manager.waitOnSymbolProcOfBuiltinSymbolIfNeeded(
								SymbolProcManager::constevalLookupBuiltinSymbolKind("arrayRef.IterableRef"),
								this->symbol_proc_id,
								this->context
							);
						if(need_to_wait){ return evo::Unexpected(Result::NEED_TO_WAIT); }
						return true;

					}else if(interface_name == "IterableRefRT"){
						if(array_ref_type.dimensions.size() != 1){
							this->emit_error(
								Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
								location,
								"Iteration of multi-dimension array references is currently unimplemented"
							);
							return evo::Unexpected(Result::ERROR);
						}
						
						if(array_ref_type.terminator.has_value()){
							this->emit_error(
								Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
								location,
								"Iteration of array references with terminators is currently unimplemented"
							);
							return evo::Unexpected(Result::ERROR);
						}

						const bool need_to_wait =
							this->context.symbol_proc_manager.waitOnSymbolProcOfBuiltinSymbolIfNeeded(
								SymbolProcManager::constevalLookupBuiltinSymbolKind("arrayRef.IterableRefRT"),
								this->symbol_proc_id,
								this->context
							);
						if(need_to_wait){ return evo::Unexpected(Result::NEED_TO_WAIT); }
						return true;

					}else{
						return false;
					}
				}
			} break;

			case BaseType::Kind::STRUCT: { // check if the type impl exists in the definition of the type
				const BaseType::Struct& target_struct =
					this->context.getTypeManager().getStruct(target_type.baseTypeID().structID());


				const WaitOnSymbolProcResult wait_on_symbol_proc_result = this->wait_on_symbol_proc<true>(
					target_struct.namespacedMembers, "impl"
				);

				switch(wait_on_symbol_proc_result){
					case WaitOnSymbolProcResult::NOT_FOUND: case WaitOnSymbolProcResult::ERROR_PASSED_BY_WHEN_COND: {
						return false;
					} break;

					case WaitOnSymbolProcResult::CIRCULAR_DEP_DETECTED:
					case WaitOnSymbolProcResult::EXISTS_BUT_ERRORED: {
						return evo::Unexpected(Result::ERROR);
					} break;

					case WaitOnSymbolProcResult::NEED_TO_WAIT: {
						return evo::Unexpected(Result::NEED_TO_WAIT);
					} break;

					case WaitOnSymbolProcResult::SEMAS_READY: {
						// do nothing...
					} break;
				}

				{
					const auto lock = std::scoped_lock(interface_type.implsLock);
					return interface_type.impls.contains(target_type_id);
				}
			} break;

			default: {
				return false;
			} break;
		}

	}




	auto SemanticAnalyzer::deducer_matches_and_extract(TypeInfo::ID deducer_id, TypeInfo::ID got_type_id)
	-> DeducerMatchOutput {
		const TypeManager& type_manager = this->context.getTypeManager();

		auto deduced_terms = evo::SmallVector<DeducerMatchOutput::DeducedTerm>();

		const TypeInfo& deducer  = type_manager.getTypeInfo(deducer_id);
		const TypeInfo& got_type = type_manager.getTypeInfo(got_type_id);



		switch(deducer.baseTypeID().kind()){
			case BaseType::Kind::TYPE_DEDUCER: {
				if(deducer.qualifiers().size() < got_type.qualifiers().size()){
					for(size_t i = 0; i < deducer.qualifiers().size(); i+=1){
						if(deducer.qualifiers()[i] != got_type.qualifiers()[i - got_type.qualifiers().size()]){
							return evo::resultError;
						}
					}

				}else if(deducer.qualifiers().size() == got_type.qualifiers().size()){
					if(deducer.qualifiers() != got_type.qualifiers()){ return evo::resultError; }
					
				}else{ // deducer.qualifiers().size() > got_type.qualifiers().size()
					return evo::resultError;
				}


				const BaseType::TypeDeducer& type_deducer = 
					type_manager.getTypeDeducer(deducer.baseTypeID().typeDeducerID());

				if(type_deducer.isAnonymous()){
					return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
				}

				const Source& deducer_source = this->context.source_manager[*type_deducer.sourceID];
				const Token& type_deducer_token = deducer_source.getTokenBuffer()[*type_deducer.identTokenID];

				if(type_deducer_token.kind() == Token::Kind::ANONYMOUS_DEDUCER){
					return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
				}

				if(deducer.qualifiers().empty()){
					deduced_terms.emplace_back(got_type_id, *type_deducer.identTokenID);
				}else{
					auto qualifiers = evo::SmallVector<TypeInfo::Qualifier>();

					for(size_t i = 0; i < got_type.qualifiers().size() - deducer.qualifiers().size(); i+=1){
						qualifiers.emplace_back(got_type.qualifiers()[i]);
					}

					deduced_terms.emplace_back(
						this->context.type_manager.getOrCreateTypeInfo(
							TypeInfo(got_type.baseTypeID(), std::move(qualifiers))
						),
						*type_deducer.identTokenID
					);
				}

				return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
			} break;

			case BaseType::Kind::ARRAY: {
				const evo::Result<bool> qualifiers_check_result =
					this->type_qualifiers_check(deducer.qualifiers(), got_type.qualifiers());
				if(qualifiers_check_result.isError() || qualifiers_check_result.value()){ return evo::resultError; }

				if(got_type.baseTypeID().kind() != BaseType::Kind::ARRAY){ return evo::resultError; }

				const BaseType::Array& deducer_array_type = 
					this->context.getTypeManager().getArray(deducer.baseTypeID().arrayID());

				const BaseType::Array& got_array_type = 
					this->context.getTypeManager().getArray(got_type.baseTypeID().arrayID());

				if(deducer_array_type.dimensions != got_array_type.dimensions){ return evo::resultError; }
				if(deducer_array_type.terminator != got_array_type.terminator){ return evo::resultError; }

				DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
					deducer_array_type.elementTypeID, got_array_type.elementTypeID
				);
				switch(deducer_match_output.outcome()){
					case DeducerMatchOutput::Outcome::MATCH:    break;
					case DeducerMatchOutput::Outcome::NO_MATCH: return evo::resultError;
					case DeducerMatchOutput::Outcome::RESULT:   return deducer_match_output.result();
				}

				deduced_terms.append_range(std::move(deducer_match_output.deducedTerms()));
				return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
			} break;

			case BaseType::Kind::ARRAY_REF: {
				const evo::Result<bool> qualifiers_check_result =
					this->type_qualifiers_check(deducer.qualifiers(), got_type.qualifiers());
				if(qualifiers_check_result.isError() || qualifiers_check_result.value()){ return evo::resultError; }

				if(got_type.baseTypeID().kind() != BaseType::Kind::ARRAY_REF){ return evo::resultError; }

				const BaseType::ArrayRef& deducer_array_ref_type = 
					this->context.getTypeManager().getArrayRef(deducer.baseTypeID().arrayRefID());

				const BaseType::ArrayRef& got_array_ref_type = 
					this->context.getTypeManager().getArrayRef(got_type.baseTypeID().arrayRefID());

				if(deducer_array_ref_type.isMut != got_array_ref_type.isMut){ return evo::resultError; }
				if(deducer_array_ref_type.terminator != got_array_ref_type.terminator){ return evo::resultError; }

				DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
					deducer_array_ref_type.elementTypeID, got_array_ref_type.elementTypeID
				);
				switch(deducer_match_output.outcome()){
					case DeducerMatchOutput::Outcome::MATCH:    break;
					case DeducerMatchOutput::Outcome::NO_MATCH: return evo::resultError;
					case DeducerMatchOutput::Outcome::RESULT:   return deducer_match_output.result();
				}
				deduced_terms.append_range(std::move(deducer_match_output.deducedTerms()));

				return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
			} break;

			case BaseType::Kind::ARRAY_DEDUCER: {
				const evo::Result<bool> qualifiers_check_result =
					this->type_qualifiers_check(deducer.qualifiers(), got_type.qualifiers());
				if(qualifiers_check_result.isError() || qualifiers_check_result.value()){ return evo::resultError; }

				if(got_type.baseTypeID().kind() != BaseType::Kind::ARRAY){ return evo::resultError; }

				const BaseType::ArrayDeducer& deducer_array_deducer_type = 
					this->context.getTypeManager().getArrayDeducer(deducer.baseTypeID().arrayDeducerID());

				const BaseType::Array& got_array_type = 
					this->context.getTypeManager().getArray(got_type.baseTypeID().arrayID());

				DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
					deducer_array_deducer_type.elementTypeID, got_array_type.elementTypeID
				);
				switch(deducer_match_output.outcome()){
					case DeducerMatchOutput::Outcome::MATCH:    break;
					case DeducerMatchOutput::Outcome::NO_MATCH: return evo::resultError;
					case DeducerMatchOutput::Outcome::RESULT:   return deducer_match_output.result();
				}
				deduced_terms.append_range(std::move(deducer_match_output.deducedTerms()));

				if(deducer_array_deducer_type.dimensions.size() != got_array_type.dimensions.size()){
					return evo::resultError;
				}


				const Source& deducer_array_deducer_type_source =
					this->context.getSourceManager()[deducer_array_deducer_type.sourceID];

				for(size_t i = 0; i < deducer_array_deducer_type.dimensions.size(); i+=1){
					if(deducer_array_deducer_type.dimensions[i].is<uint64_t>()){
						if(deducer_array_deducer_type.dimensions[i].as<uint64_t>() != got_array_type.dimensions[i]){
							return evo::resultError;
						}

					}else{
						const Token& deducer_token = deducer_array_deducer_type_source.getTokenBuffer()[
							deducer_array_deducer_type.dimensions[i].as<Token::ID>()
						];

						if(deducer_token.kind() == Token::Kind::DEDUCER){
							const sema::Expr created_int_value = sema::Expr(
								this->context.sema_buffer.createIntValue(
									core::GenericInt(
										unsigned(this->context.getTypeManager().numBitsOfPtr()),
										got_array_type.dimensions[i]
									),
									this->context.getTypeManager().getTypeInfo(TypeManager::getTypeUSize()).baseTypeID()
								)
							);

							deduced_terms.emplace_back(
								DeducerMatchOutput::DeducedTerm::Expr(TypeManager::getTypeUSize(), created_int_value),
								deducer_array_deducer_type.dimensions[i].as<Token::ID>()
							);
						}
					}
				}

				if(deducer_array_deducer_type.terminator.is<std::monostate>()){
					if(got_array_type.terminator.has_value()){ return evo::resultError; }

				}else if(deducer_array_deducer_type.terminator.is<core::GenericValue>()){
					if(deducer_array_deducer_type.terminator.as<core::GenericValue>() != *got_array_type.terminator){
						return evo::resultError;
					}

				}else{
					const Token& deducer_token = deducer_array_deducer_type_source.getTokenBuffer()[
						deducer_array_deducer_type.terminator.as<Token::ID>()
					];

					if(deducer_token.kind() == Token::Kind::DEDUCER){
						deduced_terms.emplace_back(
							DeducerMatchOutput::DeducedTerm::Expr(
								got_array_type.elementTypeID,
								this->generic_value_to_sema_expr(
									*got_array_type.terminator,
									this->context.getTypeManager().getTypeInfo(got_array_type.elementTypeID)
								)
							),
							deducer_array_deducer_type.terminator.as<Token::ID>()
						);

					}else{
						evo::debugAssert(
							deducer_token.kind() == Token::Kind::ANONYMOUS_DEDUCER, "Unknown deducer kind"
						);
					}
				}

				return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
			} break;

			case BaseType::Kind::ARRAY_REF_DEDUCER: {
				const evo::Result<bool> qualifiers_check_result =
					this->type_qualifiers_check(deducer.qualifiers(), got_type.qualifiers());
				if(qualifiers_check_result.isError() || qualifiers_check_result.value()){ return evo::resultError; }

				if(got_type.baseTypeID().kind() != BaseType::Kind::ARRAY_REF){ return evo::resultError; }

				const BaseType::ArrayRefDeducer& deducer_array_ref_deducer_type = 
					this->context.getTypeManager().getArrayRefDeducer(deducer.baseTypeID().arrayRefDeducerID());

				const BaseType::ArrayRef& got_array_ref_type = 
					this->context.getTypeManager().getArrayRef(got_type.baseTypeID().arrayRefID());

				DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
					deducer_array_ref_deducer_type.elementTypeID, got_array_ref_type.elementTypeID
				);
				switch(deducer_match_output.outcome()){
					case DeducerMatchOutput::Outcome::MATCH:    break;
					case DeducerMatchOutput::Outcome::NO_MATCH: return evo::resultError;
					case DeducerMatchOutput::Outcome::RESULT:   return deducer_match_output.result();
				}
				deduced_terms.append_range(std::move(deducer_match_output.deducedTerms()));


				if(deducer_array_ref_deducer_type.dimensions.size() != got_array_ref_type.dimensions.size()){
					return evo::resultError;
				}

				const Source& deducer_array_ref_deducer_type_source =
					this->context.getSourceManager()[deducer_array_ref_deducer_type.sourceID];

				for(size_t i = 0; i < deducer_array_ref_deducer_type.dimensions.size(); i+=1){
					const BaseType::ArrayRefDeducer::Dimension& deducer_dimension = 
						deducer_array_ref_deducer_type.dimensions[i];

					const BaseType::ArrayRef::Dimension& got_dimension = 
						got_array_ref_type.dimensions[i];


					if(deducer_dimension.isPtr()){
						if(got_dimension.isPtr() == false){ return evo::resultError; }
						
					}else if(deducer_dimension.isDeducer()){
						if(got_dimension.isLength() == false){ return evo::resultError; }

						const Token& deducer_token = deducer_array_ref_deducer_type_source.getTokenBuffer()[
							deducer_dimension.deducer()
						];

						if(deducer_token.kind() == Token::Kind::DEDUCER){
							const sema::Expr created_int_value = sema::Expr(
								this->context.sema_buffer.createIntValue(
									core::GenericInt(
										unsigned(this->context.getTypeManager().numBitsOfPtr()), got_dimension.length()
									),
									this->context.getTypeManager().getTypeInfo(TypeManager::getTypeUSize()).baseTypeID()
								)
							);

							deduced_terms.emplace_back(
								DeducerMatchOutput::DeducedTerm::Expr(TypeManager::getTypeUSize(), created_int_value),
								deducer_dimension.deducer()
							);
						}

					}else{
						evo::debugAssert(
							deducer_dimension.isLength(),
							"Unknown array reference dimension kind"
						);

						if(deducer_dimension.length() != got_dimension.length()){ return evo::resultError; }
					}
				}

				if(deducer_array_ref_deducer_type.terminator.is<std::monostate>()){
					if(got_array_ref_type.terminator.has_value()){ return evo::resultError; }

				}else if(deducer_array_ref_deducer_type.terminator.is<core::GenericValue>()){
					if(
						deducer_array_ref_deducer_type.terminator.as<core::GenericValue>()
						!= *got_array_ref_type.terminator
					){
						return evo::resultError;
					}

				}else{
					const Token& deducer_token = deducer_array_ref_deducer_type_source.getTokenBuffer()[
						deducer_array_ref_deducer_type.terminator.as<Token::ID>()
					];

					if(deducer_token.kind() == Token::Kind::DEDUCER){
						deduced_terms.emplace_back(
							DeducerMatchOutput::DeducedTerm::Expr(
								got_array_ref_type.elementTypeID,
								this->generic_value_to_sema_expr(
									*got_array_ref_type.terminator,
									this->context.getTypeManager().getTypeInfo(got_array_ref_type.elementTypeID)
								)
							),
							deducer_array_ref_deducer_type.terminator.as<Token::ID>()
						);

					}else{
						evo::debugAssert(
							deducer_token.kind() == Token::Kind::ANONYMOUS_DEDUCER, "Unknown deducer kind"
						);
					}
				}

				return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
			} break;

			case BaseType::Kind::STRUCT_TEMPLATE_DEDUCER: {
				const evo::Result<bool> qualifiers_check_result =
					this->type_qualifiers_check(deducer.qualifiers(), got_type.qualifiers());
				if(qualifiers_check_result.isError() || qualifiers_check_result.value()){ return evo::resultError; }

				if(got_type.baseTypeID().kind() != BaseType::Kind::STRUCT){ return evo::resultError; }

				const BaseType::StructTemplateDeducer& struct_template_deducer =
					this->context.getTypeManager().getStructTemplateDeducer(
						deducer.baseTypeID().structTemplateDeducerID()
					);

				const BaseType::Struct& got_struct_type = 
					this->context.getTypeManager().getStruct(got_type.baseTypeID().structID());

				if(got_struct_type.templateID.has_value() == false){ return evo::resultError; }
				if(struct_template_deducer.structTemplateID != *got_struct_type.templateID){ return evo::resultError; }


				const BaseType::StructTemplate& got_struct_template =
					this->context.getTypeManager().getStructTemplate(*got_struct_type.templateID);


				const evo::SmallVector<BaseType::StructTemplate::Arg> got_template_args =
					got_struct_template.getInstantiationArgs(got_struct_type.instantiation);


				for(size_t i = 0; i < struct_template_deducer.args.size(); i+=1){
					const BaseType::StructTemplate::Arg& deducer_arg = struct_template_deducer.args[i];
					const BaseType::StructTemplate::Arg& got_arg = got_template_args[i];

					if(got_arg.is<TypeInfo::VoidableID>()){
						if(deducer_arg.as<TypeInfo::VoidableID>().isVoid()){
							if(got_arg.as<TypeInfo::VoidableID>().isVoid()){
								continue;
							}else{
								return evo::resultError;
							}

						}else if(got_arg.as<TypeInfo::VoidableID>().isVoid()){
							return evo::resultError;

						}else{
							DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
								deducer_arg.as<TypeInfo::VoidableID>().asTypeID(),
								got_arg.as<TypeInfo::VoidableID>().asTypeID()
							);

							switch(deducer_match_output.outcome()){
								case DeducerMatchOutput::Outcome::MATCH:    break;
								case DeducerMatchOutput::Outcome::NO_MATCH: return evo::resultError;
								case DeducerMatchOutput::Outcome::RESULT:   return deducer_match_output.result();
							}

							deduced_terms.append_range(std::move(deducer_match_output.deducedTerms()));
						}

					}else if(deducer_arg.is<TypeInfo::VoidableID>()){ // arg is deducer
						const TypeInfo& deducer_arg_deducer_type_info = this->context.getTypeManager().getTypeInfo(
							deducer_arg.as<TypeInfo::VoidableID>().asTypeID()
						);

						const BaseType::TypeDeducer& deducer_arg_deducer = 
							this->context.getTypeManager().getTypeDeducer(
								deducer_arg_deducer_type_info.baseTypeID().typeDeducerID()
							);

						if(deducer_arg_deducer.sourceID.has_value()){
							const Token& deducer_token =
								this->source.getTokenBuffer()[*deducer_arg_deducer.identTokenID];

							if(deducer_token.kind() == Token::Kind::DEDUCER){
								const TypeInfo::ID arg_type_id = *got_struct_template.params[i].typeID;

								deduced_terms.emplace_back(
									DeducerMatchOutput::DeducedTerm::Expr(
										arg_type_id,
										this->generic_value_to_sema_expr(
											got_arg.as<core::GenericValue>(),
											this->context.getTypeManager().getTypeInfo(arg_type_id)
										)
									),
									*deducer_arg_deducer.identTokenID
								);
							}
						}

					}else{
						if(deducer_arg.as<core::GenericValue>() != got_arg.as<core::GenericValue>()){
							return evo::resultError;
						}
					}
				}

				return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
			} break;

			case BaseType::Kind::INTERFACE_MAP: {
				const evo::Result<bool> qualifiers_check_result =
					this->type_qualifiers_check(deducer.qualifiers(), got_type.qualifiers());
				if(qualifiers_check_result.isError() || qualifiers_check_result.value()){ return evo::resultError; }

				if(got_type.baseTypeID().kind() != BaseType::Kind::INTERFACE_MAP){ return evo::resultError; }


				const BaseType::InterfaceMap& deducer_interface_map_type = 
					this->context.getTypeManager().getInterfaceMap(deducer.baseTypeID().interfaceMapID());

				const BaseType::InterfaceMap& got_interface_map_type = 
					this->context.getTypeManager().getInterfaceMap(got_type.baseTypeID().interfaceMapID());



				DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
					deducer_interface_map_type.underlyingTypeID, got_interface_map_type.underlyingTypeID
				);
				switch(deducer_match_output.outcome()){
					case DeducerMatchOutput::Outcome::MATCH:    break;
					case DeducerMatchOutput::Outcome::NO_MATCH: return evo::resultError;
					case DeducerMatchOutput::Outcome::RESULT:   return deducer_match_output.result();
				}
				deduced_terms.append_range(std::move(deducer_match_output.deducedTerms()));

				if(deducer_interface_map_type.interfaceID != got_interface_map_type.interfaceID){
					return evo::resultError;
				}

				return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
			} break;

			default: {
				if(deducer.baseTypeID() != got_type.baseTypeID()){ return evo::resultError; }
				return DeducerMatchOutput(std::move(deduced_terms), got_type_id);
			} break;
		}
	}


	auto SemanticAnalyzer::add_deduced_terms_to_scope(evo::ArrayProxy<DeducerMatchOutput::DeducedTerm> deduced_terms)
	-> evo::Result<> {
		for(const DeducerMatchOutput::DeducedTerm& deduced_term : deduced_terms){
			if(deduced_term.value.is<TypeInfo::VoidableID>()){
				if(
					this->add_ident_to_scope(
						this->source.getTokenBuffer()[deduced_term.tokenID].getString(),
						deduced_term.tokenID,
						true,
						sema::ScopeLevel::DeducedTypeFlag{},
						deduced_term.value.as<TypeInfo::VoidableID>(),
						deduced_term.tokenID
					).isError()
				){
					return evo::resultError;
				}

			}else{
				if(
					this->add_ident_to_scope(
						this->source.getTokenBuffer()[deduced_term.tokenID].getString(),
						deduced_term.tokenID,
						true,
						sema::ScopeLevel::DeducedExprFlag{},
						deduced_term.value.as<DeducerMatchOutput::DeducedTerm::Expr>().type_id,
						deduced_term.value.as<DeducerMatchOutput::DeducedTerm::Expr>().expr,
						deduced_term.tokenID
					).isError()
				){
					return evo::resultError;
				}
			}
		}

		return evo::Result<>();
	}


	auto SemanticAnalyzer::create_prefix_overload(
		const BaseType::Function& created_func_type,
		BaseType::Struct& current_struct,
		const AST::FuncDef& ast_func_def,
		sema::Func::ID created_func_id,
		sema::Func& created_func,
		bool is_commutative,
		bool is_swapped,
		const Token& name_token
	) -> evo::Result<> {

		//////////////////
		// params

		if(created_func_type.params.size() != 1){
			if(created_func_type.params.empty()){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
					ast_func_def,
					"Prefix operator overload must have a [this] parameter"
				);
			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
					ast_func_def.params[1],
					"Prefix operator overload must only have a [this] parameter"
				);
			}
			return evo::resultError;
		}

		if(
			this->source.getTokenBuffer()[created_func.params[0].ident.as<Token::ID>()].kind()
				!= Token::Kind::KEYWORD_THIS
		){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
				ast_func_def.params[0],
				"Prefix operator overload must have a [this] parameter"
			);
			return evo::resultError;
		}


		//////////////////
		// attributes

		if(is_commutative){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
				ast_func_def,
				"Prefix operator overload cannot have attribute #commutative"
			);
			return evo::resultError;

		}

		if(is_swapped){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
				ast_func_def,
				"Prefix operator overload cannot have attribute #swapped"
			);
			return evo::resultError;
		}


		//////////////////
		// returns

		if(created_func_type.returnTypes.size() > 1){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
				ast_func_def.returns[1],
				"Prefix operator overload cannot have multiple return values"
			);
			return evo::resultError;
		}

		if(created_func_type.returnTypes[0].isVoid()){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
				ast_func_def.returns[1],
				"Prefix operator overload must return a value"
			);
			return evo::resultError;
		}

		if(created_func_type.hasErrorReturn()){
			this->emit_error(
				Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
				ast_func_def.errorReturns[0],
				"Prefix operator overload that error are unimplemented"
			);
			return evo::resultError;
		}


		//////////////////
		// create

		const auto lock = std::scoped_lock(current_struct.prefixOverloadsLock);

		const auto [begin_overloads_range, end_overloads_range] = 
			current_struct.prefixOverloads.equal_range(name_token.kind());

		const auto overloads_range = evo::IterRange(begin_overloads_range, end_overloads_range);
		for(const auto& [_, existing_func_id] : overloads_range){
			const sema::Func& existing_func =
				this->context.getSemaBuffer().getFunc(existing_func_id);
			
			if(created_func.isEquivalentOverload(existing_func, this->context)){
				this->emit_error(
					Diagnostic::Code::SEMA_INVALID_OPERATOR_PREFIX_OVERLOAD,
					ast_func_def,
					"This operator overload was already defined",
					Diagnostic::Info(
						"Previously defined here:", this->get_location(existing_func_id)
					)
				);
				return evo::resultError;
			}
		}

		current_struct.prefixOverloads.emplace(name_token.kind(), created_func_id);

		return evo::Result<>();
	}


	auto SemanticAnalyzer::infix_overload_impl(
		const std::unordered_multimap<Token::Kind, sema::Func::ID>& infix_overloads,
		TermInfo& lhs,
		TermInfo& rhs,
		const AST::Infix& ast_infix
	) -> evo::Expected<sema::FuncCall::ID, Result> {
		const Token::Kind op_kind = this->source.getTokenBuffer()[ast_infix.opTokenID].kind();

		const auto [begin_overloads_range, end_overloads_range] = infix_overloads.equal_range(op_kind);
		const auto overloads_range = evo::IterRange(begin_overloads_range, end_overloads_range);

		if(overloads_range.empty()){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_type_info(lhs.type_id.as<TypeInfo::ID>(), infos, "Infix LHS type: ");
			this->diagnostic_print_type_info(rhs.type_id.as<TypeInfo::ID>(), infos, "Infix RHS type: ");
			this->emit_error(
				Diagnostic::Code::SEMA_MATH_INFIX_NO_MATCHING_OP,
				ast_infix,
				"No matching operation for these arguments",
				std::move(infos)
			);
			return evo::Unexpected(Result::ERROR);
		}

		auto overloads_list = evo::SmallVector<SelectFuncOverloadFuncInfo, 4>();
		overloads_list.reserve(overloads_range.size());
		for(const auto& [_, overload_id] : overloads_range){
			const sema::Func& overload = this->context.getSemaBuffer().getFunc(overload_id);
			overloads_list.emplace_back(
				overload_id, this->context.getTypeManager().getFunction(overload.typeID)
			);
		}

		auto arg_infos = evo::SmallVector<SelectFuncOverloadArgInfo>{
			SelectFuncOverloadArgInfo(lhs, ast_infix.lhs, std::nullopt),
			SelectFuncOverloadArgInfo(rhs, ast_infix.rhs, std::nullopt)
		};

		const evo::Result<size_t> selected_overload_index = this->select_func_overload(
			overloads_list, arg_infos, ast_infix, false, evo::SmallVector<Diagnostic::Info>()
		);

		if(selected_overload_index.isError()){ return evo::Unexpected(Result::ERROR); }

		const sema::Func::ID selected_overload_id =
			overloads_list[selected_overload_index.value()].func_id.as<sema::Func::ID>();

		if(this->get_current_func().attributes.isComptime){
			const sema::Func& infix_op_sema_func = this->context.getSemaBuffer().getFunc(selected_overload_id);
			if(infix_op_sema_func.attributes.isComptime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
					ast_infix.opTokenID,
					"Cannot call a non-comptime operator overload within a comptime function",
					Diagnostic::Info(
						"Called operator overload was defined here:", this->get_location(selected_overload_id)
					)
				);
				return evo::Unexpected(Result::ERROR);
			}

			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(selected_overload_id);
		}

		return this->context.sema_buffer.createFuncCall(
			selected_overload_id, evo::SmallVector<sema::Expr>{lhs.getExpr(), rhs.getExpr()}
		);
	}


	auto SemanticAnalyzer::prefix_overload_impl(
		const std::unordered_multimap<Token::Kind, sema::Func::ID>& prefix_overloads,
		TermInfo& expr,
		const AST::Prefix& ast_prefix,
		SymbolProc::TermInfoID output
	) -> Result {
		const Token::Kind op_kind = this->source.getTokenBuffer()[ast_prefix.opTokenID].kind();

		const auto [begin_overloads_range, end_overloads_range] = prefix_overloads.equal_range(op_kind);
		const auto overloads_range = evo::IterRange(begin_overloads_range, end_overloads_range);

		if(overloads_range.empty()){
			auto infos = evo::SmallVector<Diagnostic::Info>();
			this->diagnostic_print_type_info(expr.type_id.as<TypeInfo::ID>(), infos, "Prefix argument type: ");
			this->emit_error(
				Diagnostic::Code::SEMA_PREFIX_NO_MATCHING_OP,
				ast_prefix,
				"No matching operation for this prefix argument",
				std::move(infos)
			);
			return Result::ERROR;
		}

		auto overloads_list = evo::SmallVector<SelectFuncOverloadFuncInfo, 2>();
		overloads_list.reserve(overloads_range.size());
		for(const auto& [_, overload_id] : overloads_range){
			const sema::Func& overload = this->context.getSemaBuffer().getFunc(overload_id);
			overloads_list.emplace_back(
				overload_id, this->context.getTypeManager().getFunction(overload.typeID)
			);
		}

		auto arg_infos = evo::SmallVector<SelectFuncOverloadArgInfo>{
			SelectFuncOverloadArgInfo(expr, ast_prefix.rhs, std::nullopt)
		};

		const evo::Result<size_t> selected_overload_index = this->select_func_overload(
			overloads_list, arg_infos, ast_prefix, false, evo::SmallVector<Diagnostic::Info>()
		);

		if(selected_overload_index.isError()){ return Result::ERROR; }

		const sema::Func::ID selected_overload_id =
			overloads_list[selected_overload_index.value()].func_id.as<sema::Func::ID>();

		if(this->get_current_func().attributes.isComptime){
			const sema::Func& infix_op_sema_func = this->context.getSemaBuffer().getFunc(selected_overload_id);
			if(infix_op_sema_func.attributes.isComptime == false){
				this->emit_error(
					Diagnostic::Code::SEMA_FUNC_ISNT_COMPTIME,
					ast_prefix.opTokenID,
					"Cannot call a non-comptime operator overload within a comptime function",
					Diagnostic::Info(
						"Called operator overload was defined here:", this->get_location(selected_overload_id)
					)
				);
				return Result::ERROR;
			}

			this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(selected_overload_id);
		}


		const sema::Func& selected_overload = this->context.getSemaBuffer().getFunc(selected_overload_id);
		const BaseType::Function& selected_overload_type =
			this->context.getTypeManager().getFunction(selected_overload.typeID);

		this->return_term_info(output,
			TermInfo::ValueCategory::EPHEMERAL,
			expr.value_stage,
			TermInfo::ValueState::NOT_APPLICABLE,
			selected_overload_type.returnTypes[0].asTypeID(),
			sema::Expr(
				this->context.sema_buffer.createFuncCall(
					selected_overload_id, evo::SmallVector<sema::Expr>{expr.getExpr()}
				)
			)
		);
		return Result::SUCCESS;
	}




	auto SemanticAnalyzer::comptime_infix_math(
		Token::Kind op, sema::Expr lhs, sema::Expr rhs, std::optional<TypeInfo::ID> lhs_type
	) -> TermInfo {
		auto comptime_intrinsic_evaluator = ComptimeIntrinsicEvaluator(
			this->context.type_manager, this->context.sema_buffer
		);

		TermInfo output = [&](){
			switch(op){
				case Token::lookupKind("=="): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.eq(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);

					}else if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.eq(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.eq(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind("!="): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.neq(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);

					}else if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.neq(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.neq(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind("<"): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.lt(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);

					}else if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.lt(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.lt(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind("<="): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.lte(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);

					}else if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.lte(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.lte(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind(">"): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.gt(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);

					}else if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.gt(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.gt(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind(">="): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.gte(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);

					}else if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.gte(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.gte(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind("&"): {
					if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.bitwiseAnd(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.bitwiseAnd(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);
					}
				} break;

				case Token::lookupKind("|"): {
					if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.bitwiseOr(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.bitwiseOr(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);
					}
				} break;

				case Token::lookupKind("^"): {
					if(lhs.kind() == sema::Expr::Kind::BOOL_VALUE){
						return comptime_intrinsic_evaluator.bitwiseXor(
							this->context.sema_buffer.getBoolValue(lhs.boolValueID()).value,
							this->context.sema_buffer.getBoolValue(rhs.boolValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.bitwiseXor(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);
					}
				} break;

				case Token::lookupKind("<<"): {
					return comptime_intrinsic_evaluator.shl(
						lhs_type.value_or(TypeManager::getTypeI256()),
						true,
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					).value();
				} break;

				case Token::lookupKind("<<|"): {
					return comptime_intrinsic_evaluator.shlSat(
						lhs_type.value_or(TypeManager::getTypeI256()),
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					);
				} break;

				case Token::lookupKind(">>"): {
					return comptime_intrinsic_evaluator.shr(
						lhs_type.value_or(TypeManager::getTypeI256()),
						true,
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					).value();
				} break;

				case Token::lookupKind("+"): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.add(
							lhs_type.value_or(TypeManager::getTypeI256()),
							true,
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						).value();

					}else{
						return comptime_intrinsic_evaluator.fadd(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind("+%"): {
					return comptime_intrinsic_evaluator.add(
						lhs_type.value_or(TypeManager::getTypeI256()),
						true,
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					).value();
				} break;

				case Token::lookupKind("+|"): {
					return comptime_intrinsic_evaluator.addSat(
						lhs_type.value_or(TypeManager::getTypeI256()),
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					);
				} break;

				case Token::lookupKind("-"): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.sub(
							lhs_type.value_or(TypeManager::getTypeI256()),
							true,
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						).value();

					}else{
						return comptime_intrinsic_evaluator.fsub(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind("-%"): {
					return comptime_intrinsic_evaluator.sub(
						lhs_type.value_or(TypeManager::getTypeI256()),
						true,
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					).value();
				} break;

				case Token::lookupKind("-|"): {
					return comptime_intrinsic_evaluator.subSat(
						lhs_type.value_or(TypeManager::getTypeI256()),
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					);
				} break;

				case Token::lookupKind("*"): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.mul(
							lhs_type.value_or(TypeManager::getTypeI256()),
							true,
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						).value();

					}else{
						return comptime_intrinsic_evaluator.fmul(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind("*%"): {
					return comptime_intrinsic_evaluator.mul(
						lhs_type.value_or(TypeManager::getTypeI256()),
						true,
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					).value();
				} break;

				case Token::lookupKind("*|"): {
					return comptime_intrinsic_evaluator.mulSat(
						lhs_type.value_or(TypeManager::getTypeI256()),
						this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
						this->context.sema_buffer.getIntValue(rhs.intValueID()).value
					);
				} break;

				case Token::lookupKind("/"): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.div(
							lhs_type.value_or(TypeManager::getTypeI256()),
							false,
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						).value();

					}else{
						return comptime_intrinsic_evaluator.fdiv(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				case Token::lookupKind("%"): {
					if(lhs.kind() == sema::Expr::Kind::INT_VALUE){
						return comptime_intrinsic_evaluator.rem(
							lhs_type.value_or(TypeManager::getTypeI256()),
							this->context.sema_buffer.getIntValue(lhs.intValueID()).value,
							this->context.sema_buffer.getIntValue(rhs.intValueID()).value
						);

					}else{
						return comptime_intrinsic_evaluator.rem(
							lhs_type.value_or(TypeManager::getTypeF128()),
							this->context.sema_buffer.getFloatValue(lhs.floatValueID()).value,
							this->context.sema_buffer.getFloatValue(rhs.floatValueID()).value
						);
					}
				} break;

				default: {
					evo::debugFatalBreak("Invalid infix op");
				} break;
			}
		}();

		if(lhs_type.has_value() == false){
			output.value_category = TermInfo::ValueCategory::EPHEMERAL_FLUID;
			output.type_id = TermInfo::FluidType();
		}

		return output;
	}







	template<bool IS_COMPTIME>
	auto SemanticAnalyzer::union_designated_init_new(
		const Instruction::DesignatedInitNew<IS_COMPTIME>& instr, TypeInfo::ID target_type_info_id
	) -> Result {
		const TypeInfo& target_type_info = this->context.getTypeManager().getTypeInfo(target_type_info_id);

		if(instr.designated_init_new.memberInits.size() != 1){
			if(instr.designated_init_new.memberInits.size() == 0){
				this->emit_error(
					Diagnostic::Code::SEMA_NEW_UNION_INIT_WRONG_NUM_FIELDS,
					instr.designated_init_new,
					"Union designated operator [new] must have a field"
				);
			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_NEW_UNION_INIT_WRONG_NUM_FIELDS,
					instr.designated_init_new.memberInits[1].ident,
					"Too many fields in union designated operator [new]",
					Diagnostic::Info("Union can only hold one field at a time")
				);
				return Result::ERROR;
			}
		}


		const std::string_view used_field_name =
			this->source.getTokenBuffer()[instr.designated_init_new.memberInits[0].ident].getString();


		const BaseType::Union& union_info =
			this->context.getTypeManager().getUnion(target_type_info.baseTypeID().unionID());

		for(size_t i = 0; const BaseType::Union::Field& field : union_info.fields){
			EVO_DEFER([&](){ i += 1; });

			const std::string_view field_name = union_info.getFieldName(field, this->context.getSourceManager());

			if(used_field_name != field_name){ continue; }


			TermInfo& init_value = this->get_term_info(instr.member_init_exprs[0]);

			if(field.typeID.isVoid()){
				if(init_value.value_category != TermInfo::ValueCategory::NULL_VALUE){
					this->emit_error(
						Diagnostic::Code::SEMA_NEW_UNION_INIT_VALUE_TO_VOID_FIELD,
						instr.designated_init_new.memberInits[0].expr,
						"Initialization of a `Void` union field must be value [null]"
					);
					return Result::ERROR;
				}
				
			}else{
				if(this->type_check<true, true>(
					field.typeID.asTypeID(),
					init_value,
					"Union field initializer",
					instr.designated_init_new.memberInits[0].ident
				).ok == false){
					return Result::ERROR;
				}

				if(
					this->currently_in_unsafe() == false
					&& this->context.getTypeManager().getTypeInfo(field.typeID.asTypeID()).isUninitPointer()
				){
					this->emit_error(
						Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
						instr.designated_init_new.memberInits[0].ident,
						"Unsafe union designated initializer [new] while not in an unsafe scope"
					);
					return Result::ERROR;
				}
			}


			const TermInfo::ValueStage value_stage = [&](){
				if constexpr(IS_COMPTIME){
					return TermInfo::ValueStage::COMPTIME;
				}else{
					if(this->currently_in_func() == false){
						return TermInfo::ValueStage::COMPTIME;

					}else if(this->get_current_func().attributes.isComptime){
						return TermInfo::ValueStage::INTERPTIME;

					}else{
						return TermInfo::ValueStage::RUNTIME;
					}
				}
			}();



			if constexpr(IS_COMPTIME){
				if(union_info.isUntagged){
					this->return_term_info(instr.output,
						TermInfo::ValueCategory::EPHEMERAL,
						value_stage,
						TermInfo::ValueState::NOT_APPLICABLE,
						target_type_info_id,
						init_value.getExpr()
					);

				}else{
					this->emit_error(
						Diagnostic::Code::MISC_UNIMPLEMENTED_FEATURE,
						instr.designated_init_new,
						"Comptime tagged union designated init `new` is unimplemented"
					);
					return Result::ERROR;
				}

			}else{
				this->return_term_info(instr.output,
					TermInfo::ValueCategory::EPHEMERAL,
					value_stage,
					TermInfo::ValueState::NOT_APPLICABLE,
					target_type_info_id,
					sema::Expr(
						this->context.sema_buffer.createUnionDesignatedInitNew(
							init_value.getExpr(), target_type_info.baseTypeID().unionID(), uint32_t(i)
						)
					)
				);
			}

			return Result::SUCCESS;
		}


		this->emit_error(
			Diagnostic::Code::SEMA_NEW_UNION_INIT_FIELD_DOESNT_EXIST,
			instr.designated_init_new.memberInits[0].ident,
			std::format("This union has no member \"{}\"", used_field_name)
		);
		return Result::ERROR;
	}




	auto SemanticAnalyzer::impl_instr_interface_impl_def_non_deducer(const Instruction::InterfaceImplDef& instr)
	-> Result {
		SymbolProc::InterfaceImplInfo& info = this->symbol_proc.extra_info.as<SymbolProc::InterfaceImplInfo>();

		BaseType::Interface::Impl& interface_impl = *info.interface_impl.as<BaseType::Interface::Impl*>();

		interface_impl.methods.reserve(info.target_interface.methods.size());

		const auto interface_has_member = [&](std::string_view ident) -> bool {
			for(const sema::Func::ID method_id : info.target_interface.methods){
				const sema::Func& method = this->context.getSemaBuffer().getFunc(method_id);
				const std::string_view target_method_name = method.getName(this->context.getSourceManager());
				if(target_method_name == ident){ return true; }
			}

			return false;
		};


		if(info.target_interface.methods.empty() == false){
			size_t method_init_i = 0;
			for(sema::Func::ID target_method_id : info.target_interface.methods){
				const sema::Func& target_method = this->context.getSemaBuffer().getFunc(target_method_id);
				const std::string_view target_method_name = target_method.getName(this->context.getSourceManager());

				if(method_init_i >= instr.interface_impl.methods.size()){
					if(target_method.status == sema::Func::Status::DEF_DONE){ // has default
						interface_impl.methods.emplace_back(target_method_id);
						continue;
					}

					if(instr.interface_impl.methods.empty()){
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_IMPL_METHOD_NOT_SET,
							instr.interface_impl,
							std::format("Method \"{}\" was not set in interface impl", target_method_name)
						);
					}else{
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_IMPL_METHOD_NOT_SET,
							instr.interface_impl,
							std::format("Method \"{}\" was not set in interface impl", target_method_name),
							Diagnostic::Info(
								std::format("Method listing for \"{}\" should go after this one", target_method_name),
								this->get_location(instr.interface_impl.methods[method_init_i - 1].method)
							)
						);
					}

					return Result::ERROR;

					
				}else{
					const AST::InterfaceImpl::Method& method_init = instr.interface_impl.methods[method_init_i];

					const std::string_view method_init_name =
						this->source.getTokenBuffer()[method_init.method].getString();

					if(target_method_name != method_init_name){
						if(target_method.status == sema::Func::Status::DEF_DONE){ // has default
							interface_impl.methods.emplace_back(target_method_id);
							continue;
						}

						if(interface_has_member(method_init_name)){
							this->emit_error(
								Diagnostic::Code::SEMA_INTERFACE_IMPL_METHOD_NOT_SET,
								instr.interface_impl,
								std::format("Method \"{}\" was not set in interface impl", target_method_name),
								Diagnostic::Info(
									std::format(
										"Method listing for \"{}\" should go before this one", target_method_name
									),
									this->get_location(method_init.method)
								)
							);
						}else{
							this->emit_error(
								Diagnostic::Code::SEMA_INTERFACE_IMPL_METHOD_DOESNT_EXIST,
								method_init.method,
								std::format("This interface has no method \"{}\"", method_init_name),
								Diagnostic::Info(
									"Interface was declared here:", this->get_location(info.target_interface)
								)
							);
							return Result::ERROR;
						}

						return Result::ERROR;
					}

					// find if of the overloads any match
					bool found_overload = false;
					using Overload = evo::Variant<sema::FuncID, sema::TemplatedFuncID>;
					for(
						const Overload& overload : info.targets[method_init_i].type_id.as<TermInfo::FuncOverloadList>()
					){
						if(overload.is<sema::TemplatedFunc::ID>()){ continue; }

						const sema::Func& overload_sema =
							this->context.getSemaBuffer().getFunc(overload.as<sema::Func::ID>());

						if(target_method.typeID != overload_sema.typeID){
							const BaseType::Function& target_method_type = 
								this->context.getTypeManager().getFunction(target_method.typeID);

							const BaseType::Function& overload_sema_type = 
								this->context.getTypeManager().getFunction(overload_sema.typeID);


							if(target_method_type.params.size() != overload_sema_type.params.size()){ continue; }

							// params
							for(size_t param_i = 1; param_i < target_method_type.params.size(); param_i+=1){
								if(target_method_type.params[param_i] != overload_sema_type.params[param_i]){
									continue;
								}
							}

							// return params
							if(target_method_type.returnTypes != overload_sema_type.returnTypes){
								if(target_method_type.returnTypes.size() != overload_sema_type.returnTypes.size()){
									continue;
								}

								bool return_params_matched = true;
								for(size_t i = 0; i < target_method_type.returnTypes.size(); i+=1){
									if(target_method_type.returnTypes[i].isVoid()){
										return_params_matched = overload_sema_type.returnTypes[i].isVoid();
										break;

									}else if(overload_sema_type.returnTypes[i].isVoid()){
										return_params_matched = false;
										break;
									}

									const TypeInfo::ID target_ret_param_type_id = 
										target_method_type.returnTypes[i].asTypeID();

									const TypeInfo::ID overload_ret_param_type_id = 
										overload_sema_type.returnTypes[i].asTypeID();

									if(target_ret_param_type_id == overload_ret_param_type_id){ continue; }


									//////////////////
									// deducers

									const DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
										target_ret_param_type_id, overload_ret_param_type_id
									);

									switch(deducer_match_output.outcome()){
										case DeducerMatchOutput::Outcome::MATCH: {
											continue;
										} break;

										case DeducerMatchOutput::Outcome::NO_MATCH: {
											return_params_matched = false;
											break;
										} break;

										case DeducerMatchOutput::Outcome::RESULT: {
											return deducer_match_output.result();
										} break;
									}
								}

								if(return_params_matched == false){ continue; }
							}

							// error params
							if(target_method_type.errorTypes != overload_sema_type.errorTypes){
								if(target_method_type.errorTypes.size() != overload_sema_type.errorTypes.size()){
									continue;
								}

								bool error_params_matched = true;
								for(size_t i = 0; i < target_method_type.errorTypes.size(); i+=1){
									if(target_method_type.errorTypes[i].isVoid()){
										error_params_matched = overload_sema_type.errorTypes[i].isVoid();
										break;

									}else if(overload_sema_type.errorTypes[i].isVoid()){
										error_params_matched = false;
										break;
									}

									const TypeInfo::ID target_ret_param_type_id = 
										target_method_type.errorTypes[i].asTypeID();

									const TypeInfo::ID overload_ret_param_type_id = 
										overload_sema_type.errorTypes[i].asTypeID();

									if(target_ret_param_type_id == overload_ret_param_type_id){ continue; }


									//////////////////
									// deducers

									const DeducerMatchOutput deducer_match_output = this->deducer_matches_and_extract(
										target_ret_param_type_id, overload_ret_param_type_id
									);

									switch(deducer_match_output.outcome()){
										case DeducerMatchOutput::Outcome::MATCH: {
											continue;
										} break;

										case DeducerMatchOutput::Outcome::NO_MATCH: {
											error_params_matched = false;
											break;
										} break;

										case DeducerMatchOutput::Outcome::RESULT: {
											return deducer_match_output.result();
										} break;
									}
								}

								if(error_params_matched == false){ continue; }
							}

						}

						if(target_method.attributes.isComptime && overload_sema.attributes.isComptime == false){
							continue;
						}

						interface_impl.methods.emplace_back(overload.as<sema::Func::ID>());
						found_overload = true;
						break;
					}

					if(found_overload == false){
						this->emit_error(
							Diagnostic::Code::SEMA_INTERFACE_IMPL_NO_OVERLOAD_MATCHES,
							method_init.method,
							"No overload has correct signature in interface impl",
							Diagnostic::Info("Interface method declared here:", this->get_location(target_method_id))
						);
						return Result::ERROR;
					}

					method_init_i += 1;
				}
			}

		}else{ // interface defines no methods
			if(instr.interface_impl.methods.empty() == false){
				const Token::ID first_method_ident_token_id = instr.interface_impl.methods[0].method;
				const std::string_view first_method_ident_str =
					this->source.getTokenBuffer()[first_method_ident_token_id].getString();

				this->emit_error(
					Diagnostic::Code::SEMA_INTERFACE_IMPL_METHOD_DOESNT_EXIST,
					first_method_ident_token_id,
					std::format("This interface has no method \"{}\"", first_method_ident_str),
					Diagnostic::Info(
						"Interface was declared here:", this->get_location(info.target_interface)
					)
				);
				return Result::ERROR;
			}
		}



		const BaseType::Interface::Impl* old_impl = nullptr;

		{
			const TypeInfo::ID target_type_id = [&](){
				if(info.type_info.is<SymbolProc::InterfaceImplInfo::ParentTypeInfo>()){
					return this->context.type_manager.getOrCreateTypeInfo(
						TypeInfo(BaseType::ID(this->scope.getCurrentEncapsulatingSymbol().as<BaseType::Struct::ID>()))
					);
					
				}else{
					return info.type_info.as<TypeInfo::ID>();
				}
			}();

			const auto lock = std::scoped_lock(info.target_interface.implsLock);

			const auto find_old_impl = info.target_interface.impls.find(target_type_id);

			if(find_old_impl == info.target_interface.impls.end()){
				info.target_interface.impls.emplace(target_type_id, interface_impl);

			}else{
				if(find_old_impl->second.instantiatingSymbolProc.load(std::memory_order::relaxed).has_value()){
					old_impl = &find_old_impl->second;
					
				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_INTERFACE_IMPL_ALREADY_EXISTS,
						instr.interface_impl,
						"Interface impl for this interface and type already exists",
						Diagnostic::Info(
							"Previously defined here:", this->get_location(find_old_impl->second.astInterfaceImpl)
						)
					);
					return Result::ERROR;
				}
			}
		}

		if(this->pop_scope_level<PopScopeLevelKind::SYMBOL_END>().isError()){ return Result::ERROR; }

		this->propagate_finished_def();

		if(old_impl != nullptr){
			old_impl->instantiatingSymbolProc = std::optional<SymbolProc::ID>();
		}



		bool any_waiting = false;
		for(const sema::Func::ID method_id : interface_impl.methods){
			const sema::Func& method = this->context.getSemaBuffer().getFunc(method_id);

			if(method.attributes.isComptime == false){ continue; }

			SymbolProc& method_symbol_proc = this->context.symbol_proc_manager.getSymbolProc(*method.symbolProcID);

			const SymbolProc::WaitOnResult wait_on_result = method_symbol_proc.waitOnPIRDeclIfNeeded(
				this->symbol_proc_id, this->context, *method.symbolProcID
			);

			switch(wait_on_result){
				case SymbolProc::WaitOnResult::NOT_NEEDED:                break;
				case SymbolProc::WaitOnResult::WAITING_UNSUSPEND: {
					this->context.symbol_proc_manager.symbol_proc_unsuspended();
					this->context.add_task_to_work_manager(*method.symbolProcID);
					[[fallthrough]];
				}
				case SymbolProc::WaitOnResult::WAITING:                   any_waiting = true; break;
				case SymbolProc::WaitOnResult::WAS_ERRORED:               return Result::ERROR;
				case SymbolProc::WaitOnResult::WAS_PASSED_ON_BY_WHEN_COND:evo::debugFatalBreak("Shouldn't be possible");
				case SymbolProc::WaitOnResult::CIRCULAR_DEP_DETECTED:     evo::debugFatalBreak("Shouldn't be possible");
			}
		}

		if(any_waiting){
			if(this->symbol_proc.shouldContinueRunning()){
				return Result::SUCCESS;
			}else{
				return Result::NEED_TO_WAIT_BEFORE_NEXT_INSTR;
			}

		}else{
			return Result::SUCCESS;
		}
	}


	auto SemanticAnalyzer::impl_instr_interface_impl_def_deducer() -> Result {
		const SymbolProc::InterfaceImplInfo& info = this->symbol_proc.extra_info.as<SymbolProc::InterfaceImplInfo>();

		const BaseType::Interface::DeducerImpl* deducer_impl =
			info.interface_impl.as<BaseType::Interface::DeducerImpl*>();

		{
			const auto lock = std::scoped_lock(info.target_interface.deducerImplsLock);
			info.target_interface.deducerImpls.emplace_back(deducer_impl);
		}

		if(this->pop_scope_level<PopScopeLevelKind::SYMBOL_END>().isError()){ return Result::ERROR; }

		this->propagate_finished_def();
		return Result::SUCCESS;
	}



	//////////////////////////////////////////////////////////////////////
	// attributes


	auto SemanticAnalyzer::analyze_global_var_attrs(
		const AST::VarDef& var_decl, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<GlobalVarAttrs> {
		auto attr_pub = ConditionalAttribute(*this, "pub");
		auto attr_priv = ConditionalAttribute(*this, "priv");
		auto attr_global = Attribute(*this, "global");

		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(var_decl.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "pub"){
				if(attribute_params_info[i].empty()){
					if(attr_pub.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #pub",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool pub_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_pub.set(attribute.attribute, pub_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #pub does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "priv"){
				if(attribute_params_info[i].empty()){
					if(attr_priv.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #priv",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool priv_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_priv.set(attribute.attribute, priv_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #priv does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "global"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #global does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_global.set(attribute.attribute).isError()){ return evo::resultError; }

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown global variable attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}


		return GlobalVarAttrs{
			.is_pub    = attr_pub.is_set(),
			.is_priv   = attr_priv.is_set(),
			.is_global = attr_global.is_set(),
		};
	}


	auto SemanticAnalyzer::analyze_func_alias_attrs(
		const AST::FuncAliasDef& func_alias_decl, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<FuncAliasAttrs> {
		auto attr_pub = ConditionalAttribute(*this, "pub");
		auto attr_priv = ConditionalAttribute(*this, "priv");


		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(func_alias_decl.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "pub"){
				if(attribute_params_info[i].empty()){
					if(attr_pub.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #pub",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool pub_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_pub.set(attribute.attribute, pub_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #pub does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "priv"){
				if(attribute_params_info[i].empty()){
					if(attr_priv.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #priv",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool priv_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_priv.set(attribute.attribute, priv_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #priv does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown variable attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}


		return FuncAliasAttrs{
			.is_pub  = attr_pub.is_set(),
			.is_priv = attr_priv.is_set(),
		};
	}



	auto SemanticAnalyzer::analyze_var_attrs(
		const AST::VarDef& var_decl, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<VarAttrs> {
		auto attr_global = Attribute(*this, "global");

		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(var_decl.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();


			if(attribute_str == "global"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #global does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_global.set(attribute.attribute).isError()){ return evo::resultError; }

			}else if(attribute_str == "pub"){
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					"Unknown variable attribute #pub",
					Diagnostic::Info("Note: attribute `#pub` is not allowed on local variables")
				);
				return evo::resultError;

			}else if(attribute_str == "priv"){
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					"Unknown variable attribute #priv",
					Diagnostic::Info("Note: attribute `#priv` is not allowed on local variables")
				);
				return evo::resultError;

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown variable attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}


		return VarAttrs(attr_global.is_set());
	}



	auto SemanticAnalyzer::analyze_alias_attrs(
		const AST::AliasDef& alias_def, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<AliasAttrs> {
		auto attr_pub = ConditionalAttribute(*this, "pub");
		auto attr_priv = ConditionalAttribute(*this, "priv");
		auto attr_distinct = Attribute(*this, "distinct");

		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(alias_def.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "pub"){
				if(attribute_params_info[i].empty()){
					if(attr_pub.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #pub",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool pub_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_pub.set(attribute.attribute, pub_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #pub does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "priv"){
				if(attribute_params_info[i].empty()){
					if(attr_priv.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #priv",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool priv_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_priv.set(attribute.attribute, priv_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #priv does not accept more than 1 argument"
					);
					return evo::resultError;
				}


			}else if(attribute_str == "distinct"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #distinct does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_distinct.set(attribute.attribute).isError()){ return evo::resultError; }

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown alias attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}

		return AliasAttrs{
			.is_pub      = attr_pub.is_set(),
			.is_priv     = attr_priv.is_set(),
			.is_distinct = attr_distinct.is_set(),
		};
	}



	auto SemanticAnalyzer::analyze_local_alias_attrs(
		const AST::AliasDef& alias_def, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<LocalAliasAttrs> {
		auto attr_distinct = Attribute(*this, "distinct");

		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(alias_def.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "distinct"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #distinct does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_distinct.set(attribute.attribute).isError()){ return evo::resultError; }

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown alias attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}

		return LocalAliasAttrs{
			.is_distinct = attr_distinct.is_set(),
		};
	}




	auto SemanticAnalyzer::analyze_struct_attrs(
		const AST::StructDef& struct_def, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<StructAttrs> {
		auto attr_pub = ConditionalAttribute(*this, "pub");
		auto attr_priv = ConditionalAttribute(*this, "priv");
		auto attr_packed = Attribute(*this, "packed");
		auto attr_ordered = Attribute(*this, "ordered");
		// auto attr_extern = Attribute(*this, "extern");


		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(struct_def.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "pub"){
				if(attribute_params_info[i].empty()){
					if(attr_pub.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #pub",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool pub_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_pub.set(attribute.attribute, pub_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #pub does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "priv"){
				if(attribute_params_info[i].empty()){
					if(attr_priv.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #priv",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool priv_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_priv.set(attribute.attribute, priv_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #priv does not accept more than 1 argument"
					);
					return evo::resultError;
				}


			}else if(attribute_str == "ordered"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #ordered does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_ordered.set(attribute.attribute).isError()){ return evo::resultError; }

			}else if(attribute_str == "packed"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #packed does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_packed.set(attribute.attribute).isError()){ return evo::resultError; }

			}else if(attribute_str == "comptimeAssert"){
				if(attribute_params_info[i].empty()){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #comptimeAssert requires a condition argument"
					);
					return evo::resultError;
				}

				if(attribute_params_info[i].size() > 2){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[2],
						"Attribute #comptimeAssert does not accept more than 2 arguments"
					);
					return evo::resultError;
				}


				TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
				if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
					return evo::resultError;
				}

				if(this->type_check<true, true>(
					this->context.getTypeManager().getTypeBool(),
					cond_term_info,
					"Condition in #comptimeAssert",
					attribute.args[0]
				).ok == false){
					return evo::resultError;
				}

				const bool cond = this->context.sema_buffer.getBoolValue(cond_term_info.getExpr().boolValueID()).value;


				auto message = std::string_view();

				if(attribute_params_info[i].size() == 2){
					TermInfo& message_term_info = this->get_term_info(attribute_params_info[i][1]);
					if(this->check_term_isnt_type(message_term_info, attribute.args[1]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						TypeManager::getTypeStringRef(),
						message_term_info,
						"Message in #comptimeAssert",
						attribute.args[1]
					).ok == false){
						return evo::resultError;
					}

					message = this->extract_string_from_sema_expr(message_term_info.getExpr());
				}

				if(cond == false){
					auto infos = evo::SmallVector<Diagnostic::Info>();

					if(message.empty() == false){
						infos.emplace_back(std::format("Message: \"{}\"", message));
					}

					this->emit_error(
						Diagnostic::Code::SEMA_COMPTIME_ASSERT_FAIL,
						attribute.attribute,
						"Comptime assert fail",
						std::move(infos)
					);
					return evo::resultError;
				}

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown struct attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}


		return StructAttrs{
			.is_pub     = attr_pub.is_set(),
			.is_priv     = attr_priv.is_set(),
			.is_ordered = attr_ordered.is_set(),
			.is_packed  = attr_packed.is_set(),
		};
	}


	auto SemanticAnalyzer::analyze_union_attrs(
		const AST::UnionDef& union_def, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<UnionAttrs> {
		auto attr_pub = ConditionalAttribute(*this, "pub");
		auto attr_priv = ConditionalAttribute(*this, "priv");
		auto attr_untagged = Attribute(*this, "untagged");


		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(union_def.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "pub"){
				if(attribute_params_info[i].empty()){
					if(attr_pub.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #pub",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool pub_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_pub.set(attribute.attribute, pub_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #pub does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "priv"){
				if(attribute_params_info[i].empty()){
					if(attr_priv.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #priv",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool priv_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_priv.set(attribute.attribute, priv_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #priv does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "untagged"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #untagged does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_untagged.set(attribute.attribute).isError()){ return evo::resultError; }

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown union attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}


		return UnionAttrs{
			.is_pub      = attr_pub.is_set(),
			.is_priv     = attr_pub.is_set(),
			.is_untagged = attr_untagged.is_set(),
		};
	}



	auto SemanticAnalyzer::analyze_enum_attrs(
		const AST::EnumDef& enum_def, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<EnumAttrs> {
		auto attr_pub = ConditionalAttribute(*this, "pub");
		auto attr_priv = ConditionalAttribute(*this, "priv");


		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(enum_def.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "pub"){
				if(attribute_params_info[i].empty()){
					if(attr_pub.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #pub",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool pub_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_pub.set(attribute.attribute, pub_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #pub does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "priv"){
				if(attribute_params_info[i].empty()){
					if(attr_priv.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #priv",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool priv_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_priv.set(attribute.attribute, priv_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #priv does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown enum attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}


		return EnumAttrs{
			.is_pub  = attr_pub.is_set(),
			.is_priv = attr_priv.is_set(),
		};
	}




	auto SemanticAnalyzer::analyze_func_attrs(
		const AST::FuncDef& func_decl, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<FuncAttrs> {
		auto attr_pub = ConditionalAttribute(*this, "pub");
		auto attr_priv = ConditionalAttribute(*this, "priv");
		auto attr_rt = ConditionalAttribute(*this, "rt");
		auto attr_unsafe = ConditionalAttribute(*this, "unsafe");
		auto attr_export = Attribute(*this, "export");
		auto attr_no_return = Attribute(*this, "noReturn");
		auto attr_entry = Attribute(*this, "entry");
		auto attr_commutative = Attribute(*this, "commutative");
		auto attr_swapped = Attribute(*this, "swapped");
		auto attr_implicit = Attribute(*this, "implicit");



		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(func_decl.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "pub"){
				if(attribute_params_info[i].empty()){
					if(attr_pub.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #pub",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool pub_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_pub.set(attribute.attribute, pub_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #pub does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "priv"){
				if(attribute_params_info[i].empty()){
					if(attr_priv.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #priv",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool priv_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_priv.set(attribute.attribute, priv_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #priv does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "rt"){
				if(attribute_params_info[i].empty()){
					if(attr_rt.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #rt",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool rt_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_rt.set(attribute.attribute, rt_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #rt does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "unsafe"){
				if(attribute_params_info[i].empty()){
					if(attr_unsafe.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #unsafe",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool unsafe_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_unsafe.set(attribute.attribute, unsafe_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #unsafe does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "export"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #export does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_entry.is_set()){
					this->emit_error(
						Diagnostic::Code::SEMA_THESE_ATTRIBUTES_CANNOT_BE_COMBINED,
						attribute.attribute,
						"A function cannot have both attribute #export and #entry"
					);
					return evo::resultError;
				}

				if(attr_export.set(attribute.attribute).isError()){ return evo::resultError; }

			}else if(attribute_str == "noReturn"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #noReturn does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_entry.is_set()){
					this->emit_error(
						Diagnostic::Code::SEMA_THESE_ATTRIBUTES_CANNOT_BE_COMBINED,
						attribute.attribute,
						"A function cannot have both attribute #noReturn and #entry"
					);
					return evo::resultError;
				}

				if(attr_no_return.set(attribute.attribute).isError()){ return evo::resultError; }

			}else if(attribute_str == "entry"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #entry does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_export.is_set()){
					this->emit_error(
						Diagnostic::Code::SEMA_THESE_ATTRIBUTES_CANNOT_BE_COMBINED,
						attribute.attribute,
						"A function cannot have both attribute #entry and #export"
					);
					return evo::resultError;
				}

				if(attr_entry.set(attribute.attribute).isError()){ return evo::resultError; }
				attr_rt.implicitly_set(attribute.attribute, true);

			}else if(attribute_str == "commutative"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #commutative does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_swapped.is_set()){
					this->emit_error(
						Diagnostic::Code::SEMA_THESE_ATTRIBUTES_CANNOT_BE_COMBINED,
						attribute.attribute,
						"A function cannot have both attribute #commutative and #swapped"
					);
					return evo::resultError;
				}
				
				if(attr_commutative.set(attribute.attribute).isError()){ return evo::resultError; }

			}else if(attribute_str == "swapped"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #swapped does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_commutative.is_set()){
					this->emit_error(
						Diagnostic::Code::SEMA_THESE_ATTRIBUTES_CANNOT_BE_COMBINED,
						attribute.attribute,
						"A function cannot have both attribute #swapped and #commutative"
					);
					return evo::resultError;
				}
				
				if(attr_swapped.set(attribute.attribute).isError()){ return evo::resultError; }

			}else if(attribute_str == "builtin"){
				// do nothing (checked already in SymbolProc)

			}else if(attribute_str == "implicit"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #implicit does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_implicit.set(attribute.attribute).isError()){ return evo::resultError; }

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown function attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}

		return FuncAttrs{
			.is_pub         = attr_pub.is_set(),
			.is_priv        = attr_priv.is_set(),
			.is_runtime     = attr_rt.is_set(),
			.is_unsafe      = attr_unsafe.is_set(),
			.is_export      = attr_export.is_set(),
			.is_no_return   = attr_no_return.is_set(),
			.is_entry       = attr_entry.is_set(),
			.is_commutative = attr_commutative.is_set(),
			.is_swapped     = attr_swapped.is_set(),
			.is_implicit    = attr_implicit.is_set(),
		};
	}



	auto SemanticAnalyzer::analyze_interface_attrs(
		const AST::InterfaceDef& interface_def, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<InterfaceAttrs> {
		auto attr_pub = ConditionalAttribute(*this, "pub");
		auto attr_priv = ConditionalAttribute(*this, "priv");
		auto attr_polymorphic = Attribute(*this, "polymorphic");

		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(interface_def.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();


			if(attribute_str == "pub"){
				if(attribute_params_info[i].empty()){
					if(attr_pub.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #pub",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool pub_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_pub.set(attribute.attribute, pub_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #pub does not accept more than 1 argument"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "priv"){
				if(attribute_params_info[i].empty()){
					if(attr_priv.set(attribute.attribute, true).isError()){ return evo::resultError; } 

				}else if(attribute_params_info[i].size() == 1){
					TermInfo& cond_term_info = this->get_term_info(attribute_params_info[i][0]);
					if(this->check_term_isnt_type(cond_term_info, attribute.args[0]).isError()){
						return evo::resultError;
					}

					if(this->type_check<true, true>(
						this->context.getTypeManager().getTypeBool(),
						cond_term_info,
						"Condition in #priv",
						attribute.args[0]
					).ok == false){
						return evo::resultError;
					}

					const bool priv_cond = this->context.sema_buffer
						.getBoolValue(cond_term_info.getExpr().boolValueID()).value;

					if(attr_priv.set(attribute.attribute, priv_cond).isError()){ return evo::resultError; }

				}else{
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args[1],
						"Attribute #priv does not accept more than 1 argument"
					);
					return evo::resultError;
				}


			}else if(attribute_str == "polymorphic"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #polymorphic does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_polymorphic.set(attribute.attribute).isError()){ return evo::resultError; }

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown interface attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}

		return InterfaceAttrs{
			.is_pub         = attr_pub.is_set(),
			.is_priv        = attr_priv.is_set(),
			.is_polymorphic = attr_polymorphic.is_set(),
		};
	}




	auto SemanticAnalyzer::analyze_switch_attrs(
		const AST::Switch& switch_stmt, evo::ArrayProxy<Instruction::AttributeParams> attribute_params_info
	) -> evo::Result<SwitchAttrs> {
		auto attr_no_jump = Attribute(*this, "noJump");
		auto attr_partial = Attribute(*this, "partial");

		const AST::AttributeBlock& attribute_block = 
			this->source.getASTBuffer().getAttributeBlock(switch_stmt.attributeBlock);

		for(size_t i = 0; const AST::AttributeBlock::Attribute& attribute : attribute_block.attributes){
			EVO_DEFER([&](){ i += 1; });
			
			const std::string_view attribute_str = this->source.getTokenBuffer()[attribute.attribute].getString();

			if(attribute_str == "noJump"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #noJump does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_no_jump.set(attribute.attribute).isError()){ return evo::resultError; }

				if(attr_partial.is_set()){
					this->emit_error(
						Diagnostic::Code::SEMA_THESE_ATTRIBUTES_CANNOT_BE_COMBINED,
						attribute.attribute,
						"A function cannot have both attribute #noJump and #partial"
					);
					return evo::resultError;
				}

			}else if(attribute_str == "partial"){
				if(attribute_params_info[i].empty() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_TOO_MANY_ATTRIBUTE_ARGS,
						attribute.args.front(),
						"Attribute #partial does not accept any arguments"
					);
					return evo::resultError;
				}

				if(attr_partial.set(attribute.attribute).isError()){ return evo::resultError; }

				if(attr_no_jump.is_set()){
					this->emit_error(
						Diagnostic::Code::SEMA_THESE_ATTRIBUTES_CANNOT_BE_COMBINED,
						attribute.attribute,
						"A function cannot have both attribute #partial and #noJump"
					);
					return evo::resultError;
				}

			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_UNKNOWN_ATTRIBUTE,
					attribute.attribute,
					std::format("Unknown interface attribute #{}", attribute_str)
				);
				return evo::resultError;
			}
		}

		return SwitchAttrs{
			.is_partial = attr_partial.is_set(),
		};
	}




	auto SemanticAnalyzer::propagate_finished_impl(
		evo::SmallVector<SymbolProc::ID>& waited_on_by_list,
		evo::SmallVector<SymbolProc::ID, 256>& symbol_procs_to_put_in_work_queue
	) -> void {
		for(const SymbolProc::ID& waited_on_id : waited_on_by_list){
			SymbolProc& waited_on = this->context.symbol_proc_manager.getSymbolProc(waited_on_id);
			const auto lock = std::scoped_lock(waited_on.waiting_for_lock);

			evo::debugAssert(waited_on.waiting_for.empty() == false, "Should never have empty list");

			for(size_t i = 0; i < waited_on.waiting_for.size() - 1; i+=1){
				if(waited_on.waiting_for[i] == this->symbol_proc_id){
					waited_on.waiting_for[i] = waited_on.waiting_for.back();
					break;
				}
			}

			waited_on.waiting_for.pop_back();

			if(waited_on.waiting_for.empty() && waited_on.isTemplateSubSymbol() == false){
				symbol_procs_to_put_in_work_queue.emplace_back(waited_on_id);
			}
		}

		waited_on_by_list.clear();
	}


	auto SemanticAnalyzer::propagate_finished_decl() -> void {
		auto symbol_procs_to_put_in_work_queue = evo::SmallVector<SymbolProc::ID, 256>();

		const auto lock = std::scoped_lock(this->symbol_proc.decl_waited_on_lock);

		this->symbol_proc.decl_done = true;
		this->propagate_finished_impl(this->symbol_proc.decl_waited_on_by, symbol_procs_to_put_in_work_queue);

		this->put_propogated_symbol_procs_into_work_queue(symbol_procs_to_put_in_work_queue);
	}


	auto SemanticAnalyzer::propagate_finished_def() -> void {
		auto symbol_procs_to_put_in_work_queue = evo::SmallVector<SymbolProc::ID, 256>();

		const auto lock = std::scoped_lock(this->symbol_proc.def_waited_on_lock);

		this->symbol_proc.def_done = true;
		this->propagate_finished_impl(this->symbol_proc.def_waited_on_by, symbol_procs_to_put_in_work_queue);

		this->put_propogated_symbol_procs_into_work_queue(symbol_procs_to_put_in_work_queue);
	}



	auto SemanticAnalyzer::propagate_finished_decl_def() -> void {
		auto symbol_procs_to_put_in_work_queue = evo::SmallVector<SymbolProc::ID, 256>();

		const auto lock = std::scoped_lock(this->symbol_proc.decl_waited_on_lock, this->symbol_proc.def_waited_on_lock);

		this->symbol_proc.decl_done = true;
		this->symbol_proc.def_done = true;

		this->propagate_finished_impl(this->symbol_proc.decl_waited_on_by, symbol_procs_to_put_in_work_queue);
		this->propagate_finished_impl(this->symbol_proc.def_waited_on_by, symbol_procs_to_put_in_work_queue);

		this->put_propogated_symbol_procs_into_work_queue(symbol_procs_to_put_in_work_queue);
	}


	auto SemanticAnalyzer::propagate_finished_pir_decl() -> void {
		auto symbol_procs_to_put_in_work_queue = evo::SmallVector<SymbolProc::ID, 256>();

		const auto lock = std::scoped_lock(this->symbol_proc.pir_decl_waited_on_lock);

		this->symbol_proc.pir_decl_done = true;
		this->propagate_finished_impl(this->symbol_proc.pir_decl_waited_on_by, symbol_procs_to_put_in_work_queue);

		this->put_propogated_symbol_procs_into_work_queue(symbol_procs_to_put_in_work_queue);
	}

	auto SemanticAnalyzer::propagate_finished_pir_def() -> void {
		auto symbol_procs_to_put_in_work_queue = evo::SmallVector<SymbolProc::ID, 256>();

		const auto lock = std::scoped_lock(this->symbol_proc.pir_def_waited_on_lock);

		this->symbol_proc.pir_def_done = true;
		this->propagate_finished_impl(this->symbol_proc.pir_def_waited_on_by, symbol_procs_to_put_in_work_queue);

		this->put_propogated_symbol_procs_into_work_queue(symbol_procs_to_put_in_work_queue);
	}


	auto SemanticAnalyzer::put_propogated_symbol_procs_into_work_queue(evo::ArrayProxy<SymbolProc::ID> symbol_procs)
	-> void {
		for(SymbolProc::ID symbol_proc_to_add_id : symbol_procs){
			SymbolProc& symbol_proc_to_add = this->context.symbol_proc_manager.getSymbolProc(symbol_proc_to_add_id);

			if(symbol_proc_to_add.hasErroredNoLock()){ continue; }

			if(symbol_proc_to_add.status != SymbolProc::Status::WORKING){ // prevent race condition of setting up waits
				if(symbol_proc_to_add.setStatusInQueueIfNotAlreadyDone()){
					this->context.add_task_to_work_manager(symbol_proc_to_add_id);
				}
			}
		}	
	}



	//////////////////////////////////////////////////////////////////////
	// exec value gets / returns


	auto SemanticAnalyzer::get_type(SymbolProc::TypeID symbol_proc_type_id) -> TypeInfo::VoidableID {
		evo::debugAssert(
			this->symbol_proc.type_ids[symbol_proc_type_id.get()].has_value(),
			"Symbol proc type wasn't set"
		);
		return *this->symbol_proc.type_ids[symbol_proc_type_id.get()];
	}

	auto SemanticAnalyzer::return_type(SymbolProc::TypeID symbol_proc_type_id, TypeInfo::VoidableID&& id) -> void {
		this->symbol_proc.type_ids[symbol_proc_type_id.get()] = std::move(id);
	}


	auto SemanticAnalyzer::get_term_info(SymbolProc::TermInfoID symbol_proc_term_info_id) -> TermInfo& {
		evo::debugAssert(
			this->symbol_proc.term_infos[symbol_proc_term_info_id.get()].has_value(),
			"Symbol proc term info wasn't set"
		);
		return *this->symbol_proc.term_infos[symbol_proc_term_info_id.get()];
	}

	auto SemanticAnalyzer::return_term_info(SymbolProc::TermInfoID symbol_proc_term_info_id, auto&&... args) -> void {
		this->symbol_proc.term_infos[symbol_proc_term_info_id.get()].emplace(std::forward<decltype(args)>(args)...);
	}



	auto SemanticAnalyzer::get_struct_instantiation(SymbolProc::StructInstantiationID instantiation_id)
	-> const SymbolProc::StructInstantiationInfo& {
		evo::debugAssert(
			this->symbol_proc.struct_instantiations[instantiation_id.get()].has_value(),
			"Symbol proc struct instantiation wasn't set"
		);
		return *this->symbol_proc.struct_instantiations[instantiation_id.get()];
	}

	auto SemanticAnalyzer::return_struct_instantiation(
		SymbolProc::StructInstantiationID instantiation_id,
		const BaseType::StructTemplate::Instantiation& instantiation,
		bool requires_pub
	) -> void {
		this->symbol_proc.struct_instantiations[instantiation_id.get()] =
			SymbolProc::StructInstantiationInfo(&instantiation, requires_pub);
	}

	auto SemanticAnalyzer::return_struct_instantiation(
		SymbolProc::StructInstantiationID instantiation_id, BaseType::StructTemplateDeducer::ID deducer_id
	) -> void {
		this->symbol_proc.struct_instantiations[instantiation_id.get()] =
			SymbolProc::StructInstantiationInfo(deducer_id, false);
	}



	//////////////////////////////////////////////////////////////////////
	// error handling / diagnostics


	auto SemanticAnalyzer::type_qualifiers_check(
		evo::ArrayProxy<TypeInfo::Qualifier> expected_qualifiers,
		evo::ArrayProxy<TypeInfo::Qualifier> got_qualifiers
	) -> evo::Result<bool> {
		if(expected_qualifiers.empty() && got_qualifiers.empty()){ return false; }

		bool is_implicit_conversion_to_optional = false;

		if(expected_qualifiers.size() != got_qualifiers.size()){
			if(
				expected_qualifiers.size() == got_qualifiers.size() + 1
				&& expected_qualifiers.back().isOptional
				&& expected_qualifiers.back().isPtr == false
			){
				is_implicit_conversion_to_optional = true;
			}else{
				return evo::resultError;
			}
		}
			

		for(size_t i = 0; i < got_qualifiers.size(); i+=1){
			const TypeInfo::Qualifier& expected_qualifier = expected_qualifiers[i];
			const TypeInfo::Qualifier& got_qualifier      = got_qualifiers[i];

			if(expected_qualifier.isPtr != got_qualifier.isPtr){
				return evo::resultError;
			}
			if(expected_qualifier.isMut && got_qualifier.isMut == false){
				return evo::resultError;
			}
			if(expected_qualifier.isUninit != got_qualifier.isUninit){
				return evo::resultError;
			}
			if(expected_qualifier.isOptional == false && got_qualifier.isOptional){
				return evo::resultError;
			}
		}

		if(is_implicit_conversion_to_optional){ return true; }
		return expected_qualifiers.back().isOptional && got_qualifiers.back().isOptional == false; // pointers
	}

	template<bool MAY_DO_IMPLICIT_CONVERSION, bool MAY_EMIT_ERROR>
	auto SemanticAnalyzer::type_check(
		TypeInfo::ID expected_type_id,
		TermInfo& got_expr,
		std::string_view expected_type_location_name,
		const auto& location,
		bool is_initialization,
		std::optional<unsigned> multi_type_index
	) -> TypeCheckInfo {
		if constexpr(MAY_EMIT_ERROR){
			evo::debugAssert(
				expected_type_location_name.empty() == false, "Error emitting `type_check` requires a message"
			);
			evo::debugAssert(
				std::isupper(int(expected_type_location_name[0])),
				"first character of expected_type_location_name should be upper-case"
			);
		}else{
			evo::debugAssert(
				expected_type_location_name.empty(), "Non-error emitting `type_check` should not have a message"
			);
		}


		const TypeManager& type_manager = this->context.getTypeManager();


		switch(got_expr.value_category){
			case TermInfo::ValueCategory::EPHEMERAL:
			case TermInfo::ValueCategory::CONCRETE_CONST:
			case TermInfo::ValueCategory::CONCRETE_MUT:
			case TermInfo::ValueCategory::FORWARDABLE: {
				const TypeInfo::ID decayed_expected_type_id =
					this->context.type_manager.decayType<false, false>(expected_type_id);

				TypeInfo::ID decayed_got_type_id = TypeInfo::ID::dummy();
				if(got_expr.isMultiValue()) [[unlikely]] {
					if(multi_type_index.has_value() == false){
						this->emit_error(
							Diagnostic::Code::SEMA_MULTI_RETURN_INTO_SINGLE_VALUE,
							location,
							std::format("{} cannot accept multiple values", expected_type_location_name)
						);
						return TypeCheckInfo::fail();
					}

					decayed_got_type_id = this->context.type_manager.decayType<false, false>(
						got_expr.type_id.as<evo::SmallVector<TypeInfo::ID>>()[*multi_type_index]
					);

				}else{
					decayed_got_type_id =
						this->context.type_manager.decayType<false, false>(got_expr.type_id.as<TypeInfo::ID>());
				}


				// if types are not exact, check if implicit conversion is valid
				bool is_implicit_conversion_to_optional = false;
				if(decayed_expected_type_id != decayed_got_type_id){
					const TypeInfo& expected_type = type_manager.getTypeInfo(decayed_expected_type_id);
					const TypeInfo& got_type      = type_manager.getTypeInfo(decayed_got_type_id);

					if(type_manager.isTypeDeducer(decayed_expected_type_id)){
						DeducerMatchOutput deducer_match_output =
							this->deducer_matches_and_extract(decayed_expected_type_id, decayed_got_type_id);

						switch(deducer_match_output.outcome()){
							case DeducerMatchOutput::Outcome::MATCH: {
								got_expr.type_id = deducer_match_output.resultantTypeID();
								return TypeCheckInfo::success(false, std::move(deducer_match_output.deducedTerms()));
							} break;

							case DeducerMatchOutput::Outcome::NO_MATCH: {
								if constexpr(MAY_EMIT_ERROR){
									auto infos = evo::SmallVector<Diagnostic::Info>();
									this->diagnostic_print_type_info(expected_type_id, infos, "Deducer type:       ");
									this->diagnostic_print_type_info(decayed_got_type_id, infos,"Type of expression: ");
									this->emit_error(
										Diagnostic::Code::SEMA_TYPE_MISMATCH,
										location,
										"Type deducer not able to deduce type",
										std::move(infos)
									);
								}
								return TypeCheckInfo::fail();
							} break;

							case DeducerMatchOutput::Outcome::RESULT: {
								return TypeCheckInfo::fail(deducer_match_output.result());
							} break;
						}
					}

					if(expected_type.baseTypeID() != got_type.baseTypeID()){
						if(got_type.baseTypeID().kind() == BaseType::Kind::STRUCT){
							const BaseType::Struct& got_struct =
								this->context.getTypeManager().getStruct(got_type.baseTypeID().structID());

							evo::debugAssert(
								got_struct.defCompleted.load(std::memory_order::relaxed),
								"expected struct def to be completed"
							);

							const auto as_find = got_struct.operatorAsOverloads.find(decayed_expected_type_id);
							if(as_find != got_struct.operatorAsOverloads.end()){
								const sema::Func::ID target_as_func_id = as_find->second;
								const sema::Func& target_as_func =
									this->context.getSemaBuffer().getFunc(target_as_func_id);

								const BaseType::Function& target_as_func_type =
									this->context.getTypeManager().getFunction(target_as_func.typeID);

								switch(target_as_func_type.params[0].kind){
									case BaseType::Function::Param::Kind::READ: {
										// no checking needed
									} break;

									case BaseType::Function::Param::Kind::MUT: {
										if(got_expr.is_mutable() == false){
											if constexpr(MAY_EMIT_ERROR){
												this->error_type_mismatch(
													expected_type_id,
													got_expr,
													expected_type_location_name,
													location,
													multi_type_index
												);
											}
											return TypeCheckInfo::fail();
										}
									} break;

									case BaseType::Function::Param::Kind::IN: {
										if(got_expr.is_ephemeral() == false){
											if constexpr(MAY_EMIT_ERROR){
												this->error_type_mismatch(
													expected_type_id,
													got_expr,
													expected_type_location_name,
													location,
													multi_type_index
												);
											}
											return TypeCheckInfo::fail();
										}
									} break;

									case BaseType::Function::Param::Kind::C: {
										evo::debugFatalBreak("Shouldn't have a [this] param of kind C");
									} break;
								}

								if(target_as_func.attributes.isImplicit == false){
									if constexpr(MAY_EMIT_ERROR){
										this->error_type_mismatch(
											expected_type_id,
											got_expr,
											expected_type_location_name,
											location,
											multi_type_index
										);
									}
									return TypeCheckInfo::fail();
								}

								if constexpr(MAY_DO_IMPLICIT_CONVERSION){
									if(is_initialization == false){
										switch(got_expr.getExpr().kind()){
											case sema::Expr::Kind::COPY: {
												sema::Copy& copy_expr =
													this->context.sema_buffer.copies[got_expr.getExpr().copyID()];
												copy_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::MOVE: {
												sema::Move& move_expr =
													this->context.sema_buffer.moves[got_expr.getExpr().moveID()];
												move_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::FORWARD: {
												sema::Forward& forward_expr =
													this->context.sema_buffer.forwards[got_expr.getExpr().forwardID()];
												forward_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::DEFAULT_NEW: {
												sema::DefaultNew& default_new_expr = 
													this->context.sema_buffer.default_news[
														got_expr.getExpr().defaultNewID()
													];
												default_new_expr.isInitialization = true;
											} break;
										}
									}


									got_expr.type_id.emplace<TypeInfo::ID>(expected_type_id);
									got_expr.getExpr() = sema::Expr(
										this->context.sema_buffer.createFuncCall(
											target_as_func_id, evo::SmallVector<sema::Expr>{got_expr.getExpr()}
										)
									);

									if(this->get_current_func().attributes.isComptime){
										this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(
											target_as_func_id
										);
									}
								}

								return TypeCheckInfo::success(true);
							}
						}

						if(expected_type.baseTypeID().kind() == BaseType::Kind::STRUCT){
							const BaseType::Struct& expected_struct =
								this->context.getTypeManager().getStruct(expected_type.baseTypeID().structID());

							evo::debugAssert(
								expected_struct.defCompleted.load(std::memory_order::relaxed),
								"expected struct def to be completed"
							);

							

							if(is_initialization){
								for(const sema::FuncID new_func_id : expected_struct.newInitOverloads){
									const sema::Func& new_func = this->context.getSemaBuffer().getFunc(new_func_id);

									if(new_func.attributes.isImplicit == false){ continue; }

									const BaseType::Function& new_func_type =
										this->context.getTypeManager().getFunction(new_func.typeID);

									if(this->currently_in_unsafe() == false && new_func_type.isUnsafe){ continue; }

									const TypeInfo::ID decayed_param_type_id = 
										this->context.type_manager.decayType<false, false>(
											new_func_type.params[0].typeID
										);

									if(decayed_param_type_id != decayed_got_type_id){ continue; }

									switch(new_func_type.params[0].kind){
										case BaseType::Function::Param::Kind::READ: {
											// do nothing
										} break;

										case BaseType::Function::Param::Kind::MUT: {
											if(got_expr.is_concrete() == false || got_expr.is_mutable() == false){
												continue;
											}
										} break;

										case BaseType::Function::Param::Kind::IN: {
											if(got_expr.is_ephemeral() == false){ continue; }
										} break;

										case BaseType::Function::Param::Kind::C: {
											evo::debugFatalBreak("Unsupported");
										} break;
									}

									if constexpr(MAY_DO_IMPLICIT_CONVERSION){
										got_expr.type_id.emplace<TypeInfo::ID>(expected_type_id);
										got_expr.getExpr() = sema::Expr(
											this->context.sema_buffer.createFuncCall(
												new_func_id, evo::SmallVector<sema::Expr>{got_expr.getExpr()}
											)
										);

										if(this->get_current_func().attributes.isComptime){
											this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>()
												.dependent_funcs.emplace(new_func_id);
										}
									}

									return TypeCheckInfo::success(true);
								}

							}else{ // assignment
								for(const sema::FuncID new_func_id : expected_struct.newAssignOverloads){
									const sema::Func& new_func = this->context.getSemaBuffer().getFunc(new_func_id);

									if(new_func.attributes.isImplicit == false){ continue; }

									const BaseType::Function& new_func_type =
										this->context.getTypeManager().getFunction(new_func.typeID);

									if(this->currently_in_unsafe() == false && new_func_type.isUnsafe){ continue; }

									const TypeInfo::ID decayed_param_type_id = 
										this->context.type_manager.decayType<false, false>(
											new_func_type.params[1].typeID
										);

									if(decayed_param_type_id != decayed_got_type_id){ continue; }

									switch(new_func_type.params[1].kind){
										case BaseType::Function::Param::Kind::READ: {
											// do nothing
										} break;

										case BaseType::Function::Param::Kind::MUT: {
											if(got_expr.is_concrete() == false || got_expr.is_mutable() == false){
												continue;
											}
										} break;

										case BaseType::Function::Param::Kind::IN: {
											if(got_expr.is_ephemeral() == false){ continue; }
										} break;

										case BaseType::Function::Param::Kind::C: {
											evo::debugFatalBreak("Unsupported");
										} break;
									}

									if constexpr(MAY_DO_IMPLICIT_CONVERSION){
										switch(got_expr.getExpr().kind()){
											case sema::Expr::Kind::COPY: {
												sema::Copy& copy_expr =
													this->context.sema_buffer.copies[got_expr.getExpr().copyID()];
												copy_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::MOVE: {
												sema::Move& move_expr =
													this->context.sema_buffer.moves[got_expr.getExpr().moveID()];
												move_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::FORWARD: {
												sema::Forward& forward_expr =
													this->context.sema_buffer.forwards[got_expr.getExpr().forwardID()];
												forward_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::DEFAULT_NEW: {
												sema::DefaultNew& default_new_expr = 
													this->context.sema_buffer.default_news[
														got_expr.getExpr().defaultNewID()
													];
												default_new_expr.isInitialization = true;
											} break;
										}
									}

									return TypeCheckInfo::success(TypeCheckInfo::AssignFunc(new_func_id));
								}


								for(const sema::FuncID new_func_id : expected_struct.newInitOverloads){
									const sema::Func& new_func = this->context.getSemaBuffer().getFunc(new_func_id);

									if(new_func.attributes.isImplicit == false){ continue; }

									const BaseType::Function& new_func_type =
										this->context.getTypeManager().getFunction(new_func.typeID);

									if(this->currently_in_unsafe() == false && new_func_type.isUnsafe){ continue; }

									const TypeInfo::ID decayed_param_type_id = 
										this->context.type_manager.decayType<false, false>(
											new_func_type.params[0].typeID
										);

									if(decayed_param_type_id != decayed_got_type_id){ continue; }

									switch(new_func_type.params[0].kind){
										case BaseType::Function::Param::Kind::READ: {
											// do nothing
										} break;

										case BaseType::Function::Param::Kind::MUT: {
											if(got_expr.is_concrete() == false || got_expr.is_mutable() == false){
												continue;
											}
										} break;

										case BaseType::Function::Param::Kind::IN: {
											if(got_expr.is_ephemeral() == false){ continue; }
										} break;

										case BaseType::Function::Param::Kind::C: {
											evo::debugFatalBreak("Unsupported");
										} break;
									}

									if constexpr(MAY_DO_IMPLICIT_CONVERSION){
										switch(got_expr.getExpr().kind()){
											case sema::Expr::Kind::COPY: {
												sema::Copy& copy_expr =
													this->context.sema_buffer.copies[got_expr.getExpr().copyID()];
												copy_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::MOVE: {
												sema::Move& move_expr =
													this->context.sema_buffer.moves[got_expr.getExpr().moveID()];
												move_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::FORWARD: {
												sema::Forward& forward_expr = this->context.sema_buffer.forwards[
													got_expr.getExpr().forwardID()
												];
												forward_expr.isInitialization = true;
											} break;

											case sema::Expr::Kind::DEFAULT_NEW: {
												sema::DefaultNew& default_new_expr = 
													this->context.sema_buffer.default_news[
														got_expr.getExpr().defaultNewID()
													];
												default_new_expr.isInitialization = true;
											} break;
										}
									}

									return TypeCheckInfo::success(TypeCheckInfo::InitAssignFunc(new_func_id));
								}
							}
						}

						if(
							expected_type.baseTypeID().kind() == BaseType::Kind::ARRAY_REF
							&& got_type.baseTypeID().kind() == BaseType::Kind::ARRAY
						){
							if(expected_type.qualifiers().empty() == false || got_type.qualifiers().size() > 1){
								if constexpr(MAY_EMIT_ERROR){
									this->error_type_mismatch(
										expected_type_id,
										got_expr,
										expected_type_location_name,
										location,
										multi_type_index
									);
								}
								return TypeCheckInfo::fail();
							}

							bool got_is_ptr = false;
							if(got_type.qualifiers().size() == 1){
								if(got_type.qualifiers()[0].isUninit | got_type.qualifiers()[0].isOptional){
									if constexpr(MAY_EMIT_ERROR){
										this->error_type_mismatch(
											expected_type_id,
											got_expr,
											expected_type_location_name,
											location,
											multi_type_index
										);
									}
									return TypeCheckInfo::fail();
								}

								got_is_ptr = true;
							}

							const BaseType::ArrayRef& expected_array_ref =
								this->context.getTypeManager().getArrayRef(expected_type.baseTypeID().arrayRefID());

							const BaseType::Array& got_array =
								this->context.getTypeManager().getArray(got_type.baseTypeID().arrayID());

							if(
								this->context.type_manager.decayType<false, false>(expected_array_ref.elementTypeID)
								!= this->context.type_manager.decayType<false, false>(got_array.elementTypeID)
							){
								if constexpr(MAY_EMIT_ERROR){
									this->error_type_mismatch(
										expected_type_id,
										got_expr,
										expected_type_location_name,
										location,
										multi_type_index
									);
								}
								return TypeCheckInfo::fail();
							}

							if(expected_array_ref.dimensions.size() != got_array.dimensions.size()){
								if constexpr(MAY_EMIT_ERROR){
									this->error_type_mismatch(
										expected_type_id,
										got_expr,
										expected_type_location_name,
										location,
										multi_type_index
									);
								}
								return TypeCheckInfo::fail();
							}

							if(
								expected_array_ref.terminator.has_value()
								&& expected_array_ref.terminator != got_array.terminator
							){
								if constexpr(MAY_EMIT_ERROR){
									this->error_type_mismatch(
										expected_type_id,
										got_expr,
										expected_type_location_name,
										location,
										multi_type_index
									);
								}
								return TypeCheckInfo::fail();
							}

							if(expected_array_ref.isMut){
								if(got_is_ptr){
									if(got_type.qualifiers()[0].isMut == false){
										if constexpr(MAY_EMIT_ERROR){
											this->error_type_mismatch(
												expected_type_id,
												got_expr,
												expected_type_location_name,
												location,
												multi_type_index
											);
										}
										return TypeCheckInfo::fail();
									}

								}else{
									if(got_expr.is_const()){
										if constexpr(MAY_EMIT_ERROR){
											this->error_type_mismatch(
												expected_type_id,
												got_expr,
												expected_type_location_name,
												location,
												multi_type_index
											);
										}
										return TypeCheckInfo::fail();
									}
								}
							}


							auto dimensions = evo::SmallVector<evo::Variant<uint64_t, sema::Expr>>();
							dimensions.reserve(got_array.dimensions.size());
							for(size_t i = 0; uint64_t dimension : got_array.dimensions){
								if(expected_array_ref.dimensions[i].isPtr()){
									dimensions.emplace_back(dimension);
								}else{
									if(dimension != expected_array_ref.dimensions[i].length()){
										if constexpr(MAY_EMIT_ERROR){
											this->error_type_mismatch(
												expected_type_id,
												got_expr,
												expected_type_location_name,
												location,
												multi_type_index
											);
										}
										return TypeCheckInfo::fail();
									}
								}

								i += 1;
							}


							if constexpr(MAY_DO_IMPLICIT_CONVERSION){
								const sema::Expr data_ptr = [&]() -> sema::Expr {
									if(got_is_ptr){
										return got_expr.getExpr();
									}else{
										return sema::Expr(this->context.sema_buffer.createAddrOf(got_expr.getExpr()));
									}
								}();

								got_expr.type_id.emplace<TypeInfo::ID>(expected_type_id);
								got_expr.getExpr() = sema::Expr(
									this->context.sema_buffer.createInitArrayRef(data_ptr, std::move(dimensions))
								);
							}

							return TypeCheckInfo::success(true);
						}


						if(
							expected_type.baseTypeID().kind() != BaseType::Kind::ARRAY_REF
							|| got_type.baseTypeID().kind() != BaseType::Kind::ARRAY_REF
						){
							if constexpr(MAY_EMIT_ERROR){
								this->error_type_mismatch(
									expected_type_id, got_expr, expected_type_location_name, location, multi_type_index
								);
							}
							return TypeCheckInfo::fail();
						}

						const BaseType::ArrayRef& expected_array_ref =
							type_manager.getArrayRef(expected_type.baseTypeID().arrayRefID());

						const BaseType::ArrayRef& got_array_ref =
							type_manager.getArrayRef(got_type.baseTypeID().arrayRefID());


						if(expected_array_ref.isMut && got_array_ref.isMut == false){
							if constexpr(MAY_EMIT_ERROR){
								this->error_type_mismatch(
									expected_type_id, got_expr, expected_type_location_name, location, multi_type_index
								);
							}
							return TypeCheckInfo::fail();
						}
					}


					const evo::Result<bool> qualifiers_check_result = 
						this->type_qualifiers_check(expected_type.qualifiers(), got_type.qualifiers());

					if(qualifiers_check_result.isError()){
						if constexpr(MAY_EMIT_ERROR){
							this->error_type_mismatch(
								expected_type_id, got_expr, expected_type_location_name, location, multi_type_index
							);
						}
						return TypeCheckInfo::fail();
					}

					is_implicit_conversion_to_optional = qualifiers_check_result.value();

					if(is_implicit_conversion_to_optional){
						if(got_expr.is_ephemeral() == false){
							if constexpr(MAY_EMIT_ERROR){
								this->emit_error(
									Diagnostic::Code::SEMA_IMPLICIT_CONVERT_TO_OPTIONAL_NOT_EPHEMERAL,
									location,
									"A value can only be implicitly converted if the value is ephemeral"
								);
							}
							return TypeCheckInfo::fail();
						}

						if(got_type.isUninitPointer() && this->currently_in_unsafe() == false){
							this->emit_error(
								Diagnostic::Code::SEMA_UNSAFE_IN_SAFE_SCOPE,
								location,
								"Unsafe implicit conversion to optional uninitialized qualified pointer while not in "
									"an unsafe scope"
							);
							return TypeCheckInfo::fail();
						}
					}
				}

				if constexpr(MAY_DO_IMPLICIT_CONVERSION){
					EVO_DEFER([&](){
						if(multi_type_index.has_value() == false){
							got_expr.type_id.emplace<TypeInfo::ID>(expected_type_id);	
						}else{
							got_expr.type_id.as<evo::SmallVector<TypeInfo::ID>>()[*multi_type_index] = expected_type_id;
						}
					});

					if(is_implicit_conversion_to_optional){
						got_expr.getExpr() = sema::Expr(
							this->context.sema_buffer.createConversionToOptional(got_expr.getExpr(), expected_type_id)
						);
					}
				}

				if(multi_type_index.has_value() == false){
					return TypeCheckInfo::success(got_expr.type_id.as<TypeInfo::ID>() != expected_type_id);
				}else{
					return TypeCheckInfo::success(
						got_expr.type_id.as<evo::SmallVector<TypeInfo::ID>>()[*multi_type_index] != expected_type_id
					);
				}
			} break;

			case TermInfo::ValueCategory::EPHEMERAL_FLUID: {
				const TypeInfo::ID decayed_expected_type_id =
					this->context.type_manager.decayType<true, true>(expected_type_id);

				const TypeInfo& expected_type_info = 
					type_manager.getTypeInfo(decayed_expected_type_id);


				if(expected_type_info.baseTypeID().kind() != BaseType::Kind::PRIMITIVE){
					if constexpr(MAY_EMIT_ERROR){
						if(expected_type_info.baseTypeID().kind() == BaseType::Kind::TYPE_DEDUCER){
							// TODO(FUTURE): better messaging
							this->emit_error(
								Diagnostic::Code::SEMA_CANNOT_INFER_TYPE,
								location,
								"Cannot deduce the type of a fluid value"
							);

						}else{
							this->error_type_mismatch(
								expected_type_id, got_expr, expected_type_location_name, location, multi_type_index
							);
						}
					}
					return TypeCheckInfo::fail();
				}


				bool is_implicit_conversion_to_optional = false;
				if(expected_type_info.qualifiers().empty() == false){
					if(
						expected_type_info.qualifiers().back().isOptional
						&& expected_type_info.qualifiers().back().isPtr == false
					){ // is optional not pointer
						is_implicit_conversion_to_optional = true;
					}else{
						if constexpr(MAY_EMIT_ERROR){
							this->error_type_mismatch(
								expected_type_id, got_expr, expected_type_location_name, location, multi_type_index
							);
						}
						return TypeCheckInfo::fail();
					}
				}

				const BaseType::Primitive::ID expected_type_primitive_id =
					expected_type_info.baseTypeID().primitiveID();

				const BaseType::Primitive& expected_type_primitive = 
					type_manager.getPrimitive(expected_type_primitive_id);

				if(got_expr.getExpr().kind() == sema::Expr::Kind::INT_VALUE){
					bool is_unsigned = true;

					switch(expected_type_primitive.kind()){
						case Token::Kind::TYPE_INT:
						case Token::Kind::TYPE_ISIZE:
						case Token::Kind::TYPE_I_N:
						case Token::Kind::TYPE_C_SHORT:
						case Token::Kind::TYPE_C_INT:
						case Token::Kind::TYPE_C_LONG:
						case Token::Kind::TYPE_C_LONG_LONG:
							is_unsigned = false;
							break;

						case Token::Kind::TYPE_UINT:
						case Token::Kind::TYPE_USIZE:
						case Token::Kind::TYPE_UI_N:
						case Token::Kind::TYPE_BYTE:
						case Token::Kind::TYPE_C_WCHAR:
						case Token::Kind::TYPE_C_USHORT:
						case Token::Kind::TYPE_C_UINT:
						case Token::Kind::TYPE_C_ULONG:
						case Token::Kind::TYPE_C_ULONG_LONG:
							break;

						default: {
							if constexpr(MAY_EMIT_ERROR){
								this->error_type_mismatch(
									expected_type_id, got_expr, expected_type_location_name, location, multi_type_index
								);
							}
							return TypeCheckInfo::fail();
						}
					}

					if constexpr(MAY_DO_IMPLICIT_CONVERSION){
						const sema::IntValue::ID int_value_id = got_expr.getExpr().intValueID();
						sema::IntValue& int_value = this->context.sema_buffer.int_values[int_value_id];

						const unsigned bit_width =
							unsigned(this->context.getTypeManager().numBits(expected_type_info.baseTypeID(), false));

						core::GenericInt target_min =
							type_manager.getMin(expected_type_info.baseTypeID()).getInt(bit_width);

						core::GenericInt target_max =
							type_manager.getMax(expected_type_info.baseTypeID()).getInt(bit_width);

						if(int_value.value.getBitWidth() >= target_min.getBitWidth()){
							target_min = target_min.ext(int_value.value.getBitWidth(), is_unsigned);
							target_max = target_max.ext(int_value.value.getBitWidth(), is_unsigned);

							if(is_unsigned){
								if(int_value.value.ult(target_min) || int_value.value.ugt(target_max)){
									if constexpr(MAY_EMIT_ERROR){
										auto infos = evo::SmallVector<Diagnostic::Info>();
										this->diagnostic_print_type_info(expected_type_id, infos, "Target type: ");

										if(int_value.value.slt(target_min)){ // check for negatives
											this->emit_error(
												Diagnostic::Code::SEMA_CANNOT_CONVERT_FLUID_VALUE,
												location,
												"Cannot implicitly convert this fluid value to the target type "
													"as fluid value is negative and the target type is unsigned",
												std::move(infos)
											);
										}else{
											this->emit_error(
												Diagnostic::Code::SEMA_CANNOT_CONVERT_FLUID_VALUE,
												location,
												"Cannot implicitly convert this fluid value to the target type "
													"as it would require truncation",
												std::move(infos)
											);
										}
									}
									return TypeCheckInfo::fail();
								}
							}else{
								if(int_value.value.slt(target_min) || int_value.value.sgt(target_max)){
									if constexpr(MAY_EMIT_ERROR){
										auto infos = evo::SmallVector<Diagnostic::Info>();
										this->diagnostic_print_type_info(expected_type_id, infos, "Target type: ");
										this->emit_error(
											Diagnostic::Code::SEMA_CANNOT_CONVERT_FLUID_VALUE,
											location,
											"Cannot implicitly convert this fluid value to the target type "
												"as it would require truncation",
											std::move(infos)
										);
									}
									return TypeCheckInfo::fail();
								}
							}

							int_value.value = int_value.value.trunc(bit_width);

						}else{
							int_value.value = int_value.value.ext(target_min.getBitWidth(), is_unsigned);

						}


						int_value.typeID = type_manager.getTypeInfo(expected_type_id).baseTypeID();
					}

				}else{
					evo::debugAssert(
						got_expr.getExpr().kind() == sema::Expr::Kind::FLOAT_VALUE, "Expected float"
					);

					switch(expected_type_primitive.kind()){
						case Token::Kind::TYPE_F16:
						case Token::Kind::TYPE_BF16:
						case Token::Kind::TYPE_F32:
						case Token::Kind::TYPE_F64:
						case Token::Kind::TYPE_F80:
						case Token::Kind::TYPE_F128:
						case Token::Kind::TYPE_C_LONG_DOUBLE:
							break;

						default: {
							if constexpr(MAY_EMIT_ERROR){
								this->error_type_mismatch(
									expected_type_id, got_expr, expected_type_location_name, location, multi_type_index
								);
							}
							return TypeCheckInfo::fail();
						}
					}

					if constexpr(MAY_DO_IMPLICIT_CONVERSION){
						const sema::FloatValue::ID float_value_id = got_expr.getExpr().floatValueID();
						sema::FloatValue& float_value = this->context.sema_buffer.float_values[float_value_id];


						const core::GenericFloat target_min = [&](){
							switch(expected_type_primitive.kind()){
								break; case Token::Kind::TYPE_F16:
									return type_manager.getMin(expected_type_info.baseTypeID()).getF16();
								break; case Token::Kind::TYPE_BF16:
									return type_manager.getMin(expected_type_info.baseTypeID()).getBF16();
								break; case Token::Kind::TYPE_F32:
									return type_manager.getMin(expected_type_info.baseTypeID()).getF32();
								break; case Token::Kind::TYPE_F64:
									return type_manager.getMin(expected_type_info.baseTypeID()).getF64();
								break; case Token::Kind::TYPE_F80:
									return type_manager.getMin(expected_type_info.baseTypeID()).getF80();
								break; case Token::Kind::TYPE_F128:
									return type_manager.getMin(expected_type_info.baseTypeID()).getF128();

								break; case Token::Kind::TYPE_C_LONG_DOUBLE: {
									if(type_manager.numBytes(expected_type_info.baseTypeID()) == 8){
										return type_manager.getMin(expected_type_info.baseTypeID()).getF64();
									}else{
										return type_manager.getMin(expected_type_info.baseTypeID()).getF128();
									}
								}
								break; default: evo::debugFatalBreak("Unknown float type");
							}
						}().asF128();


						const core::GenericFloat target_max = [&](){
							switch(expected_type_primitive.kind()){
								break; case Token::Kind::TYPE_F16:
									return type_manager.getMax(expected_type_info.baseTypeID()).getF16();
								break; case Token::Kind::TYPE_BF16:
									return type_manager.getMax(expected_type_info.baseTypeID()).getBF16();
								break; case Token::Kind::TYPE_F32:
									return type_manager.getMax(expected_type_info.baseTypeID()).getF32();
								break; case Token::Kind::TYPE_F64:
									return type_manager.getMax(expected_type_info.baseTypeID()).getF64();
								break; case Token::Kind::TYPE_F80:
									return type_manager.getMax(expected_type_info.baseTypeID()).getF80();
								break; case Token::Kind::TYPE_F128:
									return type_manager.getMax(expected_type_info.baseTypeID()).getF128();

								break; case Token::Kind::TYPE_C_LONG_DOUBLE: {
									if(type_manager.numBytes(expected_type_info.baseTypeID()) == 8){
										return type_manager.getMax(expected_type_info.baseTypeID()).getF64();
									}else{
										return type_manager.getMax(expected_type_info.baseTypeID()).getF128();
									}
								}
								break; default: evo::debugFatalBreak("Unknown float type");
							}
						}().asF128();


						const core::GenericFloat converted_literal = float_value.value.asF128();

						if(converted_literal.lt(target_min) || converted_literal.gt(target_max)){
							if constexpr(MAY_EMIT_ERROR){
								auto infos = evo::SmallVector<Diagnostic::Info>();
								this->diagnostic_print_type_info(expected_type_id, infos, "Target type: ");
								this->emit_error(
									Diagnostic::Code::SEMA_CANNOT_CONVERT_FLUID_VALUE,
									location,
									"Cannot implicitly convert this fluid value to the target type "
										"as it would require truncation",
									std::move(infos)
								);
							}
							return TypeCheckInfo::fail();
						}


						switch(expected_type_primitive.kind()){
							break; case Token::Kind::TYPE_F16:  float_value.value = float_value.value.asF16();
							break; case Token::Kind::TYPE_BF16: float_value.value = float_value.value.asBF16();
							break; case Token::Kind::TYPE_F32:  float_value.value = float_value.value.asF32();
							break; case Token::Kind::TYPE_F64:  float_value.value = float_value.value.asF64();
							break; case Token::Kind::TYPE_F80:  float_value.value = float_value.value.asF80();
							break; case Token::Kind::TYPE_F128: float_value.value = float_value.value.asF128();
							break; case Token::Kind::TYPE_C_LONG_DOUBLE: {
								if(type_manager.numBytes(expected_type_info.baseTypeID()) == 8){
									float_value.value = float_value.value.asF64();
								}else{
									float_value.value = float_value.value.asF128();
								}
							}
						}

						float_value.typeID = type_manager.getTypeInfo(expected_type_id).baseTypeID();
					}
				}

				if constexpr(MAY_DO_IMPLICIT_CONVERSION){
					got_expr.value_category = TermInfo::ValueCategory::EPHEMERAL;
					got_expr.type_id.emplace<TypeInfo::ID>(expected_type_id);

					if(is_implicit_conversion_to_optional){
						got_expr.getExpr() = sema::Expr(
							this->context.sema_buffer.createConversionToOptional(got_expr.getExpr(), expected_type_id)
						);
					}
				}

				return TypeCheckInfo::success(true);
			} break;


			case TermInfo::ValueCategory::NULL_VALUE: {
				const TypeInfo::ID decayed_expected_type_id =
					this->context.type_manager.decayType<true, true>(expected_type_id);
				const TypeInfo& expected_type = type_manager.getTypeInfo(decayed_expected_type_id);
				
				if(expected_type.isOptional() == false){
					this->emit_error(
						Diagnostic::Code::SEMA_ASSIGNED_NULL_TO_NON_OPTIONAL,
						location,
						"Value [null] can only be assigned to optional types"
					);
					return TypeCheckInfo::fail();
				}

				if(type_manager.isTypeDeducer(decayed_expected_type_id)){
					this->emit_error(
						Diagnostic::Code::SEMA_CANNOT_EXTRACT_DEDUCERS_FROM_NULL,
						location,
						"Cannot extract deducers from [null]"
					);
					return TypeCheckInfo::fail();
				}

				return TypeCheckInfo::success(true);
			} break;

			case TermInfo::ValueCategory::EXPR_DEDUCER:
				evo::debugFatalBreak("EXPR_DEDUCER should not be compared with this function");

			case TermInfo::ValueCategory::INITIALIZER:
				evo::debugFatalBreak("INITIALIZER should not be compared with this function");

			case TermInfo::ValueCategory::MODULE:
				evo::debugFatalBreak("MODULE should not be compared with this function");

			case TermInfo::ValueCategory::FUNCTION:
				evo::debugFatalBreak("FUNCTION should not be compared with this function");

			case TermInfo::ValueCategory::FUNCTION_PUB_REQUIRED:
				evo::debugFatalBreak("FUNCTION_PUB_REQUIRED should not be compared with this function");

			case TermInfo::ValueCategory::FUNCTION_NOT_PRIV_REQUIRED:
				evo::debugFatalBreak("FUNCTION_NOT_PRIV_REQUIRED should not be compared with this function");

			case TermInfo::ValueCategory::INTRINSIC_FUNC:
				evo::debugFatalBreak("INTRINSIC_FUNC should not be compared with this function");

			case TermInfo::ValueCategory::TEMPLATE_INTRINSIC_FUNC:
				evo::debugFatalBreak("TEMPLATE_INTRINSIC_FUNC should not be compared with this function");

			case TermInfo::ValueCategory::TEMPLATE_TYPE:
				evo::debugFatalBreak("TEMPLATE_TYPE should not be compared with this function");

			case TermInfo::ValueCategory::TEMPLATE_TYPE_PUB_REQUIRED:
				evo::debugFatalBreak("TEMPLATE_TYPE_PUB_REQUIRED should not be compared with this function");

			case TermInfo::ValueCategory::TAGGED_UNION_FIELD_ACCESSOR:
				evo::debugFatalBreak("TAGGED_UNION_FIELD_ACCESSOR should not be compared with this function");
		}

		evo::debugFatalBreak("Unknown or unsupported value category");
	}



	auto SemanticAnalyzer::handle_non_auto_implicit_conversion(
		TypeCheckInfo::NonAutoImplicitConversionTarget& non_auto_implicit_conversion_target,
		const TermInfo& lhs,
		sema::Expr value,
		const AST::Infix& infix
	) -> Result {
		EVO_DEFER([&](){ non_auto_implicit_conversion_target = std::monostate(); });

		return non_auto_implicit_conversion_target.visit([&](const auto& conversion_target) -> Result {
			using TargetT = std::decay_t<decltype(conversion_target)>;

			if constexpr(std::is_same<TargetT, std::monostate>()){
				evo::debugFatalBreak("Not a non-auto implicit conversion");

			}else if constexpr(std::is_same<TargetT, TypeCheckInfo::InitAssignFunc>()){
				if(this->get_special_member_call_dependents<SpecialMemberKind::DELETE, true>(
					lhs, this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs, infix
				).isError()){
					return Result::ERROR;
				}

				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createDelete(lhs.getExpr(), lhs.type_id.as<TypeInfo::ID>())
				);

				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createAssign(
						lhs.getExpr(),
						sema::Expr(
							this->context.sema_buffer.createFuncCall(
								conversion_target.func_id, evo::SmallVector<sema::Expr>{value}
							)
						)
					)
				);

				if(this->get_current_func().attributes.isComptime){
					this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(
						conversion_target.func_id
					);
				}

				return Result::SUCCESS;
				
			}else if constexpr(std::is_same<TargetT, TypeCheckInfo::AssignFunc>()){
				this->get_current_scope_level().stmtBlock().emplace_back(
					this->context.sema_buffer.createFuncCall(
						conversion_target.func_id,
						evo::SmallVector<sema::Expr>{lhs.getExpr(), value}
					)
				);

				if(this->get_current_func().attributes.isComptime){
					this->symbol_proc.extra_info.as<SymbolProc::FuncInfo>().dependent_funcs.emplace(
						conversion_target.func_id
					);
				}

				return Result::SUCCESS;

			}else{
				static_assert(false, "Unknown conversion target");
			}
		});
	}





	auto SemanticAnalyzer::error_type_mismatch(
		TypeInfo::ID expected_type_id,
		const TermInfo& got_expr,
		std::string_view expected_type_location_name,
		const auto& location,
		std::optional<unsigned> multi_type_index
	) -> void {
		evo::debugAssert(
			std::isupper(int(expected_type_location_name[0])), "first character of name should be upper-case"
		);

		constexpr static bool LOCATION_IS_MULTI_ASSIGN = 
			std::is_same<std::decay_t<decltype(location)>, AST::MultiAssign>();


		auto infos = evo::SmallVector<Diagnostic::Info>();

		if constexpr(LOCATION_IS_MULTI_ASSIGN){
			infos.emplace_back(
				std::format("Multi-assign index: {}", *multi_type_index),
				this->get_location(location.assigns[*multi_type_index])
			);
		}


		this->diagnostic_print_type_info(expected_type_id, infos, "Expected type:      ");

		this->diagnostic_print_type_info(got_expr, multi_type_index, infos, "Expression is type: ");


		const auto& actual_location = [&](){
			if constexpr(LOCATION_IS_MULTI_ASSIGN){
				return location.value;
			}else{
				return location;
			}
		}();


		this->emit_error(
			Diagnostic::Code::SEMA_TYPE_MISMATCH,
			actual_location,
			std::format(
				"{} cannot accept an expression of a different type, "
					"and this expression cannot be implicitly converted to the correct type",
				expected_type_location_name
			),
			std::move(infos)
		);
	}



	auto SemanticAnalyzer::diagnostic_print_type_info(
		TypeInfo::VoidableID type_id, evo::SmallVector<Diagnostic::Info>& infos, std::string_view message
	) const -> void {
		if(type_id.isVoid()){
			infos.emplace_back(std::format("{}Void", message));

		}else{
			auto initial_type_str = std::string();
			initial_type_str += message;
			initial_type_str +=
				this->context.getTypeManager().printType(type_id.asTypeID(), this->context);
			infos.emplace_back(std::move(initial_type_str));

			this->diagnostic_print_type_info_impl(type_id.asTypeID(), infos, message);
		}
	}


	auto SemanticAnalyzer::diagnostic_print_type_info(
		const TermInfo& term_info,
		std::optional<unsigned> multi_type_index,
		evo::SmallVector<Diagnostic::Info>& infos,
		std::string_view message
	) const -> void {
		auto initial_type_str = std::string();
		initial_type_str += message;
		initial_type_str += this->print_term_type(term_info, multi_type_index);
		infos.emplace_back(std::move(initial_type_str));

		if(
			term_info.type_id.is<TypeInfo::ID>()
			|| (term_info.type_id.is<evo::SmallVector<TypeInfo::ID>>() && multi_type_index.has_value())
		){
			const TypeInfo::ID actual_got_type_id = [&](){
				if(term_info.type_id.is<TypeInfo::ID>()){
					return term_info.type_id.as<TypeInfo::ID>();
				}else{
					return term_info.type_id.as<evo::SmallVector<TypeInfo::ID>>()[*multi_type_index];
				}
			}();

			this->diagnostic_print_type_info_impl(actual_got_type_id, infos, message);
		}
	}



	auto SemanticAnalyzer::diagnostic_print_type_info_impl(
		TypeInfo::ID type_id, evo::SmallVector<Diagnostic::Info>& infos, std::string_view message
	) const -> void {
		evo::debugAssert(
			message.size() >= evo::stringSize(" > Alias of: "),
			"Message must be at least {} characters",
			evo::stringSize(" > Alias of: ")
		);


		while(true){
			const TypeInfo& expected_type = this->context.getTypeManager().getTypeInfo(type_id);
			if(expected_type.qualifiers().empty() == false){ break; }
			if(expected_type.baseTypeID().kind() != BaseType::Kind::ALIAS){ break; }

			const BaseType::Alias& expected_alias = this->context.getTypeManager().getAlias(
				expected_type.baseTypeID().aliasID()
			);

			type_id = expected_alias.aliasedType;

			auto alias_of_str = std::string();
			alias_of_str.reserve(message.size());
			alias_of_str += " > Alias of: ";
			while(alias_of_str.size() < message.size()){
				alias_of_str += ' ';
			}

			alias_of_str += this->context.getTypeManager().printType(type_id, this->context);

			infos.emplace_back(std::move(alias_of_str));
		}
	}


	template<SemanticAnalyzer::SpecialMemberFailKind MEMBER>
	auto SemanticAnalyzer::diagnostic_print_special_member_fail(
		TypeInfo::ID type_id, evo::SmallVector<Diagnostic::Info>& infos
	) -> void {
		const TypeInfo& type_info = this->context.getTypeManager().getTypeInfo(type_id);

		switch(type_info.baseTypeID().kind()){
			case BaseType::Kind::ARRAY: {
				const BaseType::Array& array_type =
					this->context.getTypeManager().getArray(type_info.baseTypeID().arrayID());

				this->diagnostic_print_special_member_fail<MEMBER>(array_type.elementTypeID, infos);
			} break;

			case BaseType::Kind::ALIAS: {
				const BaseType::Alias& alias_type =
					this->context.getTypeManager().getAlias(type_info.baseTypeID().aliasID());

				this->diagnostic_print_special_member_fail<MEMBER>(alias_type.aliasedType, infos);
			} break;

			case BaseType::Kind::DISTINCT_ALIAS: {
				const BaseType::DistinctAlias& distinct_alias_type =
					this->context.getTypeManager().getDistinctAlias(type_info.baseTypeID().distinctAliasID());

				this->diagnostic_print_special_member_fail<MEMBER>(distinct_alias_type.underlyingType, infos);
			} break;

			case BaseType::Kind::STRUCT: {
				const BaseType::Struct& struct_type =
					this->context.getTypeManager().getStruct(type_info.baseTypeID().structID());

				using DeletableOverloadState = BaseType::Struct::DeletableOverload::State;

				const DeletableOverloadState state = [&]() -> DeletableOverloadState {
					if constexpr(MEMBER == SpecialMemberFailKind::COPY){
						return struct_type.copyInitOverload.load().state;
					}else{
						return struct_type.moveInitOverload.load().state;
					}
				}();

				switch(state){
					case DeletableOverloadState::NOT_DELETED: {
						evo::debugFatalBreak("Struct sepcial member wasn't deleted");
					} break;

					case DeletableOverloadState::EXPLICITLY_DELETED: {
						if constexpr(MEMBER == SpecialMemberFailKind::COPY){
							infos.emplace_back("Operator [copy] was explicitly deleted");
						}else{
							infos.emplace_back("Operator [move] was explicitly deleted");
						}
					} break;

					case DeletableOverloadState::IMPLICIT_MEMBER_DELETED: {
						if constexpr(MEMBER == SpecialMemberFailKind::COPY){
							infos.emplace_back(
								"Operator [copy] was not generated by the compiler due to one or more of the members "
									"being not copyable"
							);
						}else{
							infos.emplace_back(
								"Operator [move] was not generated by the compiler due to one or more of the members "
									"being not movable"
							);
						}
					} break;

					case DeletableOverloadState::IMPLICIT_OTHER_EXPLICITLY_DELETED: {
						if constexpr(MEMBER == SpecialMemberFailKind::COPY){
							infos.emplace_back(
								"Operator [copy] was not generated by the compiler due to operator [move] being "
									"explicitly deleted"
							);
						}else{
							infos.emplace_back(
								"Operator [move] was not generated by the compiler due to operator [copy] being "
									"explicitly deleted"
							);
						}
					} break;
				}

				infos.emplace_back(
					std::format("Type: {}", this->context.getTypeManager().printType(type_id, this->context))
				);
			} break;

			case BaseType::Kind::UNION: {
				const BaseType::Union& union_type =
					this->context.getTypeManager().getUnion(type_info.baseTypeID().unionID());

				evo::debugAssert(union_type.isUntagged == false, "untagged unions are always copyable");

				unsigned num_not_supported = 0;
				for(const BaseType::Union::Field& field : union_type.fields){
					if(field.typeID.isVoid()){ continue; }

					if constexpr(MEMBER == SpecialMemberFailKind::COPY){
						if(this->context.getTypeManager().isCopyable(field.typeID.asTypeID()) == false){
							num_not_supported += 1;
						}
					}else{
						if(this->context.getTypeManager().isMovable(field.typeID.asTypeID()) == false){
							num_not_supported += 1;
						}
					}
				}

				if constexpr(MEMBER == SpecialMemberFailKind::COPY){
					infos.emplace_back(
						std::format(
							"{} union field{} are not copyable",
							num_not_supported,
							num_not_supported > 1 ? "s" : ""
						)
					);
				}else{
					infos.emplace_back(
						std::format(
							"{} union field{} are not movable",
							num_not_supported,
							num_not_supported > 1 ? "s" : ""
						)
					);
				}

				infos.emplace_back(
					std::format("Type: {}", this->context.getTypeManager().printType(type_id, this->context))
				);
			} break;

			case BaseType::Kind::INTERFACE_MAP: {
				const BaseType::InterfaceMap& interface_map_type =
					this->context.getTypeManager().getInterfaceMap(type_info.baseTypeID().interfaceMapID());

				this->diagnostic_print_special_member_fail<MEMBER>(interface_map_type.underlyingTypeID, infos);
			} break;

			default: evo::debugFatalBreak("Unknown type kind that is not support this special member");
		}
	}




	auto SemanticAnalyzer::check_type_qualifiers(evo::ArrayProxy<TypeInfo::Qualifier> qualifiers, const auto& location)
	-> evo::Result<> {
		bool found_read_only_ptr = false;
		for(ptrdiff_t i = qualifiers.size() - 1; i >= 0; i-=1){
			const TypeInfo::Qualifier& qualifier = qualifiers[i];

			if(found_read_only_ptr){
				if(qualifier.isPtr && qualifier.isMut){
					this->emit_error(
						Diagnostic::Code::SEMA_INVALID_TYPE_QUALIFIERS,
						location,
						"Invalid type qualifiers",
						Diagnostic::Info(
							"If one type qualifier level is a not mut-qualified pointer, "
							"all previous pointer qualifier levels must not also be mut-qualified"
						)
					);
					return evo::resultError;
				}

			}else if(qualifier.isPtr && qualifier.isMut == false){
				found_read_only_ptr = true;
			}
		}
		return evo::Result<>();
	}



	auto SemanticAnalyzer::check_term_isnt_type(const TermInfo& term_info, const auto& location) -> evo::Result<> {
		if(term_info.value_category == TermInfo::ValueCategory::TYPE){
			this->emit_error(Diagnostic::Code::SEMA_TYPE_USED_AS_EXPR, location, "Type used as an expression");
			return evo::resultError;
		}

		return evo::Result<>();
	}



	auto SemanticAnalyzer::add_ident_to_scope(
		sema::ScopeManager::Scope& target_scope,
		std::string_view ident_str,
		const auto& ast_node,
		bool include_shadow_checks,
		auto&&... ident_id_info
	) -> evo::Result<> {
		sema::ScopeLevel& current_scope_level = 
			this->context.sema_buffer.scope_manager.getLevel(target_scope.getCurrentLevel());

		const sema::ScopeLevel::AddIdentResult add_ident_result = current_scope_level.addIdent(
			ident_str, std::forward<decltype(ident_id_info)>(ident_id_info)...
		);

		if(add_ident_result.has_value() == false){
			const bool is_shadow_redef = add_ident_result.error();
			if(is_shadow_redef){
				const sema::ScopeLevel::IdentID& shadowed_ident =
					*current_scope_level.lookupDisallowedIdentForShadowing(ident_str);

				shadowed_ident.visit([&](const auto& first_decl_ident_id) -> void {
					using IdentIDType = std::decay_t<decltype(first_decl_ident_id)>;


					const Diagnostic::Location first_ident_location = [&]() -> Diagnostic::Location {
						if constexpr(
							std::is_same<IdentIDType, sema::ScopeLevel::FuncOverloadList>()
							|| std::is_same<IdentIDType, sema::ScopeLevel::MethodOverloadList>()
						){
							return first_decl_ident_id.funcs.front().visit(
								[&](const auto& func_id) -> Diagnostic::Location { return this->get_location(func_id); }
							);

						}else{
							return this->get_location(first_decl_ident_id);
						}
					}();
					
					this->emit_error(
						Diagnostic::Code::SEMA_IDENT_ALREADY_IN_SCOPE,
						ast_node,
						std::format("Identifier \"{}\" was already defined in this scope", ident_str),
						evo::SmallVector<Diagnostic::Info>{
							Diagnostic::Info("First defined here:", std::move(first_ident_location)),
							Diagnostic::Info("Note: shadowing is not allowed")
						}
					);
				});

			}else{
				this->error_already_defined<false>(
					ast_node,
					ident_str,
					*current_scope_level.lookupIdent(ident_str)
				);
			}

			return evo::resultError;
		}

		if(include_shadow_checks && current_scope_level.doesShadowingChecks()){
			for(auto iter = std::next(target_scope.begin()); iter != target_scope.end(); ++iter){
				sema::ScopeLevel& scope_level = this->context.sema_buffer.scope_manager.getLevel(*iter);
				if(scope_level.disallowIdentForShadowing(ident_str, add_ident_result.value()) == false){
					this->error_already_defined<true>(
						ast_node,
						ident_str,
						*scope_level.lookupIdent(ident_str)
					);
					return evo::resultError;
				}
			}
		}

		return evo::Result<>();
	}


	template<bool IS_SHADOWING>
	auto SemanticAnalyzer::error_already_defined_impl(
		const auto& redef_id,
		std::string_view ident_str,
		const sema::ScopeLevel::IdentID& first_defined_id,
		std::optional<sema::Func::ID> attempted_decl_func_id
	)  -> void {
		first_defined_id.visit([&](const auto& first_decl_ident_id) -> void {
			using IdentIDType = std::decay_t<decltype(first_decl_ident_id)>;

			static constexpr bool IS_FUNC_OVERLOAD_COLLISION = 
				std::is_same<std::remove_cvref_t<std::decay_t<decltype(redef_id)>>, pcit::panther::AST::FuncDef>() 
				&& 	(
						std::is_same<IdentIDType, sema::ScopeLevel::FuncOverloadList>()
						|| std::is_same<IdentIDType, sema::ScopeLevel::MethodOverloadList>()
					)
				&& !IS_SHADOWING;

			auto infos = evo::SmallVector<Diagnostic::Info>();

			if constexpr(IS_FUNC_OVERLOAD_COLLISION){
				const sema::Func& attempted_decl_func = this->context.getSemaBuffer().getFunc(*attempted_decl_func_id);

				for(const sema::ScopeLevel::Overload& overload_id : first_decl_ident_id.funcs){
					if(overload_id.is<sema::TemplatedFunc::ID>()){ continue; }

					const sema::Func& overload = this->context.sema_buffer.getFunc(overload_id.as<sema::Func::ID>());
					if(attempted_decl_func.isEquivalentOverload(overload, this->context)){
						// TODO(FUTURE): better messaging
						infos.emplace_back(
							"Overload collided with:", this->get_location(overload_id.as<sema::Func::ID>())
						);
						break;
					}
				}
				
			}else if constexpr(
				std::is_same<IdentIDType, sema::ScopeLevel::FuncOverloadList>()
				|| std::is_same<IdentIDType, sema::ScopeLevel::MethodOverloadList>()
			){
				first_decl_ident_id.funcs.front().visit([&](const auto& func_id) -> void {
					if(first_decl_ident_id.funcs.size() == 1){
						infos.emplace_back("First defined here:", this->get_location(func_id));

					}else if(first_decl_ident_id.funcs.size() == 2){
						infos.emplace_back(
							"First defined here (and 1 other place):", this->get_location(func_id)
						);
					}else{
						infos.emplace_back(
							std::format(
								"First defined here (and {} other places):", first_decl_ident_id.funcs.size() - 1
							),
							this->get_location(func_id)
						);
					}
				});

			}else{
				infos.emplace_back("First defined here:", this->get_location(first_decl_ident_id));
			}


			if constexpr(IS_SHADOWING){
				infos.emplace_back("Note: shadowing is not allowed");
			}

			if constexpr(IS_FUNC_OVERLOAD_COLLISION){
				this->emit_error(
					Diagnostic::Code::SEMA_IDENT_ALREADY_IN_SCOPE,
					redef_id,
					std::format("Function \"{}\" has an overload that collides with this declaration", ident_str),
					std::move(infos)
				);
			}else{
				this->emit_error(
					Diagnostic::Code::SEMA_IDENT_ALREADY_IN_SCOPE,
					redef_id,
					std::format("Identifier \"{}\" was already defined in this scope", ident_str),
					std::move(infos)
				);
			}
		});
	};



	auto SemanticAnalyzer::print_term_type(
		const TermInfo& term_info, std::optional<unsigned> multi_type_index
	) const -> std::string {
		return term_info.type_id.visit([&](const auto& type_id) -> std::string {
			using TypeID = std::decay_t<decltype(type_id)>;

			if constexpr(std::is_same<TypeID, TermInfo::InitializerType>()){
				return "{INITIALIZER}";

			}else if constexpr(std::is_same<TypeID, TermInfo::NullType>()){	
				return "{NULL}";

			}else if constexpr(std::is_same<TypeID, TermInfo::ExprDeducerType>()){	
				return "{EXPR DEDUCER}";
				
			}else if constexpr(std::is_same<TypeID, TermInfo::FluidType>()){
				if(term_info.getExpr().kind() == sema::Expr::Kind::INT_VALUE){
					return "{FLUID INTEGRAL}";
				}else{
					evo::debugAssert(
						term_info.getExpr().kind() == sema::Expr::Kind::FLOAT_VALUE, "Unsupported fluid type"
					);
					return "{FLUID FLOAT}";
				}
				
			}else if constexpr(std::is_same<TypeID, TypeInfo::ID>()){
				return this->context.getTypeManager().printType(type_id, this->context);

			}else if constexpr(std::is_same<TypeID, TermInfo::BuiltinTypeMethod>()){
				return "{BUILTIN TYPE METHOD}";

			}else if constexpr(std::is_same<TypeID, TermInfo::FuncOverloadList>()){
				// TODO(FEATURE): actual name
				return "{FUNCTION}";

			}else if constexpr(std::is_same<TypeID, TypeInfo::VoidableID>()){
				return this->context.getTypeManager().printType(type_id, this->context);

			}else if constexpr(std::is_same<TypeID, evo::SmallVector<TypeInfo::ID>>()){
				return this->context.getTypeManager().printType(type_id[*multi_type_index], this->context);

			}else if constexpr(std::is_same<TypeID, Source::ID>()){
				// TODO(FEATURE): actual module name?
				return "{MODULE}";

			}else if constexpr(std::is_same<TypeID, ClangSource::ID>()){
				// TODO(FEATURE): actual name?
				return "{CLANG MODULE}";

			}else if constexpr(std::is_same<TypeID, BuiltinModule::ID>()){
				// TODO(FEATURE): actual name?
				return "{BUILTIN MODULE}";

			}else if constexpr(std::is_same<TypeID, sema::TemplatedStruct::ID>()){
				// TODO(FEATURE): actual name
				return "{TEMPLATED STRUCT}";

			}else if constexpr(std::is_same<TypeID, sema::StructTemplateAlias::ID>()){
				// TODO(FEATURE): actual name
				return "{STRUCT TEMPLATE ALIAS}";

			}else if constexpr(std::is_same<TypeID, TemplateIntrinsicFunc::Kind>()){
				// TODO(FEATURE): actual name
				return "{TEMPLATE INTRINSIC FUNC}";

			}else if constexpr(std::is_same<TypeID, TermInfo::TemplateDeclInstantiationType>()){
				// TODO(FEATURE): actual name?
				return "{TEMPLATE DECL INSTANTIATION TYPE}";

			}else if constexpr(std::is_same<TypeID, TermInfo::ExceptParamPack>()){
				return "{EXCEPT PARAM PACK}";

			}else if constexpr(std::is_same<TypeID, TermInfo::TaggedUnionFieldAccessor>()){
				// TODO(FEATURE): actual name?
				return "{TAGGED UNION FIELD ACCESSOR}";

			}else if constexpr(std::is_same<TypeID, TermInfo::VariadicParamTypes>()){
				// TODO(FEATURE): actual name?
				return "{VARIADIC PARAM}";

			}else{
				static_assert(false, "Unsupported type id kind");
			}
		});
	}



	auto SemanticAnalyzer::check_scope_isnt_terminated(const auto& location) -> evo::Result<> {
		if(this->get_current_scope_level().isTerminated() == false){ return evo::Result<>(); }

		this->emit_error(
			Diagnostic::Code::SEMA_SCOPE_IS_ALREADY_TERMINATED,
			location,
			"Scope is already terminated"
		);
		return evo::resultError;
	}


}